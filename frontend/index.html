<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dispatch App</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #0a0a0b;
      --bg-secondary: #111113;
      --bg-tertiary: #1a1a1d;
      --bg-hover: #222225;
      --border: #2a2a2d;
      --border-light: #3a3a3d;
      --text-primary: #e8e8ea;
      --text-secondary: #a0a0a5;
      --text-muted: #606065;
      --accent-blue: #3b82f6;
      --accent-green: #22c55e;
      --accent-amber: #f59e0b;
      --accent-red: #ef4444;
      --accent-purple: #a855f7;
      --accent-cyan: #06b6d4;
      
      --duty-driving: #3b82f6;
      --duty-oov: #f59e0b;
      --duty-break: #22c55e;
      --duty-waiting: #64748b;
      --duty-charter: #a855f7;
      --duty-dead: #ef4444;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
    }

    .header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 12px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header-left { display: flex; align-items: center; gap: 24px; }

    .menu-toggle {
      display: none;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
    }
    
    .menu-toggle:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }
    
    body.nav-collapsed .menu-toggle {
      display: block;
    }

    .logo {
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
      font-size: 14px;
      color: var(--accent-cyan);
    }

    .date-nav { display: flex; align-items: center; gap: 12px; }

    .date-nav button {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      width: 32px;
      height: 32px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .date-nav button:hover { background: var(--bg-hover); color: var(--text-primary); }
    .current-date { font-weight: 600; font-size: 15px; min-width: 160px; text-align: center; }

    .depot-filter { display: flex; align-items: center; gap: 8px; }
    .depot-filter-label { font-size: 12px; color: var(--text-secondary); }

    .depot-select, .style-select {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
    }

    .depot-select { min-width: 160px; }
    .depot-select:focus, .style-select:focus { outline: none; border-color: var(--accent-blue); }

    .header-right { display: flex; align-items: center; gap: 12px; }

    .style-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .style-toggle-label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .btn-primary {
      background: var(--accent-blue);
      border: none;
      color: white;
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .btn-primary:hover { background: #2563eb; }
    
    .btn-ai {
      background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 50%, #d946ef 100%);
      border: none;
      color: white;
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }
    
    .btn-ai:hover { 
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(168, 85, 247, 0.4);
    }
    
    /* AI Assistant Modal */
    .ai-modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 999;
    }
    
    .ai-modal-overlay.show { display: block; }
    
    .ai-assistant {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      max-width: 90vw;
      max-height: 80vh;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      z-index: 1000;
      flex-direction: column;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
    }
    
    .ai-assistant.show { display: flex; }
    
    .ai-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
    }
    
    .ai-title {
      font-weight: 600;
      font-size: 15px;
      background: linear-gradient(135deg, #a855f7, #d946ef);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .ai-close {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 18px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    .ai-close:hover { background: var(--bg-hover); color: var(--text-primary); }
    
    .ai-messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 200px;
      max-height: 400px;
    }
    
    .ai-message {
      display: flex;
      flex-direction: column;
    }
    
    .ai-message.user { align-items: flex-end; }
    .ai-message.assistant { align-items: flex-start; }
    
    .ai-message-content {
      max-width: 85%;
      padding: 10px 14px;
      border-radius: 12px;
      font-size: 13px;
      line-height: 1.5;
    }
    
    .ai-message.user .ai-message-content {
      background: var(--accent-blue);
      color: white;
      border-bottom-right-radius: 4px;
    }
    
    .ai-message.assistant .ai-message-content {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border-bottom-left-radius: 4px;
    }
    
    .ai-message.assistant .ai-message-content ul {
      margin-left: 16px;
    }
    
    .ai-message.loading .ai-message-content {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-typing {
      display: flex;
      gap: 4px;
    }
    
    .ai-typing span {
      width: 6px;
      height: 6px;
      background: var(--text-muted);
      border-radius: 50%;
      animation: typing 1.4s infinite;
    }
    
    .ai-typing span:nth-child(2) { animation-delay: 0.2s; }
    .ai-typing span:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.5; }
      30% { transform: translateY(-4px); opacity: 1; }
    }
    
    .ai-input-area {
      display: flex;
      gap: 10px;
      padding: 16px 20px;
      border-top: 1px solid var(--border);
    }
    
    .ai-input {
      flex: 1;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 13px;
      font-family: inherit;
    }
    
    .ai-input:focus {
      outline: none;
      border-color: var(--accent-purple);
    }
    
    .ai-input::placeholder { color: var(--text-muted); }
    
    .ai-send {
      background: linear-gradient(135deg, #8b5cf6, #a855f7);
      border: none;
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .ai-send:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);
    }
    
    .ai-send:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .ai-footer {
      padding: 10px 20px;
      text-align: center;
      font-size: 10px;
      color: var(--text-muted);
      border-top: 1px solid var(--border);
    }

    .stats-bar {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 12px 24px;
      display: flex;
      gap: 32px;
    }

    .stat-item { display: flex; align-items: center; gap: 10px; }
    .stat-indicator { width: 10px; height: 10px; border-radius: 50%; }
    .stat-indicator.green { background: var(--accent-green); }
    .stat-indicator.amber { background: var(--accent-amber); }
    .stat-indicator.red { background: var(--accent-red); }
    .stat-indicator.blue { background: var(--accent-blue); }
    .stat-indicator.purple { background: var(--accent-purple); }
    .stat-label { font-size: 13px; color: var(--text-secondary); }
    .stat-value { font-weight: 600; font-size: 14px; font-family: 'JetBrains Mono', monospace; }

    .main-content { display: flex; height: calc(100vh - 110px); }
    .heatmap-view { display: flex; width: 100%; height: 100%; }
    .heatmap-left { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

    .heatmap-section {
      display: flex;
      flex-direction: column;
      border-bottom: 1px solid var(--border);
      overflow: hidden;
      transition: flex 0.3s ease;
      min-height: 44px;
    }

    .heatmap-section:last-child { border-bottom: none; }
    .heatmap-section.collapsed { flex: 0 0 44px !important; min-height: 44px; max-height: 44px; }
    .heatmap-section.collapsed .timeline-header,
    .heatmap-section.collapsed .heatmap-rows { display: none; }
    .heatmap-section.expanded { flex: 3 !important; }
    .heatmap-section.resizing { transition: none; }

    /* Resize handles between sections */
    .section-resize-handle {
      height: 8px;
      background: var(--border);
      cursor: ns-resize;
      position: relative;
      flex-shrink: 0;
      transition: background 0.2s;
      z-index: 10;
    }
    
    .section-resize-handle:hover,
    .section-resize-handle.active {
      background: var(--accent-blue);
    }
    
    .section-resize-handle::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 40px;
      height: 4px;
      background: var(--text-muted);
      border-radius: 2px;
      opacity: 0.5;
      transition: opacity 0.2s;
    }
    
    .section-resize-handle:hover::after,
    .section-resize-handle.active::after {
      opacity: 1;
      background: white;
    }

    #driversSection { flex: 1.2; }
    #vehiclesSection { flex: 1; }
    #unassignedSection { flex: 0.6; min-height: 120px; }

    .section-header {
      background: var(--bg-tertiary);
      padding: 10px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      cursor: pointer;
      user-select: none;
    }

    .section-header:hover { background: var(--bg-hover); }
    .section-header-left { display: flex; align-items: center; gap: 12px; }
    .section-toggle { color: var(--text-muted); font-size: 10px; transition: transform 0.2s; }
    .heatmap-section.collapsed .section-toggle { transform: rotate(-90deg); }

    .section-title {
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section-count {
      background: var(--bg-hover);
      padding: 2px 8px;
      border-radius: 10px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
    }

    .section-controls { display: flex; align-items: center; gap: 8px; }
    .section-stats { display: flex; gap: 16px; font-size: 12px; margin-right: 16px; }
    .section-stat { display: flex; align-items: center; gap: 4px; }
    .mini-dot { width: 6px; height: 6px; border-radius: 50%; }
    .mini-dot.green { background: var(--accent-green); }
    .mini-dot.red { background: var(--accent-red); }
    .mini-dot.amber { background: var(--accent-amber); }

    .section-btn {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      width: 28px;
      height: 28px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .section-btn:hover { background: var(--bg-hover); color: var(--text-primary); }

    .timeline-header {
      display: flex;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .timeline-label-col {
      width: 140px;
      min-width: 140px;
      padding: 6px 12px;
      font-size: 11px;
      color: var(--text-muted);
      border-right: 1px solid var(--border);
    }

    .timeline-hours { display: flex; flex: 1; }

    .timeline-hour {
      flex: 1;
      text-align: center;
      font-size: 10px;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-muted);
      padding: 6px 0;
      border-right: 1px solid var(--border);
    }

    .timeline-hour:last-child { border-right: none; }
    .heatmap-rows { flex: 1; overflow-y: auto; }

    .heatmap-row {
      display: flex;
      border-bottom: 1px solid var(--border);
      height: 38px;
      cursor: pointer;
      transition: background 0.1s;
    }

    .heatmap-row:hover { background: var(--bg-hover); }
    .heatmap-row.selected { background: rgba(59, 130, 246, 0.15); }
    .heatmap-row.nav-highlight, .vertical-column.nav-highlight { 
      box-shadow: inset 0 0 0 2px var(--accent-blue);
    }

    .row-label {
      width: 140px;
      min-width: 140px;
      padding: 0 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      border-right: 1px solid var(--border);
      overflow: hidden;
    }

    .row-status { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
    .row-status.available { background: var(--accent-green); }
    .row-status.busy { background: var(--accent-blue); }
    .row-status.leave { background: var(--accent-red); }
    .row-status.maintenance { background: var(--accent-amber); }
    .row-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .row-timeline { flex: 1; display: flex; position: relative; }

    /* ============================================
       STYLE A: Original (Fragmented)
       ============================================ */
    .style-a .timeline-duty {
      position: absolute;
      top: 4px;
      height: 20px;
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      font-weight: 500;
      overflow: hidden;
      white-space: nowrap;
      color: white;
      min-width: 2px;
      cursor: pointer;
    }
    
    /* Hide text in narrow blocks, show on hover via tooltip */
    .style-a .timeline-duty .duty-text {
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
      padding: 0 2px;
    }
    
    /* Tooltip for all timeline duties */
    .timeline-duty-tooltip {
      position: absolute;
      top: calc(100% + 4px);
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 10px;
      min-width: 160px;
      max-width: 250px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity 0.15s, visibility 0.15s;
      font-size: 11px;
      line-height: 1.4;
      color: var(--text-primary);
      text-align: left;
    }
    
    .timeline-duty:hover .timeline-duty-tooltip {
      opacity: 1;
      visibility: visible;
    }
    
    .timeline-duty-tooltip::after {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-bottom-color: var(--border-color);
    }
    
    .timeline-duty-tooltip .tooltip-title {
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--text-primary);
    }
    
    .timeline-duty-tooltip .tooltip-row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      color: var(--text-secondary);
    }
    
    .timeline-duty-tooltip .tooltip-label {
      color: var(--text-muted);
    }
    
    .timeline-duty-tooltip .tooltip-value {
      font-family: 'JetBrains Mono', monospace;
      font-weight: 500;
    }

    .style-a .timeline-duty.driving { background: var(--duty-driving); }
    .style-a .timeline-duty.oov { background: var(--duty-oov); color: #000; }
    .style-a .timeline-duty.break { background: var(--duty-break); color: #000; }
    .style-a .timeline-duty.waiting { background: var(--duty-waiting); }
    .style-a .timeline-duty.charter { background: var(--duty-charter); }
    .style-a .timeline-duty.dead { background: var(--duty-dead); }
    .style-a .timeline-duty.leave { background: var(--accent-red); }
    .style-a .timeline-duty.maintenance { background: var(--accent-amber); color: #000; }

    .style-a .vehicle-status-bar {
      position: absolute;
      bottom: 4px;
      height: 4px;
      border-radius: 1px;
      background: var(--accent-green);
    }

    .style-a .shift-label {
      position: absolute;
      top: 4px;
      height: 20px;
      display: flex;
      align-items: center;
      padding: 0 6px;
      font-size: 9px;
      font-weight: 600;
      color: white;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
      z-index: 5;
    }

    /* ============================================
       STYLE B: Unified bar with subtle segments
       ============================================ */
    .style-b .shift-bar {
      position: absolute;
      top: 2px;
      height: 32px;
      border-radius: 4px;
    }

    .style-b .shift-bar.regular { background: #1e3a5f; }
    .style-b .shift-bar.charter { background: #3d2663; }
    .style-b .shift-bar.maintenance { background: #78350f; }
    .style-b .shift-bar.adhoc { background: #065f46; }

    .style-b .shift-bar .segment {
      position: absolute;
      top: 0;
      height: calc(100% - 10px);
    }

    .style-b .shift-bar .segment.driving { background: rgba(59, 130, 246, 0.6); }
    .style-b .shift-bar .segment.oov { background: rgba(245, 158, 11, 0.3); }
    .style-b .shift-bar .segment.break { background: rgba(34, 197, 94, 0.3); }
    .style-b .shift-bar .segment.waiting { background: rgba(100, 116, 139, 0.3); }
    .style-b .shift-bar .segment.dead { background: rgba(239, 68, 68, 0.4); }
    .style-b .shift-bar .segment.charter { background: rgba(168, 85, 247, 0.5); }

    .style-b .shift-bar .shift-label {
      position: absolute;
      left: 8px;
      right: 8px;
      top: 0;
      height: calc(100% - 10px);
      display: flex;
      align-items: center;
      font-size: 10px;
      font-weight: 600;
      color: white;
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
      z-index: 5;
      pointer-events: none;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    /* Tooltip for shift bars */
    .shift-bar .shift-tooltip {
      position: absolute;
      top: calc(100% + 4px);
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 10px;
      min-width: 180px;
      max-width: 280px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity 0.15s, visibility 0.15s;
      font-size: 11px;
      line-height: 1.4;
      color: var(--text-primary);
      text-align: left;
    }
    
    .shift-bar:hover .shift-tooltip {
      opacity: 1;
      visibility: visible;
    }
    
    .shift-bar .shift-tooltip::after {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-bottom-color: var(--border-color);
    }
    
    .shift-bar .shift-tooltip .tooltip-title {
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--text-primary);
    }
    
    .shift-bar .shift-tooltip .tooltip-row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      color: var(--text-secondary);
    }
    
    .shift-bar .shift-tooltip .tooltip-label {
      color: var(--text-muted);
    }
    
    .shift-bar .shift-tooltip .tooltip-value {
      font-family: 'JetBrains Mono', monospace;
      font-weight: 500;
    }
    
    .shift-bar .shift-tooltip .tooltip-duties {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid var(--border-color);
      font-size: 10px;
    }
    
    .shift-bar .shift-tooltip .tooltip-duty {
      display: flex;
      gap: 6px;
      padding: 2px 0;
    }
    
    .shift-bar .shift-tooltip .tooltip-duty-type {
      width: 6px;
      height: 6px;
      border-radius: 2px;
      margin-top: 4px;
      flex-shrink: 0;
    }
    
    .shift-bar .shift-tooltip .tooltip-duty-type.driving { background: var(--duty-driving); }
    .shift-bar .shift-tooltip .tooltip-duty-type.oov { background: var(--duty-oov); }
    .shift-bar .shift-tooltip .tooltip-duty-type.break { background: var(--duty-break); }
    .shift-bar .shift-tooltip .tooltip-duty-type.waiting { background: var(--duty-waiting); }
    .shift-bar .shift-tooltip .tooltip-duty-type.charter { background: var(--duty-charter); }
    .shift-bar .shift-tooltip .tooltip-duty-type.dead { background: var(--duty-dead); }

    .style-b .shift-bar .vehicle-strip {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 10px;
      background: rgba(0,0,0,0.4);
      border-radius: 0 0 4px 4px;
      overflow: hidden;
    }
    
    .style-b .shift-bar .vehicle-segment {
      position: absolute;
      top: 0;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 7px;
      font-weight: 600;
      color: #1a1a1a;
      overflow: hidden;
      white-space: nowrap;
    }
    
    .style-b .shift-bar .vehicle-segment.assigned {
      background: #6ee7b7;
    }
    
    .style-b .shift-bar .vehicle-segment.missing {
      background: #fca5a5;
      color: #7f1d1d;
    }
    
    .style-b .shift-bar .vehicle-segment.none {
      background: transparent;
      color: transparent;
    }

    .style-b .timeline-duty.leave {
      position: absolute;
      top: 6px;
      height: 24px;
      border-radius: 4px;
      background: var(--accent-red);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      font-weight: 500;
    }

    /* ============================================
       STYLE C: Gradient/opacity approach
       ============================================ */
    .style-c .shift-bar {
      position: absolute;
      top: 2px;
      height: 32px;
      border-radius: 6px;
      background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .style-c .shift-bar.charter {
      background: linear-gradient(135deg, #6b21a8 0%, #a855f7 100%);
    }

    .style-c .shift-bar.maintenance {
      background: linear-gradient(135deg, #92400e 0%, #f59e0b 100%);
    }

    .style-c .shift-bar.adhoc {
      background: linear-gradient(135deg, #065f46 0%, #10b981 100%);
    }

    .style-c .shift-bar .segment {
      position: absolute;
      top: 0;
      height: calc(100% - 10px);
    }

    .style-c .shift-bar .segment.driving { background: rgba(255,255,255,0.15); }
    .style-c .shift-bar .segment.oov { background: rgba(0,0,0,0.2); }
    .style-c .shift-bar .segment.break { background: rgba(34, 197, 94, 0.3); }
    .style-c .shift-bar .segment.waiting { background: rgba(0,0,0,0.35); }
    .style-c .shift-bar .segment.dead { background: rgba(239, 68, 68, 0.3); }

    .style-c .shift-bar .shift-label {
      position: absolute;
      left: 10px;
      right: 10px;
      top: 0;
      height: calc(100% - 10px);
      display: flex;
      align-items: center;
      font-size: 10px;
      font-weight: 600;
      color: white;
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
      z-index: 5;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .style-c .shift-bar .vehicle-strip {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 10px;
      background: rgba(0,0,0,0.4);
      border-radius: 0 0 6px 6px;
      overflow: hidden;
    }
    
    .style-c .shift-bar .vehicle-segment {
      position: absolute;
      top: 0;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 7px;
      font-weight: 600;
      color: #1a1a1a;
      overflow: hidden;
      white-space: nowrap;
    }
    
    .style-c .shift-bar .vehicle-segment.assigned {
      background: #6ee7b7;
    }
    
    .style-c .shift-bar .vehicle-segment.missing {
      background: #fca5a5;
      color: #7f1d1d;
    }
    
    .style-c .shift-bar .vehicle-segment.none {
      background: transparent;
      color: transparent;
    }

    .style-c .timeline-duty.leave {
      position: absolute;
      top: 6px;
      height: 24px;
      border-radius: 6px;
      background: linear-gradient(135deg, #991b1b 0%, #ef4444 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      font-weight: 500;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    /* ============================================
       STYLE D: Outline style
       ============================================ */
    .style-d .shift-bar {
      position: absolute;
      top: 2px;
      height: 32px;
      border-radius: 4px;
      border: 2px solid var(--accent-blue);
      background: transparent;
    }

    .style-d .shift-bar.charter {
      border-color: var(--accent-purple);
    }

    .style-d .shift-bar.maintenance {
      border-color: var(--accent-amber);
      background: rgba(245, 158, 11, 0.1);
    }

    .style-d .shift-bar.adhoc {
      border-color: var(--accent-green);
      background: rgba(34, 197, 94, 0.1);
    }

    .style-d .shift-bar .segment {
      position: absolute;
      top: 0;
      height: calc(100% - 10px);
    }

    .style-d .shift-bar .segment.driving { background: rgba(59, 130, 246, 0.4); }
    .style-d .shift-bar .segment.oov { background: transparent; }
    .style-d .shift-bar .segment.break { background: rgba(34, 197, 94, 0.2); }
    .style-d .shift-bar .segment.waiting { background: transparent; }
    .style-d .shift-bar .segment.dead { background: rgba(239, 68, 68, 0.2); }

    .style-d .shift-bar .shift-label {
      position: absolute;
      left: 8px;
      right: 8px;
      top: 0;
      height: calc(100% - 10px);
      display: flex;
      align-items: center;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-primary);
      z-index: 5;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .style-d .shift-bar.charter .shift-label {
      color: var(--accent-purple);
    }

    .style-d .shift-bar.maintenance .shift-label {
      color: var(--accent-amber);
    }

    .style-d .shift-bar.adhoc .shift-label {
      color: var(--accent-green);
    }

    .style-d .shift-bar .vehicle-strip {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 10px;
      background: rgba(0,0,0,0.15);
      border-radius: 0 0 4px 4px;
      overflow: hidden;
    }
    
    .style-d .shift-bar .vehicle-segment {
      position: absolute;
      top: 0;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 7px;
      font-weight: 600;
      color: #1a1a1a;
      overflow: hidden;
      white-space: nowrap;
    }
    
    .style-d .shift-bar .vehicle-segment.assigned {
      background: #6ee7b7;
    }
    
    .style-d .shift-bar .vehicle-segment.missing {
      background: #fca5a5;
      color: #7f1d1d;
    }
    
    .style-d .shift-bar .vehicle-segment.none {
      background: transparent;
      color: transparent;
    }

    .style-d .timeline-duty.leave {
      position: absolute;
      top: 6px;
      height: 24px;
      border-radius: 4px;
      border: 2px solid var(--accent-red);
      background: rgba(239, 68, 68, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent-red);
      font-size: 10px;
      font-weight: 500;
    }

    /* ============================================
       STYLE E: Modern pill style
       ============================================ */
    .style-e .shift-bar {
      position: absolute;
      top: 2px;
      height: 32px;
      border-radius: 11px;
      background: #1e293b;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
    }

    .style-e .shift-bar.maintenance {
      background: linear-gradient(180deg, #fbbf24 0%, #d97706 100%);
    }

    .style-e .shift-bar.maintenance .shift-label {
      color: #000;
      text-shadow: none;
    }

    .style-e .shift-bar .segment {
      position: absolute;
      top: 2px;
      height: calc(100% - 14px);
      border-radius: 9px;
    }

    .style-e .shift-bar .segment.driving { background: linear-gradient(180deg, #60a5fa 0%, #3b82f6 100%); }
    .style-e .shift-bar .segment.oov { background: linear-gradient(180deg, #fbbf24 0%, #f59e0b 100%); opacity: 0.6; }
    .style-e .shift-bar .segment.break { background: linear-gradient(180deg, #4ade80 0%, #22c55e 100%); opacity: 0.7; }
    .style-e .shift-bar .segment.waiting { background: #475569; }
    .style-e .shift-bar .segment.dead { background: linear-gradient(180deg, #f87171 0%, #ef4444 100%); opacity: 0.7; }
    .style-e .shift-bar .segment.charter { background: linear-gradient(180deg, #c084fc 0%, #a855f7 100%); }

    .style-e .shift-bar .shift-label {
      position: absolute;
      left: 12px;
      right: 12px;
      top: 0;
      height: calc(100% - 10px);
      display: flex;
      align-items: center;
      font-size: 9px;
      font-weight: 600;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
      z-index: 5;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .style-e .shift-bar .vehicle-strip {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 10px;
      background: rgba(0,0,0,0.4);
      border-radius: 0 0 11px 11px;
      overflow: hidden;
    }
    
    .style-e .shift-bar .vehicle-segment {
      position: absolute;
      top: 0;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 7px;
      font-weight: 600;
      color: #1a1a1a;
      overflow: hidden;
      white-space: nowrap;
    }
    
    .style-e .shift-bar .vehicle-segment.assigned {
      background: #6ee7b7;
    }
    
    .style-e .shift-bar .vehicle-segment.missing {
      background: #fca5a5;
      color: #7f1d1d;
    }
    
    .style-e .shift-bar .vehicle-segment.none {
      background: transparent;
      color: transparent;
    }

    .style-e .timeline-duty.leave {
      position: absolute;
      top: 7px;
      height: 22px;
      border-radius: 11px;
      background: linear-gradient(180deg, #f87171 0%, #dc2626 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 9px;
      font-weight: 500;
    }

    /* Unassigned job block - same across all styles */
    .time-block.unassigned-job {
      position: absolute;
      top: 6px;
      height: 24px;
      background: repeating-linear-gradient(45deg, var(--accent-red), var(--accent-red) 2px, #dc2626 2px, #dc2626 4px);
      color: white;
      border: 1px solid var(--accent-red);
      border-radius: 4px;
      display: flex;
      align-items: center;
      padding: 0 8px;
      font-size: 10px;
      font-weight: 500;
    }

    /* Detail Panel - keeping existing styles */
    .detail-panel {
      width: 680px;
      min-width: 580px;
      max-width: 1000px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .detail-panel.resizing {
      transition: none;
    }

    /* Horizontal resize handle for detail panel */
    .panel-resize-handle {
      width: 6px;
      background: var(--border);
      cursor: ew-resize;
      position: relative;
      flex-shrink: 0;
      transition: background 0.2s;
    }
    
    .panel-resize-handle:hover,
    .panel-resize-handle.active {
      background: var(--accent-blue);
    }
    
    .panel-resize-handle::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 3px;
      height: 40px;
      background: var(--text-muted);
      border-radius: 2px;
      opacity: 0;
      transition: opacity 0.2s;
    }
    
    .panel-resize-handle:hover::after,
    .panel-resize-handle.active::after {
      opacity: 1;
      background: white;
    }

    .panel-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    .panel-header-info { flex: 1; }
    .panel-title { font-weight: 600; font-size: 14px; margin-bottom: 4px; }
    .panel-subtitle { font-size: 12px; color: var(--text-secondary); }
    .panel-actions { display: flex; gap: 6px; }

    .panel-action-btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      width: 32px;
      height: 32px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .panel-action-btn:hover { background: var(--bg-hover); color: var(--text-primary); }

    .panel-content { flex: 1; overflow-y: auto; padding: 16px; }
    .panel-section { margin-bottom: 20px; }

    .panel-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .panel-section-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
    }

    .panel-section-action {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      padding: 4px 10px;
      font-size: 11px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .panel-section-action:hover { border-color: var(--accent-blue); color: var(--accent-blue); }

    .duty-list { display: flex; flex-direction: column; gap: 1px; }
    
    /* Duty list header row */
    .duty-list-header {
      display: flex;
      align-items: center;
      padding: 4px 6px 4px 28px;
      gap: 4px;
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 2px;
    }
    
    .duty-header-time { width: 42px; text-align: center; flex-shrink: 0; }
    .duty-header-sep { width: 6px; flex-shrink: 0; }
    .duty-header-type { width: 50px; flex-shrink: 0; }
    .duty-header-desc { flex: 1; min-width: 30px; }
    .duty-header-location { width: 70px; flex-shrink: 0; }
    .duty-header-vehicle { width: 58px; flex-shrink: 0; }
    .duty-header-pay { width: 48px; flex-shrink: 0; }
    .duty-header-hours { width: 36px; text-align: right; flex-shrink: 0; }
    .duty-header-actions { width: 24px; flex-shrink: 0; }

    .duty-item {
      display: flex;
      align-items: stretch;
      background: var(--bg-tertiary);
      border-radius: 4px;
      overflow: hidden;
      min-height: 36px;
      position: relative;
    }

    .duty-item:hover { background: var(--bg-hover); }
    .duty-item:hover .duty-insert-arrows { opacity: 1; }

    /* Insert arrows for adding duties above/below */
    .duty-insert-arrows {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 2px 0;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      gap: 2px;
      width: 20px;
    }
    
    .duty-insert-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-muted);
      padding: 2px 4px;
      cursor: pointer;
      font-size: 9px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      white-space: nowrap;
    }
    
    .duty-insert-btn:hover {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
    }

    .duty-type-bar { width: 3px; flex-shrink: 0; align-self: stretch; }
    .duty-type-bar.driving { background: var(--duty-driving); }
    .duty-type-bar.oov { background: var(--duty-oov); }
    .duty-type-bar.break { background: var(--duty-break); }
    .duty-type-bar.waiting { background: var(--duty-waiting); }
    .duty-type-bar.charter { background: var(--duty-charter); }
    .duty-type-bar.dead { background: var(--duty-dead); }

    /* Inline editing duty item - single row responsive */
    .duty-item-inline {
      display: flex;
      align-items: center;
      background: var(--bg-tertiary);
      border-radius: 4px;
      overflow: visible;
      min-height: 32px;
      position: relative;
      z-index: 1;
    }
    
    .duty-item-inline:focus-within {
      z-index: 100;
    }
    
    .duty-item-inline:hover { background: var(--bg-hover); }
    .duty-item-inline:hover .duty-insert-arrows { opacity: 1; }
    .duty-item-inline:hover .duty-delete-btn { opacity: 1; }
    
    .duty-inline-content {
      flex: 1;
      display: flex;
      align-items: center;
      padding: 4px 6px;
      gap: 4px;
      min-width: 0;
    }
    
    .duty-inline-time {
      width: 42px;
      padding: 2px 2px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      background: var(--bg-secondary);
      border: 1px solid transparent;
      border-radius: 3px;
      color: var(--text-primary);
      text-align: center;
      flex-shrink: 0;
    }
    
    .duty-inline-time:focus {
      outline: none;
      border-color: var(--accent-blue);
      background: var(--bg-primary);
    }
    
    .duty-time-sep {
      color: var(--text-muted);
      font-size: 10px;
      flex-shrink: 0;
      width: 6px;
      text-align: center;
    }
    
    .duty-inline-desc {
      flex: 1 1 50px;
      min-width: 30px;
      padding: 2px 4px;
      font-size: 11px;
      background: var(--bg-secondary);
      border: 1px solid transparent;
      border-radius: 3px;
      color: var(--text-primary);
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .duty-inline-desc:focus {
      outline: none;
      border-color: var(--accent-blue);
      background: var(--bg-primary);
    }
    
    .duty-inline-location-wrapper {
      position: relative;
      flex: 0 1 70px;
      min-width: 50px;
    }
    
    .duty-inline-location {
      width: 100%;
      padding: 2px 4px;
      font-size: 11px;
      background: var(--bg-secondary);
      border: 1px solid transparent;
      border-radius: 3px;
      color: var(--text-primary);
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .duty-inline-location:focus {
      outline: none;
      border-color: var(--accent-blue);
      background: var(--bg-primary);
    }
    
    .duty-inline-location-wrapper .location-autocomplete {
      position: absolute;
      top: 100%;
      left: 0;
      width: 250px;
      z-index: 9999;
      font-size: 11px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    
    .duty-inline-location-wrapper:focus-within {
      z-index: 100;
    }
    
    .duty-inline-location-wrapper .location-suggestion {
      padding: 6px 8px;
    }
    
    .duty-inline-select {
      padding: 2px 2px;
      font-size: 10px;
      background: var(--bg-secondary);
      border: 1px solid transparent;
      border-radius: 3px;
      color: var(--text-secondary);
      cursor: pointer;
      flex-shrink: 0;
    }
    
    .duty-inline-select:focus {
      outline: none;
      border-color: var(--accent-blue);
    }
    
    .duty-inline-select.type {
      width: 50px;
      color: var(--text-primary);
      font-weight: 500;
    }
    
    .duty-inline-select.vehicle {
      width: 58px;
    }
    
    .duty-inline-select.vehicle.missing {
      border-color: var(--accent-red);
      color: var(--accent-red);
    }
    
    .duty-inline-select.pay {
      width: 48px;
    }
    
    .duty-inline-hours {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      color: var(--text-muted);
      width: 36px;
      text-align: right;
      flex-shrink: 0;
    }
    
    .duty-delete-btn {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 2px 4px;
      font-size: 12px;
      border-radius: 3px;
      opacity: 0.5;
      transition: all 0.15s;
      flex-shrink: 0;
      width: 24px;
      text-align: center;
    }
    
    .duty-item-inline:hover .duty-delete-btn {
      opacity: 1;
    }
    
    .duty-delete-btn:hover {
      background: rgba(239, 68, 68, 0.2);
      color: var(--accent-red);
    }
    
    /* Cancelled duty styling */
    .duty-item-inline.cancelled {
      opacity: 0.5;
      background: repeating-linear-gradient(
        -45deg,
        transparent,
        transparent 4px,
        rgba(239, 68, 68, 0.05) 4px,
        rgba(239, 68, 68, 0.05) 8px
      );
    }
    
    .duty-item-inline.cancelled .duty-inline-content {
      text-decoration: line-through;
      text-decoration-color: var(--accent-red);
    }
    
    .duty-item-inline.cancelled .duty-inline-time,
    .duty-item-inline.cancelled .duty-inline-desc,
    .duty-item-inline.cancelled .duty-inline-select,
    .duty-item-inline.cancelled .duty-inline-location {
      pointer-events: none;
      color: var(--text-muted);
    }
    
    .duty-cancel-btn {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 2px 4px;
      font-size: 12px;
      border-radius: 3px;
      opacity: 0.5;
      transition: all 0.15s;
      flex-shrink: 0;
      width: 24px;
      text-align: center;
    }
    
    .duty-item-inline:hover .duty-cancel-btn {
      opacity: 1;
    }
    
    .duty-cancel-btn:hover {
      background: rgba(245, 158, 11, 0.2);
      color: var(--accent-amber);
    }
    
    .duty-reinstate-btn {
      background: rgba(34, 197, 94, 0.15);
      border: 1px solid rgba(34, 197, 94, 0.3);
      color: var(--accent-green);
      cursor: pointer;
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      transition: all 0.15s;
      flex-shrink: 0;
      font-weight: 500;
    }
    
    .duty-reinstate-btn:hover {
      background: rgba(34, 197, 94, 0.25);
      border-color: var(--accent-green);
    }
    
    .duty-cancelled-badge {
      font-size: 10px;
      padding: 2px 6px;
      background: rgba(239, 68, 68, 0.15);
      color: var(--accent-red);
      border-radius: 3px;
      margin-right: 8px;
    }

    /* Vehicle schedule item (driver-centric mode) */
    .vehicle-schedule-item {
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 10px 12px;
      margin-bottom: 6px;
      border-left: 3px solid var(--accent-blue);
    }
    
    .vehicle-schedule-item.clickable {
      cursor: pointer;
      transition: all 0.15s ease;
    }
    
    .vehicle-schedule-item.clickable:hover {
      background: var(--bg-hover);
      border-left-color: #60a5fa;
      transform: translateX(2px);
    }
    
    .vehicle-schedule-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    
    .vehicle-schedule-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-primary);
    }
    
    .vehicle-schedule-badge {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 500;
      text-transform: uppercase;
      background: rgba(59, 130, 246, 0.15);
      color: var(--accent-blue);
    }
    
    .vehicle-schedule-badge.charter {
      background: rgba(168, 85, 247, 0.15);
      color: var(--accent-purple);
    }
    
    .vehicle-schedule-driver {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    
    .vehicle-schedule-driver .driver-name {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-primary);
      flex: 1;
    }
    
    .vehicle-schedule-driver .nav-arrow {
      font-size: 12px;
      color: var(--accent-blue);
      opacity: 0;
      transition: opacity 0.15s;
    }
    
    .vehicle-schedule-item.clickable:hover .nav-arrow {
      opacity: 1;
    }
    
    .vehicle-schedule-details {
      display: flex;
      gap: 12px;
      font-size: 11px;
      color: var(--text-muted);
    }
    
    .vehicle-schedule-details .detail-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .panel-section-hint {
      font-size: 10px;
      color: var(--text-muted);
      margin-bottom: 8px;
      font-style: italic;
    }

    .duty-content {
      flex: 1;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      padding: 4px 8px;
      gap: 6px;
      min-width: 0;
    }
    
    .duty-row-main {
      display: flex;
      align-items: center;
      gap: 6px;
      width: 100%;
    }
    
    .duty-row-meta {
      display: flex;
      align-items: center;
      gap: 6px;
      width: 100%;
      padding-top: 2px;
    }

    .duty-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      color: var(--text-primary);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .duty-desc {
      flex: 1;
      font-size: 11px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 0;
    }

    .duty-badge {
      font-size: 9px;
      padding: 2px 5px;
      border-radius: 3px;
      font-weight: 600;
      flex-shrink: 0;
    }

    .duty-badge.driving { background: rgba(59, 130, 246, 0.2); color: var(--accent-blue); }
    .duty-badge.oov { background: rgba(245, 158, 11, 0.2); color: var(--accent-amber); }
    .duty-badge.break { background: rgba(34, 197, 94, 0.2); color: var(--accent-green); }
    .duty-badge.waiting { background: rgba(100, 116, 139, 0.2); color: #94a3b8; }
    .duty-badge.charter { background: rgba(168, 85, 247, 0.2); color: var(--accent-purple); }
    .duty-badge.dead { background: rgba(239, 68, 68, 0.2); color: var(--accent-red); }

    .duty-vehicle {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
      flex-shrink: 0;
      font-family: 'JetBrains Mono', monospace;
    }

    .duty-vehicle.assigned { background: var(--accent-green); color: #000; }
    .duty-vehicle.missing { background: var(--accent-red); color: #fff; }
    
    /* Hours display */
    .duty-hours {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      color: var(--text-muted);
      background: var(--bg-secondary);
      padding: 2px 5px;
      border-radius: 3px;
      flex-shrink: 0;
    }
    
    /* Pay type select */
    .duty-pay-select {
      font-size: 9px;
      padding: 2px 4px;
      border-radius: 3px;
      border: 1px solid var(--border);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      cursor: pointer;
      flex-shrink: 0;
    }
    
    .duty-pay-select:hover {
      border-color: var(--accent-blue);
    }
    
    .duty-pay-select:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    .duty-actions {
      display: flex;
      gap: 2px;
      padding-right: 6px;
      flex-shrink: 0;
      align-items: center;
    }

    .duty-action-btn {
      background: transparent;
      border: none;
      color: var(--text-muted);
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .duty-action-btn:hover { background: var(--bg-secondary); color: var(--text-primary); }
    .duty-action-btn.delete:hover { color: var(--accent-red); }
    
    /* Shift totals summary */
    .shift-totals {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      background: var(--bg-secondary);
      border-radius: 4px;
      margin-top: 8px;
      font-size: 11px;
    }
    
    .shift-totals-label {
      color: var(--text-muted);
      font-weight: 500;
    }
    
    .shift-totals-value {
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-primary);
      font-weight: 600;
    }
    
    .shift-totals-breakdown {
      display: flex;
      gap: 12px;
      color: var(--text-secondary);
      font-size: 10px;
    }
    
    .shift-total-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .shift-total-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }
    
    .shift-total-dot.driving { background: var(--duty-driving); }
    .shift-total-dot.oov { background: var(--duty-oov); }
    .shift-total-dot.break { background: var(--duty-break); }
    .shift-total-dot.waiting { background: var(--duty-waiting); }
    .shift-total-dot.charter { background: var(--duty-charter); }
    .shift-total-dot.dead { background: var(--duty-dead); }

    .shift-block {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      margin-bottom: 12px;
      overflow: visible;
    }

    .shift-block-header {
      background: var(--bg-hover);
      padding: 8px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
    }

    .shift-block-title {
      font-weight: 600;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .shift-block-meta {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .shift-block-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      color: var(--text-secondary);
    }

    .shift-vehicle-status {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 3px;
    }

    .shift-vehicle-status.complete { background: rgba(34, 197, 94, 0.15); color: var(--accent-green); }
    .shift-vehicle-status.partial { background: rgba(245, 158, 11, 0.15); color: var(--accent-amber); }
    .shift-vehicle-status.none { background: rgba(239, 68, 68, 0.15); color: var(--accent-red); }

    .shift-block-actions {
      display: flex;
      gap: 8px;
      padding: 6px 8px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-subtle);
    }
    
    .shift-action-btn {
      flex: 1;
      padding: 6px 10px;
      font-size: 11px;
      font-weight: 500;
      border: 1px solid var(--border-subtle);
      border-radius: 4px;
      background: var(--bg-secondary);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s ease;
    }
    
    .shift-action-btn:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }
    
    .shift-action-btn.danger:hover {
      border-color: var(--accent-red);
      color: var(--accent-red);
    }
    
    .shift-action-btn.primary {
      background: #60a5fa;
      border-color: #60a5fa;
      color: #1e3a8a;
      font-weight: 600;
    }
    
    .shift-action-btn.primary:hover {
      background: #3b82f6;
      border-color: #3b82f6;
    }
    
    .bulk-assign-panel {
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid var(--accent-green);
      border-radius: 6px;
      padding: 10px;
      margin: 8px 0;
    }
    
    .bulk-assign-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .bulk-assign-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--accent-green);
    }
    
    .bulk-assign-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 14px;
    }
    
    .bulk-assign-close:hover {
      color: var(--text-primary);
    }
    
    .bulk-assign-info {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .shift-block-content { 
      padding: 6px; 
      overflow-x: auto;
    }
    
    .transfer-list {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 8px;
    }
    
    .transfer-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      margin-bottom: 6px;
    }
    
    .transfer-item:hover {
      background: var(--bg-secondary);
    }
    
    .transfer-item-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .transfer-item-name {
      font-size: 12px;
      font-weight: 500;
      color: var(--text-primary);
    }
    
    .transfer-item-detail {
      font-size: 10px;
      color: var(--text-muted);
    }
    
    .transfer-btn {
      padding: 4px 10px;
      font-size: 11px;
      font-weight: 500;
      background: var(--accent-blue);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .transfer-btn:hover {
      filter: brightness(1.1);
    }
    
    .transfer-cancel-btn {
      width: 100%;
      padding: 8px;
      margin-top: 8px;
      font-size: 11px;
      background: transparent;
      border: 1px solid var(--border-subtle);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
    }
    
    .transfer-cancel-btn:hover {
      background: var(--bg-tertiary);
    }
    
    /* Filter bar styles */
    .filter-bar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-subtle);
    }
    
    .filter-search {
      flex: 1;
      min-width: 120px;
      padding: 5px 8px;
      font-size: 11px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: 4px;
      color: var(--text-primary);
    }
    
    .filter-search::placeholder {
      color: var(--text-muted);
    }
    
    .filter-search:focus {
      outline: none;
      border-color: var(--accent-blue);
    }
    
    .filter-select {
      padding: 5px 8px;
      font-size: 11px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: 4px;
      color: var(--text-primary);
      cursor: pointer;
    }
    
    .filter-select:focus {
      outline: none;
      border-color: var(--accent-blue);
    }
    
    .filter-btn {
      padding: 5px 10px;
      font-size: 10px;
      background: transparent;
      border: 1px solid var(--border-subtle);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
    }
    
    .filter-btn:hover {
      background: var(--bg-secondary);
    }
    
    .filter-btn.active {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
    }
    
    .filter-toggle-btn {
      padding: 5px 10px;
      font-size: 10px;
      background: transparent;
      border: 1px solid var(--border-subtle);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .filter-toggle-btn:hover {
      background: var(--bg-secondary);
      border-color: var(--text-muted);
    }
    
    .filter-toggle-btn.active {
      background: rgba(245, 158, 11, 0.15);
      border-color: var(--accent-amber);
      color: var(--accent-amber);
    }
    
    /* Cancelled duty bar on Gantt - for Style A (absolute positioned) */
    .style-a .timeline-duty.cancelled-ghost {
      position: absolute;
      top: 4px;
      height: 20px;
      opacity: 0.4;
      background: repeating-linear-gradient(
        -45deg,
        var(--bg-tertiary),
        var(--bg-tertiary) 3px,
        rgba(239, 68, 68, 0.4) 3px,
        rgba(239, 68, 68, 0.4) 6px
      ) !important;
      border: 1px dashed rgba(239, 68, 68, 0.6);
      border-radius: 2px;
    }
    
    /* Cancelled duty segment inside shift bar - for Style B/C/D/E */
    .segment.cancelled-ghost {
      opacity: 0.4;
      background: repeating-linear-gradient(
        -45deg,
        var(--bg-tertiary),
        var(--bg-tertiary) 3px,
        rgba(239, 68, 68, 0.4) 3px,
        rgba(239, 68, 68, 0.4) 6px
      ) !important;
      border: 1px dashed rgba(239, 68, 68, 0.5);
      box-sizing: border-box;
    }
    
    /* Assignment list styles */
    .assignment-panel {
      display: flex;
      flex-direction: column;
      max-height: 300px;
    }
    
    .assignment-search {
      padding: 8px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-subtle);
    }
    
    .assignment-search-input {
      width: 100%;
      padding: 8px 10px;
      font-size: 12px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: 6px;
      color: var(--text-primary);
    }
    
    .assignment-search-input::placeholder {
      color: var(--text-muted);
    }
    
    .assignment-search-input:focus {
      outline: none;
      border-color: var(--accent-blue);
    }
    
    .assignment-filters {
      display: flex;
      gap: 6px;
      padding: 6px 8px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-subtle);
    }
    
    .assignment-filter-btn {
      padding: 4px 8px;
      font-size: 10px;
      background: transparent;
      border: 1px solid var(--border-subtle);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
    }
    
    .assignment-filter-btn:hover {
      background: var(--bg-secondary);
    }
    
    .assignment-filter-btn.active {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
    }
    
    .assignment-list {
      flex: 1;
      overflow-y: auto;
      max-height: 220px;
    }
    
    .assignment-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      border-bottom: 1px solid var(--border-subtle);
    }
    
    .assignment-item:hover {
      background: var(--bg-tertiary);
    }
    
    .assignment-item-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
      flex: 1;
      min-width: 0;
    }
    
    .assignment-item-name {
      font-size: 12px;
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .assignment-item-name.clickable {
      cursor: pointer;
      color: var(--accent-blue);
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 2px;
    }
    
    .assignment-item-name.clickable:hover {
      color: #60a5fa;
      text-decoration-style: solid;
    }
    
    .assignment-item-detail {
      font-size: 10px;
      color: var(--text-muted);
    }
    
    .assignment-item-status {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 3px;
      margin-left: 8px;
    }
    
    .assignment-item-status.available {
      background: rgba(34, 197, 94, 0.15);
      color: var(--accent-green);
    }
    
    .assignment-item-status.working,
    .assignment-item-status.inuse {
      background: rgba(59, 130, 246, 0.15);
      color: var(--accent-blue);
    }
    
    .assignment-item-status.unavailable {
      background: rgba(239, 68, 68, 0.15);
      color: var(--accent-red);
    }
    
    .assignment-item.unavailable {
      opacity: 0.6;
    }
    
    .assignment-item.unavailable .assignment-item-name {
      color: var(--text-muted);
    }
    
    .assignment-empty {
      padding: 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
    }
    
    .assignment-count {
      font-size: 10px;
      color: var(--text-muted);
      padding: 4px 8px;
      background: var(--bg-tertiary);
      text-align: center;
    }
    
    /* Smart suggestion panel styles */
    .suggestion-panel {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(59, 130, 246, 0.1));
      border: 1px solid var(--accent-green);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
    }
    
    .suggestion-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }
    
    .suggestion-icon { font-size: 16px; }
    
    .suggestion-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--accent-green);
    }
    
    .suggestion-subtitle {
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 2px;
    }
    
    .suggestion-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .suggestion-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: var(--bg-secondary);
      border-radius: 6px;
      border-left: 3px solid var(--accent-green);
    }
    
    .suggestion-item.not-possible {
      border-left-color: var(--accent-red);
      opacity: 0.6;
    }
    
    .suggestion-rank {
      font-size: 14px;
      font-weight: 700;
      color: var(--accent-green);
      width: 20px;
    }
    
    .suggestion-item.not-possible .suggestion-rank {
      color: var(--accent-red);
    }
    
    .suggestion-details {
      flex: 1;
      min-width: 0;
    }
    
    .suggestion-job-name {
      font-size: 12px;
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .suggestion-location {
      font-size: 10px;
      color: var(--text-secondary);
      margin-top: 2px;
    }
    
    .suggestion-metrics {
      display: flex;
      gap: 8px;
      margin-top: 4px;
    }
    
    .suggestion-metric {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 3px;
      background: var(--bg-tertiary);
    }
    
    .suggestion-metric.distance {
      color: var(--accent-blue);
    }
    
    .suggestion-metric.time {
      color: var(--accent-amber);
    }
    
    .suggestion-metric.wait {
      color: var(--accent-green);
    }
    
    .suggestion-metric.late {
      color: var(--accent-red);
      background: rgba(239, 68, 68, 0.15);
    }
    
    .suggestion-actions {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .suggestion-assign-btn {
      padding: 6px 12px;
      font-size: 10px;
      font-weight: 600;
      background: #6ee7b7;
      color: #065f46;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .suggestion-assign-btn:hover {
      background: #34d399;
    }
    
    .suggestion-item.not-possible .suggestion-assign-btn {
      background: var(--text-muted);
      color: var(--bg-primary);
      cursor: not-allowed;
    }

    .edit-form {
      background: var(--bg-tertiary);
      border: 2px solid var(--accent-blue);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .edit-form-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--accent-blue);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .form-row { display: flex; gap: 12px; margin-bottom: 12px; }
    .form-group { flex: 1; }

    .form-label {
      display: block;
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 6px;
      font-weight: 500;
    }

    .form-label .required { color: var(--accent-red); margin-left: 2px; }

    .form-input, .form-select {
      width: 100%;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 13px;
      font-family: inherit;
    }

    .form-input:focus, .form-select:focus { outline: none; border-color: var(--accent-blue); background: var(--bg-primary); }
    .form-input.error, .form-select.error { border-color: var(--accent-red); background: rgba(239, 68, 68, 0.1); }
    .form-input[maxlength="5"] { font-family: 'JetBrains Mono', monospace; letter-spacing: 1px; text-align: center; }
    .form-error { color: var(--accent-red); font-size: 11px; margin-top: 6px; padding: 6px 10px; background: rgba(239, 68, 68, 0.1); border-radius: 4px; }
    .form-hint { color: var(--text-muted); font-size: 10px; margin-top: 4px; }
    .form-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border); }

    .form-btn {
      padding: 8px 18px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .form-btn.cancel { background: transparent; border: 1px solid var(--border); color: var(--text-secondary); }
    .form-btn.cancel:hover { border-color: var(--text-muted); color: var(--text-primary); background: var(--bg-hover); }
    .form-btn.save { background: var(--accent-blue); border: none; color: white; }
    .form-btn.save:hover { background: #2563eb; }
    .form-btn.save:disabled { background: var(--text-muted); cursor: not-allowed; opacity: 0.6; }

    .available-slots { margin-top: 12px; padding: 10px; background: var(--bg-secondary); border-radius: 6px; border: 1px solid var(--border); }
    .available-slots-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; font-weight: 500; }
    .slot-chips { display: flex; flex-wrap: wrap; gap: 6px; }
    .slot-chip { font-size: 11px; padding: 4px 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; font-family: 'JetBrains Mono', monospace; transition: all 0.15s; }
    .slot-chip:hover { border-color: var(--accent-blue); color: var(--accent-blue); background: rgba(59, 130, 246, 0.1); }

    .compatible-list { display: flex; flex-direction: column; gap: 6px; }
    .compatible-item { background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; padding: 10px 12px; font-size: 13px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; }
    .compatible-item:hover { border-color: var(--accent-blue); background: var(--bg-hover); }
    .compatible-item-info { display: flex; flex-direction: column; gap: 2px; }
    .compatible-item-name { font-weight: 500; }
    .compatible-item-detail { font-size: 11px; color: var(--text-secondary); }
    .assign-btn { background: #6ee7b7; border: none; color: #065f46; padding: 6px 12px; font-size: 11px; font-weight: 600; border-radius: 4px; cursor: pointer; }
    .assign-btn:hover { background: #34d399; }

    .info-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border); font-size: 13px; }
    .info-label { color: var(--text-secondary); }
    .info-value { font-weight: 500; }

    .empty-panel { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-muted); padding: 32px; text-align: center; }
    .empty-text { font-size: 14px; }

    .toast { position: fixed; bottom: 24px; right: 24px; background: var(--bg-tertiary); border: 1px solid var(--accent-green); border-radius: 8px; padding: 12px 20px; display: flex; align-items: center; gap: 10px; font-size: 13px; box-shadow: 0 4px 20px rgba(0,0,0,0.4); transform: translateY(100px); opacity: 0; transition: all 0.3s ease; z-index: 1000; }
    .toast.show { transform: translateY(0); opacity: 1; }
    .toast.error { border-color: var(--accent-red); }

    .heatmap-section.unassigned .heatmap-row { background: rgba(239, 68, 68, 0.05); }
    .heatmap-section.unassigned .heatmap-row:hover { background: rgba(239, 68, 68, 0.1); }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--bg-primary); }
    ::-webkit-scrollbar-thumb { background: var(--border-light); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

    /* Vertical View Styles */
    .vertical-view .heatmap-rows { display: none; }
    .vertical-view .timeline-header { display: none; }
    .vertical-view .vertical-container { display: flex; flex-direction: column; flex: 1; overflow: hidden; }
    
    .vertical-container { display: none; }
    
    .vertical-wrapper {
      display: flex;
      flex-direction: column;
      flex: 1;
      overflow: hidden;
    }
    
    /* Fixed header row */
    .vertical-header-row {
      display: flex;
      background: var(--bg-secondary);
      border-bottom: 2px solid var(--border-light);
      flex-shrink: 0;
      z-index: 20;
    }
    
    .vertical-time-header {
      width: 60px;
      min-width: 60px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-secondary);
      border-right: 1px solid var(--border-light);
      background: var(--bg-tertiary);
      flex-shrink: 0;
    }
    
    .vertical-headers-scroll {
      display: flex;
      overflow-x: hidden;
      flex: 1;
    }
    
    .vertical-column-header {
      min-width: 120px;
      width: 120px;
      height: 50px;
      padding: 6px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-subtle);
      display: flex;
      flex-direction: column;
      justify-content: center;
      cursor: pointer;
      flex-shrink: 0;
    }
    
    .vertical-column-header:hover { background: var(--bg-tertiary); }
    .vertical-column-header.selected { background: rgba(59, 130, 246, 0.2); }
    
    .vertical-column-name {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .vertical-column-subtitle {
      font-size: 9px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* Scrollable body area */
    .vertical-body-row {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    .vertical-time-column {
      width: 60px;
      min-width: 60px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-light);
      overflow-y: hidden;
      flex-shrink: 0;
    }
    
    .vertical-time-body {
      height: calc(30px * 38);
    }
    
    .vertical-time-slot {
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border-subtle);
      font-family: 'JetBrains Mono', monospace;
    }
    
    .vertical-time-slot.hour-mark {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-weight: 500;
    }
    
    .vertical-columns-scroll {
      display: flex;
      flex: 1;
      overflow: auto;
    }
    
    .vertical-column {
      min-width: 120px;
      width: 120px;
      border-right: 1px solid var(--border-subtle);
      position: relative;
      flex-shrink: 0;
    }
    
    .vertical-column:hover { background: var(--bg-hover); }
    .vertical-column.selected { background: rgba(59, 130, 246, 0.15); }
    
    .vertical-column-body {
      position: relative;
      height: calc(30px * 38); /* 30px per slot, slots from 05:00-24:00 = 38 slots (19 hours * 2) */
    }
    
    .vertical-grid-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--border-subtle);
      pointer-events: none;
    }
    
    .vertical-grid-line.hour-mark {
      background: var(--border-light);
    }
    
    .vertical-block {
      position: absolute;
      left: 4px;
      right: 4px;
      background: var(--accent-blue);
      border-radius: 4px;
      padding: 4px 6px;
      overflow: hidden;
      cursor: pointer;
      font-size: 10px;
      color: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      z-index: 5;
    }
    
    .vertical-block:hover {
      filter: brightness(1.1);
      z-index: 6;
    }
    
    .vertical-block.charter { background: var(--accent-purple); }
    .vertical-block.unassigned { background: var(--accent-red); }
    .vertical-block.maintenance { background: var(--accent-amber); }
    .vertical-block.leave { background: var(--accent-red); opacity: 0.7; }
    
    .vertical-block-title {
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .vertical-block-time {
      font-size: 9px;
      opacity: 0.9;
    }
    
    .vertical-block-details {
      font-size: 9px;
      opacity: 0.8;
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* ============================================
       NAV SIDEBAR
       ============================================ */
    .app-container {
      display: flex;
      height: calc(100vh - 56px); /* viewport minus header */
      overflow: hidden;
    }
    
    .nav-sidebar {
      width: 160px;
      min-width: 160px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      transition: width 0.2s ease, min-width 0.2s ease, transform 0.2s ease;
      z-index: 100;
      overflow: hidden;
    }
    
    .nav-sidebar.collapsed {
      width: 0;
      min-width: 0;
      border-right: none;
    }
    
    .nav-sidebar.collapsed .nav-section,
    .nav-sidebar.collapsed .nav-toggle {
      opacity: 0;
      pointer-events: none;
    }
    
    .nav-section {
      padding: 12px 0;
    }
    
    .nav-section:not(:last-child) {
      border-bottom: 1px solid var(--border);
    }
    
    .nav-section-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
      padding: 0 16px 8px;
      white-space: nowrap;
    }
    
    .nav-item {
      display: flex;
      align-items: center;
      padding: 10px 16px;
      cursor: pointer;
      color: var(--text-secondary);
      transition: all 0.15s;
      border-left: 3px solid transparent;
      text-decoration: none;
      white-space: nowrap;
    }
    
    .nav-item:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }
    
    .nav-item.active {
      background: rgba(59, 130, 246, 0.1);
      color: var(--accent-blue);
      border-left-color: var(--accent-blue);
    }
    
    .nav-label {
      font-size: 13px;
      font-weight: 500;
      white-space: nowrap;
    }
    
    .nav-toggle {
      margin-top: auto;
      padding: 12px;
      border-top: 1px solid var(--border);
    }
    
    .nav-toggle-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      padding: 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 12px;
      transition: all 0.15s;
    }
    
    .nav-toggle-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }
    
    .app-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-width: 0;
    }
    
    /* Adjust main-content to work within app-body */
    .app-body .stats-bar {
      flex-shrink: 0;
    }
    
    .app-body .main-content {
      flex: 1;
      overflow: hidden;
    }
    
    /* Screen placeholder */
    .screen {
      display: none;
      flex-direction: column;
      flex: 1;
      overflow: hidden;
    }
    
    .screen#screen-dispatch {
      display: contents;
    }
    
    .screen-placeholder {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      padding: 40px;
      text-align: center;
    }
    
    .screen-placeholder-title {
      font-size: 24px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
    }
    
    .screen-placeholder-desc {
      font-size: 14px;
      max-width: 400px;
    }
    
    /* CRUD Screen Styles */
    .screen-header-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 24px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
    }
    
    .screen-header-bar h2 {
      font-size: 18px;
      font-weight: 600;
    }
    
    .screen-filters {
      display: flex;
      gap: 12px;
      padding: 12px 24px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
    }
    
    .filter-input {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      width: 250px;
    }
    
    .filter-input:focus {
      outline: none;
      border-color: var(--accent-blue);
    }
    
    .filter-select {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      min-width: 140px;
    }
    
    .screen-table-container {
      flex: 1;
      overflow: auto;
      padding: 16px 24px;
    }
    
    .screen-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .screen-table th,
    .screen-table td {
      padding: 12px 16px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    
    .screen-table th {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
      background: var(--bg-secondary);
      position: sticky;
      top: 0;
    }
    
    .screen-table td {
      font-size: 13px;
    }
    
    .screen-table tr:hover {
      background: var(--bg-hover);
    }
    
    .loading-cell {
      text-align: center;
      color: var(--text-muted);
      padding: 40px !important;
    }
    
    /* ============================================
       OPS CALENDAR STYLES
       ============================================ */
    .ops-calendar-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    .ops-calendar-grid {
      flex: 1;
      padding: 16px;
      overflow: auto;
    }
    
    .ops-calendar-sidebar {
      width: 280px;
      min-width: 280px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .ops-sidebar-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }
    
    .ops-sidebar-header h3 {
      font-size: 14px;
      font-weight: 600;
      margin: 0;
    }
    
    .ops-roster-list {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }
    
    .ops-roster-item {
      background: var(--bg-tertiary);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 10px;
      border-left: 4px solid var(--accent-blue);
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .ops-roster-item:hover {
      background: var(--bg-hover);
      transform: translateX(2px);
    }
    
    .ops-roster-item.status-draft { border-left-color: var(--accent-amber); }
    .ops-roster-item.status-published { border-left-color: var(--accent-green); }
    .ops-roster-item.status-archived { border-left-color: var(--text-muted); opacity: 0.7; }
    
    .ops-roster-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
    }
    
    .ops-roster-code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }
    
    .ops-roster-status {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      text-transform: uppercase;
      font-weight: 600;
    }
    
    .ops-roster-status.draft { background: rgba(245, 158, 11, 0.2); color: var(--accent-amber); }
    .ops-roster-status.published { background: rgba(34, 197, 94, 0.2); color: var(--accent-green); }
    .ops-roster-status.archived { background: rgba(100, 116, 139, 0.2); color: var(--text-muted); }
    
    .ops-roster-name { font-size: 12px; color: var(--text-secondary); margin-bottom: 6px; }
    .ops-roster-dates { font-size: 11px; color: var(--text-muted); margin-bottom: 8px; }
    .ops-roster-stats { display: flex; gap: 12px; font-size: 11px; color: var(--text-muted); margin-bottom: 10px; }
    
    .ops-roster-actions {
      display: flex;
      gap: 6px;
    }
    
    .ops-roster-actions button {
      flex: 1;
      padding: 6px 8px;
      font-size: 11px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .ops-roster-actions .btn-publish {
      background: rgba(34, 197, 94, 0.15);
      border: 1px solid var(--accent-green);
      color: var(--accent-green);
    }
    .ops-roster-actions .btn-publish:hover { background: rgba(34, 197, 94, 0.3); }
    
    .ops-roster-actions .btn-unpublish {
      background: rgba(245, 158, 11, 0.15);
      border: 1px solid var(--accent-amber);
      color: var(--accent-amber);
    }
    .ops-roster-actions .btn-unpublish:hover { background: rgba(245, 158, 11, 0.3); }
    
    .ops-roster-actions .btn-open {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      color: var(--text-primary);
    }
    .ops-roster-actions .btn-open:hover { background: var(--bg-hover); border-color: var(--accent-blue); }
    
    /* Calendar Grid */
    .calendar-month {
      display: flex;
      flex-direction: column;
      background: var(--bg-secondary);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .calendar-header-row {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
    }
    
    .calendar-header-cell {
      padding: 12px 8px;
      text-align: center;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
    }
    
    .calendar-header-cell.weekend { color: var(--accent-amber); }
    
    .calendar-body {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
    }
    
    .calendar-day {
      min-height: 100px;
      border-right: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      padding: 4px;
      background: var(--bg-primary);
      position: relative;
    }
    
    .calendar-day:nth-child(7n) { border-right: none; }
    .calendar-day.other-month { background: var(--bg-secondary); opacity: 0.5; }
    .calendar-day.weekend { background: rgba(245, 158, 11, 0.03); }
    .calendar-day.today { background: rgba(59, 130, 246, 0.08); }
    .calendar-day.holiday { background: rgba(239, 68, 68, 0.08); }
    
    .calendar-day-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 4px;
      margin-bottom: 4px;
    }
    
    .calendar-day-number {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }
    
    .calendar-day.today .calendar-day-number {
      background: var(--accent-blue);
      color: white;
    }
    
    .calendar-holiday-badge {
      font-size: 9px;
      padding: 2px 5px;
      background: rgba(239, 68, 68, 0.15);
      color: var(--accent-red);
      border-radius: 3px;
      white-space: nowrap;
      max-width: 80px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .calendar-day.school-holiday {
      background: rgba(139, 92, 246, 0.06);
    }
    
    .calendar-school-badge {
      font-size: 8px;
      padding: 1px 4px;
      background: rgba(139, 92, 246, 0.15);
      color: #8b5cf6;
      border-radius: 3px;
      white-space: nowrap;
    }
    
    .calendar-badges {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
    }
    
    .calendar-roster-bars {
      display: flex;
      flex-direction: column;
      gap: 2px;
      padding: 0 2px;
    }
    
    .calendar-roster-bar {
      font-size: 10px;
      padding: 3px 6px;
      border-radius: 3px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .calendar-roster-bar:hover { filter: brightness(1.1); transform: scale(1.02); }
    .calendar-roster-bar.draft { background: rgba(245, 158, 11, 0.2); color: var(--accent-amber); border: 1px solid rgba(245, 158, 11, 0.3); }
    .calendar-roster-bar.published { background: rgba(34, 197, 94, 0.2); color: var(--accent-green); border: 1px solid rgba(34, 197, 94, 0.3); }
    .calendar-roster-bar.archived { background: rgba(100, 116, 139, 0.2); color: var(--text-muted); border: 1px solid rgba(100, 116, 139, 0.3); }
    
    .calendar-no-rosters {
      padding: 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 13px;
    }
    
    .ops-section-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      padding: 8px 4px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 8px;
    }
    
    .ops-roster-item.unscheduled {
      border-left-color: var(--text-muted);
      opacity: 0.8;
    }
    
    .ops-roster-status.unscheduled {
      background: rgba(100, 116, 139, 0.2);
      color: var(--text-muted);
    }
    
    .ops-roster-cal-dates {
      font-size: 11px;
      color: var(--accent-blue);
      margin-bottom: 6px;
    }
    
    .ops-roster-actions .btn-schedule {
      background: rgba(59, 130, 246, 0.15);
      border: 1px solid var(--accent-blue);
      color: var(--accent-blue);
      width: 100%;
    }
    .ops-roster-actions .btn-schedule:hover { background: rgba(59, 130, 246, 0.3); }
    
    .ops-roster-actions .btn-unschedule {
      background: rgba(100, 116, 139, 0.15);
      border: 1px solid var(--text-muted);
      color: var(--text-secondary);
    }
    .ops-roster-actions .btn-unschedule:hover { background: rgba(100, 116, 139, 0.3); }
    
    /* Schedule Modal */
    .schedule-modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    .schedule-modal-overlay.show { display: flex; }
    
    .schedule-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      width: 400px;
      max-width: 90vw;
    }
    
    .schedule-modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .schedule-modal-title { font-weight: 600; font-size: 15px; }
    
    .schedule-modal-close {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
    }
    .schedule-modal-close:hover { color: var(--text-primary); }
    
    .schedule-modal-body { padding: 20px; }
    .schedule-modal-footer {
      padding: 16px 20px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }
    
    .badge {
      display: inline-block;
      padding: 4px 8px;
      font-size: 11px;
      font-weight: 500;
      border-radius: 4px;
      text-transform: uppercase;
    }
    
    .badge-success { background: rgba(34, 197, 94, 0.2); color: var(--accent-green); }
    .badge-warning { background: rgba(245, 158, 11, 0.2); color: var(--accent-amber); }
    .badge-error { background: rgba(239, 68, 68, 0.2); color: var(--accent-red); }
    .badge-info { background: rgba(59, 130, 246, 0.2); color: var(--accent-blue); }
    
    .action-btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      margin-right: 4px;
    }
    
    .action-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }
    
    .action-btn.danger:hover {
      background: rgba(239, 68, 68, 0.2);
      color: var(--accent-red);
      border-color: var(--accent-red);
    }
    
    /* Modal Styles */
    .crud-modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    
    .crud-modal-overlay.show {
      display: flex;
    }
    
    .crud-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      width: 500px;
      max-width: 90vw;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    .crud-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
    }
    
    .crud-modal-title {
      font-size: 16px;
      font-weight: 600;
    }
    
    .crud-modal-close {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
    }
    
    .crud-modal-close:hover {
      color: var(--text-primary);
    }
    
    .crud-modal-body {
      padding: 20px;
      overflow-y: auto;
    }
    
    .crud-modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding: 16px 20px;
      border-top: 1px solid var(--border);
    }
    
    .form-group {
      margin-bottom: 16px;
    }
    
    .form-label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }
    
    .form-input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 10px 12px;
      border-radius: 6px;
      font-size: 14px;
    }
    
    .form-input:focus {
      outline: none;
      border-color: var(--accent-blue);
    }
    
    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    
    /* Location autocomplete styles */
    .location-input-wrapper {
      position: relative;
    }
    
    .location-autocomplete {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 6px 6px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .location-suggestion {
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .location-suggestion:last-child {
      border-bottom: none;
    }
    
    .location-suggestion:hover {
      background: var(--bg-hover);
    }
    
    .location-suggestion-name {
      font-weight: 500;
      color: var(--text-primary);
    }
    
    .location-suggestion-address {
      font-size: 11px;
      color: var(--text-muted);
    }
    
    .location-loading {
      padding: 10px 12px;
      color: var(--text-muted);
      font-size: 12px;
      text-align: center;
    }
    
    .location-coords {
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 2px;
    }
    
    .btn-secondary {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 10px 16px;
      font-size: 13px;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
    }
    
    .btn-secondary:hover {
      background: var(--bg-hover);
    }
    
    /* Roster table styles */
    .roster-cell {
      padding: 8px !important;
      vertical-align: top;
      min-width: 100px;
    }
    
    .roster-cell.filled {
      background: var(--bg-tertiary);
    }
    
    .roster-cell.empty {
      color: var(--text-muted);
      text-align: center;
    }
    
    .roster-cell-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: var(--accent-blue);
      margin-bottom: 4px;
    }
    
    .roster-cell-driver {
      font-size: 12px;
      color: var(--text-primary);
    }
    
    .roster-cell-vehicle {
      font-size: 11px;
      color: var(--text-muted);
    }
    
    /* Roster Gantt styles */
    .roster-gantt {
      min-width: 1200px;
    }
    
    .roster-gantt-header {
      display: flex;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    
    .roster-gantt-driver-col {
      width: 180px;
      min-width: 180px;
      padding: 10px 12px;
      font-weight: 600;
      font-size: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      border-right: 1px solid var(--border);
    }
    
    .roster-gantt-timeline {
      flex: 1;
      display: flex;
      position: relative;
    }
    
    .roster-gantt-hour {
      flex: 1;
      text-align: center;
      padding: 10px 0;
      font-size: 11px;
      color: var(--text-muted);
      border-right: 1px solid var(--border-light);
    }
    
    .roster-gantt-hour:last-child {
      border-right: none;
    }
    
    .roster-gantt-row {
      display: flex;
      border-bottom: 1px solid var(--border);
      min-height: 50px;
    }
    
    .roster-gantt-row:hover {
      background: var(--bg-secondary);
    }
    
    .roster-gantt-row.on-leave {
      background: repeating-linear-gradient(
        45deg,
        transparent,
        transparent 10px,
        rgba(239, 68, 68, 0.05) 10px,
        rgba(239, 68, 68, 0.05) 20px
      );
    }
    
    .roster-gantt-driver {
      width: 180px;
      min-width: 180px;
      padding: 10px 12px;
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    
    .roster-gantt-driver-name {
      font-weight: 500;
      font-size: 13px;
      color: var(--text-primary);
    }
    
    .roster-gantt-driver-id {
      font-size: 11px;
      color: var(--text-muted);
    }
    
    .roster-gantt-driver-leave {
      font-size: 10px;
      color: var(--accent-red);
      margin-top: 2px;
    }
    
    .roster-gantt-blocks {
      flex: 1;
      position: relative;
      min-height: 50px;
    }
    
    .roster-gantt-block {
      position: absolute;
      top: 6px;
      bottom: 6px;
      background: var(--accent-blue);
      border-radius: 4px;
      padding: 4px 8px;
      color: white;
      font-size: 11px;
      cursor: pointer;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      transition: transform 0.1s, box-shadow 0.1s;
      z-index: 1;
    }
    
    .roster-gantt-block:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      z-index: 5;
    }
    
    .roster-gantt-block.dragging {
      opacity: 0.7;
      z-index: 100;
    }
    
    .roster-gantt-block-name {
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .roster-gantt-block-time {
      font-size: 10px;
      opacity: 0.9;
    }
    
    .roster-gantt-block-vehicle {
      font-size: 10px;
      opacity: 0.8;
    }
    
    .quick-assign-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      border: none;
      border-radius: 3px;
      background: rgba(250, 204, 21, 0.9);
      color: #000;
      font-size: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
    }
    
    .roster-gantt-block:hover .quick-assign-btn {
      opacity: 1;
    }
    
    .quick-assign-btn:hover {
      background: rgba(250, 204, 21, 1);
      transform: scale(1.1);
    }
    
    .roster-gantt-row.unassigned-row .roster-gantt-blocks {
      background: rgba(107, 114, 128, 0.05);
    }
    
    /* Dispatch Toggle Header */
    .unassigned-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-light);
      gap: 12px;
    }
    
    .unassigned-header-title {
      font-weight: 600;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .unassigned-header-stats {
      font-size: 12px;
      color: var(--text-muted);
    }
    
    .unassigned-header-stats .included {
      color: var(--accent-green);
    }
    
    .unassigned-header-stats .omitted {
      color: var(--text-muted);
    }
    
    .unassigned-header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .toggle-group {
      display: flex;
      gap: 4px;
      align-items: center;
    }
    
    .toggle-group-label {
      font-size: 11px;
      color: var(--text-muted);
      margin-right: 4px;
    }
    
    .btn-toggle-include, .btn-toggle-omit {
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: 1px solid var(--border-light);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .btn-toggle-include:hover {
      background: rgba(34, 197, 94, 0.1);
      border-color: var(--accent-green);
      color: var(--accent-green);
    }
    
    .btn-toggle-omit:hover {
      background: rgba(107, 114, 128, 0.1);
      border-color: var(--text-muted);
    }
    
    /* Block dispatch indicator */
    .dispatch-toggle-btn {
      position: absolute;
      bottom: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.3);
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.15s;
      z-index: 5;
    }
    
    .dispatch-toggle-btn:hover {
      opacity: 1;
      transform: scale(1.1);
    }
    
    .dispatch-toggle-btn.included {
      background: rgba(34, 197, 94, 0.9);
      color: white;
      opacity: 0.8;
    }
    
    .dispatch-toggle-btn.omitted {
      background: rgba(239, 68, 68, 0.7);
      color: white;
      opacity: 0.8;
    }
    
    .roster-gantt-block:hover .dispatch-toggle-btn {
      opacity: 1;
    }
    
    .roster-gantt-grid-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      background: var(--border-light);
      pointer-events: none;
    }
    
    .roster-gantt-drop-zone {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background: transparent;
      transition: background 0.2s;
    }
    
    .roster-gantt-drop-zone.drag-over {
      background: rgba(59, 130, 246, 0.1);
    }
    
    /* Roster status badges */
    .roster-status {
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
    }
    .roster-status.draft { background: var(--bg-tertiary); color: var(--text-secondary); }
    .roster-status.published { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .roster-status.archived { background: rgba(107, 114, 128, 0.2); color: #6b7280; }
    
    textarea.form-input {
      resize: vertical;
      min-height: 60px;
    }
    
    /* Wide modal for shift editor */
    .crud-modal-wide {
      width: 900px;
      max-width: 95vw;
    }
    
    /* Form section */
    .form-section {
      margin: 20px 0;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .form-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
    }
    
    .form-section-title {
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
    }
    
    .btn-small {
      background: var(--accent-blue);
      border: none;
      color: white;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .btn-small:hover {
      background: #2563eb;
    }
    
    /* Duty editor */
    .duty-blocks-container {
      background: var(--bg-primary);
      max-height: 400px;
      overflow-y: auto;
    }
    
    .duty-editor-empty {
      padding: 24px;
      text-align: center;
      color: var(--text-muted);
      font-size: 13px;
    }
    
    /* Individual duty block */
    .duty-block {
      border-bottom: 2px solid var(--border);
      margin-bottom: 0;
    }
    
    .duty-block:last-child {
      border-bottom: none;
    }
    
    .duty-block-header {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      gap: 12px;
    }
    
    .duty-block-name {
      flex: 1;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 13px;
      font-weight: 500;
    }
    
    .duty-block-name:focus {
      outline: none;
      border-color: var(--accent-blue);
    }
    
    .duty-block-driver {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .duty-block-driver-label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
    }
    
    .duty-block-driver select {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      min-width: 140px;
    }
    
    .duty-block-driver select:focus {
      outline: none;
      border-color: var(--accent-blue);
    }
    
    .duty-block-delete {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 6px 10px;
      font-size: 14px;
      border-radius: 4px;
    }
    
    .duty-block-delete:hover {
      background: rgba(239, 68, 68, 0.2);
      color: var(--accent-red);
    }
    
    .duty-block-lines {
      background: var(--bg-secondary);
    }
    
    .duty-line-header {
      display: flex;
      align-items: center;
      padding: 6px 12px 6px 44px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
    }
    
    .duty-col-arrows { width: 32px; }
    .duty-col-time { width: 70px; }
    .duty-col-type { width: 100px; }
    .duty-col-desc { flex: 1; min-width: 100px; }
    .duty-col-location { width: 150px; position: relative; }
    .duty-col-vehicle { width: 100px; }
    .duty-col-pay { width: 80px; }
    .duty-col-hours { width: 55px; text-align: right; }
    .duty-col-actions { width: 36px; text-align: center; }
    
    .duty-col-location .location-input-wrapper {
      position: relative;
    }
    
    .duty-col-location input[type="text"] {
      width: 100%;
      font-size: 12px;
      padding: 4px 6px;
    }
    
    .duty-col-location .location-autocomplete {
      position: absolute;
      top: 100%;
      left: 0;
      width: 250px;
      z-index: 1001;
    }
    
    .duty-line {
      display: flex;
      align-items: center;
      padding: 6px 12px;
      border-bottom: 1px solid var(--border);
      gap: 6px;
    }
    
    .duty-line:last-child {
      border-bottom: none;
    }
    
    .duty-line:hover {
      background: var(--bg-hover);
    }
    
    .duty-line-arrows {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .duty-line-arrow {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 2px 6px;
      font-size: 10px;
      border-radius: 3px;
      opacity: 0.5;
    }
    
    .duty-line:hover .duty-line-arrow {
      opacity: 1;
    }
    
    .duty-line-arrow:hover {
      background: var(--accent-blue);
      color: white;
    }
    
    .duty-line input,
    .duty-line select {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 5px 7px;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .duty-line input:focus,
    .duty-line select:focus {
      outline: none;
      border-color: var(--accent-blue);
    }
    
    .duty-line .duty-col-time input {
      width: 58px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
    }
    
    .duty-line .duty-col-type select {
      width: 88px;
      font-size: 11px;
    }
    
    .duty-line .duty-col-desc input {
      width: 100%;
      font-size: 11px;
    }
    
    .duty-line .duty-col-vehicle select {
      width: 88px;
      font-size: 11px;
    }
    
    .duty-line .duty-col-pay select {
      width: 68px;
      font-size: 11px;
    }
    
    .duty-line .duty-col-hours {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      color: var(--text-secondary);
    }
    
    .duty-line-delete {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px 6px;
      font-size: 12px;
      border-radius: 4px;
      opacity: 0.5;
    }
    
    .duty-line:hover .duty-line-delete {
      opacity: 1;
    }
    
    .duty-line-delete:hover {
      background: rgba(239, 68, 68, 0.2);
      color: var(--accent-red);
    }
    
    .duty-editor-totals {
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      font-size: 12px;
      display: flex;
      justify-content: flex-end;
      gap: 24px;
    }
    
    .duty-total-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .duty-total-label {
      color: var(--text-muted);
    }
    
    .duty-total-value {
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
      color: var(--text-primary);
    }
  </style>
</head>
<body class="style-b">
  <header class="header">
    <div class="header-left">
      <button class="menu-toggle" id="menuToggle" onclick="toggleNavSidebar()">Menu</button>
      <div class="logo">DESPATCH//</div>
      <div class="date-nav">
        <button onclick="changeDate(-1)"></button>
        <span class="current-date" id="currentDate">Mon 14 Jul 2025</span>
        <button onclick="changeDate(1)"></button>
      </div>
      <div class="style-toggle">
        <span class="style-toggle-label">Data:</span>
        <select class="style-select" id="dataSourceSelect" onchange="changeDataSource()">
          <option value="fake"> Fake Data</option>
          <option value="real"> Real API</option>
        </select>
      </div>
      <div class="style-toggle">
        <span class="style-toggle-label">Style:</span>
        <select class="style-select" id="styleSelect" onchange="changeStyle()">
          <option value="style-a">A: Original (Fragmented)</option>
          <option value="style-b" selected>B: Unified + Segments</option>
          <option value="style-c">C: Gradient/Opacity</option>
          <option value="style-d">D: Outline</option>
          <option value="style-e">E: Modern Pill</option>
        </select>
      </div>
      <div class="style-toggle">
        <span class="style-toggle-label">Primary:</span>
        <select class="style-select" id="allocationMode" onchange="changeAllocationMode()">
          <option value="driver">Driver  Vehicle</option>
          <option value="vehicle">Vehicle  Driver</option>
        </select>
      </div>
      <div class="style-toggle">
        <span class="style-toggle-label">View:</span>
        <select class="style-select" id="viewMode" onchange="changeViewMode()">
          <option value="horizontal">Horizontal</option>
          <option value="vertical">Vertical</option>
        </select>
      </div>
    </div>
    <div class="header-right">
      <button class="btn-ai" onclick="toggleAIAssistant()">
        Batman
      </button>
      <button class="btn-primary" onclick="showToast('Charter creation coming soon')">
        + Charter
      </button>
    </div>
  </header>
  
  <!-- AI Assistant Modal -->
  <div class="ai-modal-overlay" id="aiModalOverlay" onclick="toggleAIAssistant()"></div>
  <div class="ai-assistant" id="aiAssistant">
    <div class="ai-header">
      <div class="ai-title">Batman</div>
      <button class="ai-close" onclick="toggleAIAssistant()"></button>
    </div>
    <div class="ai-messages" id="aiMessages">
      <div class="ai-message assistant">
        <div class="ai-message-content">
          I'm Batman. I watch over this dispatch board. Ask me anything:
          <ul style="margin: 8px 0 0 16px; font-size: 12px;">
            <li>"Who's available between 14:00 and 18:00?"</li>
            <li>"Which vehicles have capacity over 50?"</li>
            <li>"Summarise today's dispatch"</li>
            <li>"Any drivers approaching overtime?"</li>
          </ul>
        </div>
      </div>
    </div>
    <div class="ai-input-area">
      <input type="text" class="ai-input" id="aiInput" 
             placeholder="Signal Batman..." 
             onkeydown="if(event.key==='Enter')sendAIQuery()">
      <button class="ai-send" onclick="sendAIQuery()">Send</button>
    </div>
    <div class="ai-footer">The Dark Knight watches over your fleet</div>
  </div>

  <div class="app-container">
    <!-- Navigation Sidebar -->
    <nav class="nav-sidebar" id="navSidebar">
      <div class="nav-section">
        <div class="nav-section-title">Operations</div>
        <a class="nav-item active" onclick="navigateTo('dispatch')" data-screen="dispatch">
          <span class="nav-label">Dispatch</span>
        </a>
        <a class="nav-item" onclick="navigateTo('calendar')" data-screen="calendar">
          <span class="nav-label">Operations Calendar</span>
        </a>
        <a class="nav-item" onclick="navigateTo('charters')" data-screen="charters">
          <span class="nav-label">Charters</span>
        </a>
        <a class="nav-item" onclick="navigateTo('customers')" data-screen="customers">
          <span class="nav-label">Customers</span>
        </a>
      </div>
      <div class="nav-section">
        <div class="nav-section-title">Resources</div>
        <a class="nav-item" onclick="navigateTo('hrm')" data-screen="hrm">
          <span class="nav-label">HRM</span>
        </a>
        <a class="nav-item" onclick="navigateTo('vehicles')" data-screen="vehicles">
          <span class="nav-label">Vehicles</span>
        </a>
        <a class="nav-item" onclick="navigateTo('shifts')" data-screen="shifts">
          <span class="nav-label">Shift Templates</span>
        </a>
        <a class="nav-item" onclick="navigateTo('roster')" data-screen="roster">
          <span class="nav-label">Roster</span>
        </a>
        <a class="nav-item" onclick="navigateTo('maintenance')" data-screen="maintenance">
          <span class="nav-label">Maintenance</span>
        </a>
      </div>
      <div class="nav-toggle">
        <button class="nav-toggle-btn" onclick="toggleNavSidebar()">
          Hide Menu
        </button>
      </div>
    </nav>
    
    <!-- Main App Body -->
    <div class="app-body">
      <!-- Dispatch Screen -->
      <div class="screen" id="screen-dispatch">
        <div class="stats-bar">
          <div class="stat-item">
            <div class="stat-indicator green"></div>
            <span class="stat-label">Drivers Available</span>
            <span class="stat-value" id="statDriversAvail">28</span>
          </div>
          <div class="stat-item">
            <div class="stat-indicator blue"></div>
            <span class="stat-label">Drivers Working</span>
            <span class="stat-value" id="statDriversWork">64</span>
          </div>
          <div class="stat-item">
            <div class="stat-indicator red"></div>
            <span class="stat-label">On Leave</span>
            <span class="stat-value" id="statDriversLeave">12</span>
          </div>
          <div class="stat-item">
            <div class="stat-indicator green"></div>
            <span class="stat-label">Vehicles Available</span>
            <span class="stat-value" id="statVehiclesAvail">22</span>
          </div>
          <div class="stat-item">
            <div class="stat-indicator amber"></div>
            <span class="stat-label">In Maintenance</span>
            <span class="stat-value" id="statVehiclesMaint">8</span>
          </div>
          <div class="stat-item">
            <div class="stat-indicator purple"></div>
            <span class="stat-label">Unassigned Jobs</span>
            <span class="stat-value" id="statUnassigned">7</span>
          </div>
        </div>

        <div class="main-content">
    <div class="heatmap-view">
      <div class="heatmap-left">
        <div class="heatmap-section" id="driversSection">
          <div class="section-header" onclick="toggleSection('driversSection')">
            <div class="section-header-left">
              <span class="section-toggle"></span>
              <div class="section-title">DRIVERS <span class="section-count" id="driverCount">104</span></div>
            </div>
            <div class="section-controls">
              <div class="section-stats">
                <div class="section-stat"><div class="mini-dot green"></div> <span id="driverAvail">28</span> avail</div>
                <div class="section-stat"><div class="mini-dot red"></div> <span id="driverLeave">12</span> leave</div>
              </div>
              <button class="section-btn" onclick="event.stopPropagation(); expandSection('driversSection')"></button>
              <button class="section-btn" onclick="event.stopPropagation(); popoutSection('drivers')"></button>
            </div>
          </div>
          <div class="filter-bar" id="driverFilterBar">
            <input type="text" class="filter-search" id="driverSearch" placeholder="Search drivers..." 
                   oninput="applyDriverFilters()" onclick="event.stopPropagation()">
            <select class="filter-select" id="driverStatusFilter" onchange="applyDriverFilters()" onclick="event.stopPropagation()">
              <option value="all">All Status</option>
              <option value="active">Active (Hide Leave)</option>
              <option value="available">Available Only</option>
              <option value="working">Working Only</option>
              <option value="leave">On Leave Only</option>
            </select>
            <select class="filter-select" id="driverSort" onchange="applyDriverFilters()" onclick="event.stopPropagation()">
              <option value="status">Sort: Status</option>
              <option value="name">Sort: Name</option>
            </select>
            <button class="filter-toggle-btn" id="showCancelledBtn" onclick="event.stopPropagation(); toggleShowCancelled()" title="Show cancelled duties on Gantt">
              Show Cancelled
            </button>
          </div>
          <div class="timeline-header">
            <div class="timeline-label-col">Name</div>
            <div class="timeline-hours" id="driverTimelineHeader"></div>
          </div>
          <div class="heatmap-rows" id="driverRows"></div>
          <div class="vertical-container" id="driverVertical"></div>
        </div>

        <div class="section-resize-handle" id="resizeDriverVehicle" data-above="driversSection" data-below="vehiclesSection"></div>

        <div class="heatmap-section" id="vehiclesSection">
          <div class="section-header" onclick="toggleSection('vehiclesSection')">
            <div class="section-header-left">
              <span class="section-toggle"></span>
              <div class="section-title">VEHICLES <span class="section-count" id="vehicleCount">80</span></div>
            </div>
            <div class="section-controls">
              <div class="section-stats">
                <div class="section-stat"><div class="mini-dot green"></div> <span id="vehicleAvail">22</span> avail</div>
                <div class="section-stat"><div class="mini-dot amber"></div> <span id="vehicleMaint">8</span> maint</div>
              </div>
              <button class="section-btn" onclick="event.stopPropagation(); expandSection('vehiclesSection')"></button>
              <button class="section-btn" onclick="event.stopPropagation(); popoutSection('vehicles')"></button>
            </div>
          </div>
          <div class="filter-bar" id="vehicleFilterBar">
            <input type="text" class="filter-search" id="vehicleSearch" placeholder="Search vehicles..." 
                   oninput="applyVehicleFilters()" onclick="event.stopPropagation()">
            <select class="filter-select" id="vehicleStatusFilter" onchange="applyVehicleFilters()" onclick="event.stopPropagation()">
              <option value="all">All Status</option>
              <option value="active">Active (Hide Maint)</option>
              <option value="available">Available Only</option>
              <option value="inuse">In Use Only</option>
              <option value="maintenance">Maintenance Only</option>
            </select>
            <select class="filter-select" id="vehicleSort" onchange="applyVehicleFilters()" onclick="event.stopPropagation()">
              <option value="status">Sort: Status</option>
              <option value="id">Sort: ID</option>
            </select>
          </div>
          <div class="timeline-header">
            <div class="timeline-label-col">Vehicle</div>
            <div class="timeline-hours" id="vehicleTimelineHeader"></div>
          </div>
          <div class="heatmap-rows" id="vehicleRows"></div>
          <div class="vertical-container" id="vehicleVertical"></div>
        </div>

        <div class="section-resize-handle" id="resizeVehicleUnassigned" data-above="vehiclesSection" data-below="unassignedSection"></div>

        <div class="heatmap-section unassigned" id="unassignedSection">
          <div class="section-header" onclick="toggleSection('unassignedSection')">
            <div class="section-header-left">
              <span class="section-toggle"></span>
              <div class="section-title">UNASSIGNED <span class="section-count" id="unassignedCount">7</span></div>
            </div>
            <div class="section-controls">
              <button class="section-btn" onclick="event.stopPropagation(); expandSection('unassignedSection')"></button>
              <button class="section-btn" onclick="event.stopPropagation(); popoutSection('unassigned')"></button>
            </div>
          </div>
          <div class="timeline-header">
            <div class="timeline-label-col">Job</div>
            <div class="timeline-hours" id="unassignedTimelineHeader"></div>
          </div>
          <div class="heatmap-rows" id="unassignedRows"></div>
          <div class="vertical-container" id="unassignedVertical"></div>
        </div>
      </div>

      <div class="panel-resize-handle" id="panelResizeHandle"></div>

      <div class="detail-panel" id="detailPanel">
        <div class="empty-panel">
          <div class="empty-text">Select a driver, vehicle, or job</div>
        </div>
      </div>
    </div>
    </div>
      </div><!-- end screen-dispatch -->
      
      <!-- HRM Screen -->
      <div class="screen" id="screen-hrm" style="display: none;">
        <div class="screen-header-bar">
          <h2>Human Resources</h2>
          <button class="btn-primary" onclick="showAddEmployeeModal()">+ Add Employee</button>
        </div>
        <div class="screen-filters">
          <input type="text" class="filter-input" placeholder="Search employees..." oninput="filterEmployees(this.value)">
          <select class="filter-select" onchange="filterEmployeeRole(this.value)">
            <option value="">All Roles</option>
            <option value="driver">Drivers</option>
            <option value="dispatcher">Dispatchers</option>
            <option value="admin">Admins</option>
          </select>
        </div>
        <div class="screen-table-container">
          <table class="screen-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Phone</th>
                <th>Licence</th>
                <th>Role</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="employeesTableBody">
              <tr><td colspan="7" class="loading-cell">Loading employees...</td></tr>
            </tbody>
          </table>
        </div>
      </div>
      
      <!-- Operations Calendar Screen -->
      <div class="screen" id="screen-calendar" style="display: none;">
        <div class="screen-header-bar">
          <h2>Operations Calendar</h2>
          <div style="display: flex; gap: 12px; align-items: center;">
            <button class="btn-secondary" onclick="changeCalendarMonth(-1)"> Prev</button>
            <span id="calendarMonthLabel" style="font-size: 16px; font-weight: 600; min-width: 140px; text-align: center;"></span>
            <button class="btn-secondary" onclick="changeCalendarMonth(1)">Next </button>
            <button class="btn-secondary" onclick="goToCalendarToday()" style="margin-left: 8px;">Today</button>
          </div>
        </div>
        
        <div class="ops-calendar-container">
          <div class="ops-calendar-grid" id="opsCalendarGrid">
            <div style="padding: 40px; text-align: center; color: var(--text-muted);">Loading calendar...</div>
          </div>
          
          <div class="ops-calendar-sidebar">
            <div class="ops-sidebar-header">
              <h3>Rosters This Month</h3>
            </div>
            <div class="ops-roster-list" id="opsRosterList"></div>
          </div>
        </div>
      </div>
      
      <!-- Vehicles Screen -->
      <div class="screen" id="screen-vehicles" style="display: none;">
        <div class="screen-header-bar">
          <h2>Vehicle Fleet</h2>
          <button class="btn-primary" onclick="showAddVehicleModal()">+ Add Vehicle</button>
        </div>
        <div class="screen-filters">
          <input type="text" class="filter-input" placeholder="Search vehicles..." oninput="filterVehicles(this.value)">
          <select class="filter-select" onchange="filterVehicleStatus(this.value)">
            <option value="">All Statuses</option>
            <option value="active">Active</option>
            <option value="inactive">Inactive</option>
            <option value="sold">Sold</option>
          </select>
        </div>
        <div class="screen-table-container">
          <table class="screen-table">
            <thead>
              <tr>
                <th>Fleet #</th>
                <th>Rego</th>
                <th>Capacity</th>
                <th>Make/Model</th>
                <th>Year</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="vehiclesTableBody">
              <tr><td colspan="7" class="loading-cell">Loading vehicles...</td></tr>
            </tbody>
          </table>
        </div>
      </div>
      
      <!-- Shift Templates Screen -->
      <div class="screen" id="screen-shifts" style="display: none;">
        <div class="screen-header-bar">
          <h2>Shift Templates</h2>
          <button class="btn-primary" onclick="showAddShiftModal()">+ Add Template</button>
        </div>
        <div class="screen-filters">
          <input type="text" class="filter-input" placeholder="Search templates..." oninput="filterShifts(this.value)">
          <select class="filter-select" onchange="filterShiftType(this.value)">
            <option value="">All Types</option>
            <option value="regular">Regular</option>
            <option value="charter">Charter</option>
            <option value="school">School</option>
          </select>
        </div>
        <div class="screen-table-container">
          <table class="screen-table">
            <thead>
              <tr>
                <th>Code</th>
                <th>Name</th>
                <th>Type</th>
                <th>Start</th>
                <th>End</th>
                <th>Duration</th>
                <th>Duties</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="shiftsTableBody">
              <tr><td colspan="8" class="loading-cell">Loading shift templates...</td></tr>
            </tbody>
          </table>
        </div>
      </div>
      
      <!-- Roster Screen -->
      <div class="screen" id="screen-roster" style="display: none;">
        <!-- Roster List View -->
        <div id="rosterListView">
          <div class="screen-header-bar">
            <h2>Rosters</h2>
            <div style="display: flex; gap: 8px;">
              <input type="text" id="rosterSearchInput" placeholder="Search rosters..." class="search-input" style="width: 200px;" onkeyup="filterRosters()">
              <button class="btn-primary" onclick="showAddRosterModal()">+ New Roster</button>
            </div>
          </div>
          <div class="screen-table-container">
            <table class="screen-table">
              <thead>
                <tr>
                  <th>Code</th>
                  <th>Name</th>
                  <th>Date Range</th>
                  <th>Status</th>
                  <th>Entries</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="rosterListTableBody">
                <tr><td colspan="6" class="loading-cell">Loading rosters...</td></tr>
              </tbody>
            </table>
          </div>
        </div>
        
        <!-- Roster Detail/Gantt View -->
        <div id="rosterDetailView" style="display: none; flex-direction: column; height: 100%;">
          <div class="screen-header-bar">
            <div style="display: flex; align-items: center; gap: 16px;">
              <button class="btn-secondary" onclick="backToRosterList()"> Back</button>
              <h2 id="rosterDetailTitle">Roster Detail</h2>
              <span id="rosterDetailDates" style="color: var(--text-muted); font-size: 13px;"></span>
            </div>
            <div style="display: flex; gap: 8px; align-items: center;">
              <button class="btn-secondary" onclick="changeRosterDay(-1)"> Prev</button>
              <input type="date" id="rosterDayPicker" onchange="goToRosterDay(this.value)" style="background: var(--bg-secondary); border: 1px solid var(--border); color: var(--text-primary); padding: 6px 10px; border-radius: 4px;">
              <button class="btn-secondary" onclick="changeRosterDay(1)">Next </button>
            </div>
          </div>
          
          <!-- Day Info Bar -->
          <div id="rosterDayInfoBar" style="padding: 12px 20px; background: var(--bg-secondary); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
            <div>
              <span id="rosterDayLabel" style="font-size: 16px; font-weight: 600; color: var(--text-primary);"></span>
              <span id="rosterDayHoliday" style="margin-left: 12px; padding: 2px 8px; border-radius: 4px; font-size: 11px; background: var(--accent-orange); color: white; display: none;"></span>
            </div>
            <div id="rosterDayStats" style="font-size: 12px; color: var(--text-muted);"></div>
          </div>
          
          <!-- Gantt Container -->
          <div id="rosterGanttContainer" style="flex: 1; overflow: auto; padding: 16px;">
            <div id="rosterGantt" class="roster-gantt">
              <!-- Gantt content rendered here -->
            </div>
          </div>
        </div>
      </div>
      
      <!-- Charters Screen -->
      <div class="screen" id="screen-charters" style="display: none;">
        <div class="screen-placeholder">
          <div class="screen-placeholder-title">Charter Management</div>
          <div class="screen-placeholder-desc">Create, manage, and track charter bookings and quotations.</div>
        </div>
      </div>
      
      <!-- Customers Screen -->
      <div class="screen" id="screen-customers" style="display: none;">
        <div class="screen-placeholder">
          <div class="screen-placeholder-title">Customers</div>
          <div class="screen-placeholder-desc">Manage customer accounts, contacts, and booking history.</div>
        </div>
      </div>
      
      <!-- Maintenance Screen -->
      <div class="screen" id="screen-maintenance" style="display: none;">
        <div class="screen-placeholder">
          <div class="screen-placeholder-title">Maintenance</div>
          <div class="screen-placeholder-desc">Schedule and track vehicle maintenance, repairs, and servicing.</div>
        </div>
      </div>
      
    </div><!-- end app-body -->
  </div><!-- end app-container -->

  <div class="toast" id="toast">
    <span class="toast-message" id="toastMessage">Done</span>
  </div>

  <script>
    const DUTY_TYPES = {
      driving: { label: 'D', name: 'Driving' },
      oov: { label: 'OOV', name: 'Out of Vehicle' },
      break: { label: 'BRK', name: 'Meal Break' },
      waiting: { label: 'WAIT', name: 'Waiting' },
      charter: { label: 'CHT', name: 'Charter' },
      dead: { label: 'DEAD', name: 'Dead Running' }
    };

    const VEHICLE_REQUIRED_TYPES = ['driving', 'charter', 'dead'];
    const DRIVER_REQUIRED_TYPES = ['driving', 'charter', 'dead'];

    // Pay types (will be configurable via HRM in future)
    const PAY_TYPES = {
      standard: { label: 'Standard', code: 'STD' },
      overtime: { label: 'Overtime', code: 'OT' },
      doubleTime: { label: 'Double Time', code: 'DT' },
      penalty: { label: 'Penalty Rate', code: 'PEN' },
      allowance: { label: 'Allowance', code: 'ALW' },
      unpaid: { label: 'Unpaid', code: 'UNP' }
    };

    const ROUTES = ['Route 101', 'Route 102', 'Route 203', 'Route 305', 'Express A', 'Metro Loop'];
    
    // Real Adelaide locations with coordinates for distance/time calculations
    const LOCATIONS = [
      { id: 'cbd', name: 'Adelaide CBD', lat: -34.9285, lng: 138.6007, type: 'urban' },
      { id: 'airport', name: 'Adelaide Airport', lat: -34.9449, lng: 138.5311, type: 'transport' },
      { id: 'glenelg', name: 'Glenelg', lat: -34.9824, lng: 138.5156, type: 'beach' },
      { id: 'oval', name: 'Adelaide Oval', lat: -34.9156, lng: 138.5962, type: 'venue' },
      { id: 'convention', name: 'Convention Centre', lat: -34.9220, lng: 138.5970, type: 'venue' },
      { id: 'port', name: 'Port Adelaide', lat: -34.8469, lng: 138.5030, type: 'urban' },
      { id: 'marion', name: 'Westfield Marion', lat: -35.0136, lng: 138.5561, type: 'shopping' },
      { id: 'modbury', name: 'Tea Tree Plaza', lat: -34.8329, lng: 138.6836, type: 'shopping' },
      { id: 'elizabeth', name: 'Elizabeth', lat: -34.7117, lng: 138.6696, type: 'urban' },
      { id: 'noarlunga', name: 'Noarlunga Centre', lat: -35.1381, lng: 138.5176, type: 'urban' },
      { id: 'mtbarker', name: 'Mount Barker', lat: -35.0667, lng: 138.8667, type: 'hills' },
      { id: 'victor', name: 'Victor Harbor', lat: -35.5522, lng: 138.6178, type: 'coastal' },
      { id: 'barossa', name: 'Barossa Valley', lat: -34.5282, lng: 138.9519, type: 'wine' },
      { id: 'mclaren', name: 'McLaren Vale', lat: -35.2167, lng: 138.5500, type: 'wine' },
      { id: 'stirling', name: 'Stirling (Adelaide Hills)', lat: -34.9983, lng: 138.7217, type: 'hills' },
      { id: 'semaphore', name: 'Semaphore', lat: -34.8389, lng: 138.4822, type: 'beach' },
      { id: 'henley', name: 'Henley Beach', lat: -34.9178, lng: 138.4961, type: 'beach' },
      { id: 'norwood', name: 'Norwood', lat: -34.9211, lng: 138.6314, type: 'urban' },
      { id: 'burnside', name: 'Burnside Village', lat: -34.9375, lng: 138.6547, type: 'shopping' },
      { id: 'uni', name: 'Adelaide University', lat: -34.9190, lng: 138.6046, type: 'education' },
      { id: 'flinders', name: 'Flinders University', lat: -35.0244, lng: 138.5672, type: 'education' },
      { id: 'rah', name: 'Royal Adelaide Hospital', lat: -34.9208, lng: 138.5872, type: 'medical' },
      { id: 'fmc', name: 'Flinders Medical Centre', lat: -35.0197, lng: 138.5678, type: 'medical' },
      { id: 'zoo', name: 'Adelaide Zoo', lat: -34.9125, lng: 138.6056, type: 'attraction' },
      { id: 'hahndorf', name: 'Hahndorf', lat: -35.0297, lng: 138.8081, type: 'tourist' }
    ];
    
    // Get location by id or name
    function getLocation(idOrName) {
      return LOCATIONS.find(l => l.id === idOrName || l.name === idOrName) || LOCATIONS[0];
    }
    
    // Route cache in localStorage to avoid repeated API calls
    const ROUTE_CACHE_KEY = 'despatch_route_cache';
    const ROUTE_CACHE_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7 days
    
    function getRouteCache() {
      try {
        const cached = localStorage.getItem(ROUTE_CACHE_KEY);
        if (!cached) return {};
        const data = JSON.parse(cached);
        // Clean expired entries
        const now = Date.now();
        Object.keys(data).forEach(key => {
          if (data[key].timestamp + ROUTE_CACHE_EXPIRY < now) {
            delete data[key];
          }
        });
        return data;
      } catch (e) {
        return {};
      }
    }
    
    function setRouteCache(cache) {
      try {
        localStorage.setItem(ROUTE_CACHE_KEY, JSON.stringify(cache));
      } catch (e) {
        console.warn('Failed to save route cache:', e);
      }
    }
    
    function getRouteCacheKey(loc1, loc2) {
      // Sort by ID to ensure AB and BA use same cache (distance is same both ways usually)
      const ids = [loc1.id, loc2.id].sort();
      return `${ids[0]}_${ids[1]}`;
    }
    
    // Calculate distance using Haversine formula (fallback, returns km)
    function calculateDistanceHaversine(loc1, loc2) {
      const R = 6371; // Earth's radius in km
      const dLat = (loc2.lat - loc1.lat) * Math.PI / 180;
      const dLng = (loc2.lng - loc1.lng) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(loc1.lat * Math.PI / 180) * Math.cos(loc2.lat * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    
    // Estimate travel time using Haversine (fallback)
    function estimateTravelTimeHaversine(loc1, loc2) {
      const distance = calculateDistanceHaversine(loc1, loc2);
      const isUrban = loc1.type === 'urban' || loc2.type === 'urban' || 
                      loc1.type === 'shopping' || loc2.type === 'shopping';
      const avgSpeed = isUrban ? 35 : 55;
      return (distance / avgSpeed) + (10/60); // Add 10 min buffer
    }
    
    // Fetch route from OSRM (free, no API key needed)
    async function fetchOSRMRoute(loc1, loc2) {
      const url = `https://router.project-osrm.org/route/v1/driving/${loc1.lng},${loc1.lat};${loc2.lng},${loc2.lat}?overview=false`;
      
      const response = await fetch(url);
      if (!response.ok) throw new Error('OSRM request failed');
      
      const data = await response.json();
      if (data.code !== 'Ok' || !data.routes || !data.routes[0]) {
        throw new Error('No route found');
      }
      
      const route = data.routes[0];
      return {
        distance: route.distance / 1000, // Convert meters to km
        duration: route.duration / 3600   // Convert seconds to hours
      };
    }
    
    // ============================================
    // NOMINATIM LOCATION AUTOCOMPLETE
    // ============================================
    
    let locationSearchTimeout = null;
    let currentLocationInput = null;
    
    // Search for locations using Nominatim (OpenStreetMap free geocoding)
    async function searchLocations(query, inputId) {
      if (!query || query.length < 3) {
        hideLocationSuggestions(inputId);
        return;
      }
      
      currentLocationInput = inputId;
      showLocationLoading(inputId);
      
      try {
        // Bias search towards Australia
        const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&addressdetails=1&limit=5&countrycodes=au`;
        
        const response = await fetch(url, {
          headers: {
            'User-Agent': 'DispatchApp/1.0'  // Required by Nominatim
          }
        });
        
        if (!response.ok) throw new Error('Nominatim request failed');
        
        const results = await response.json();
        
        if (currentLocationInput === inputId) {
          showLocationSuggestions(inputId, results);
        }
      } catch (error) {
        console.warn('Location search failed:', error);
        hideLocationSuggestions(inputId);
      }
    }
    
    // Debounced location search
    function onLocationInput(inputId) {
      const input = document.getElementById(inputId);
      if (!input) return;
      
      const query = input.value;
      
      // Clear any existing location coords when typing new text
      const latInput = document.getElementById(inputId + 'Lat');
      const lngInput = document.getElementById(inputId + 'Lng');
      if (latInput) latInput.value = '';
      if (lngInput) lngInput.value = '';
      
      // Debounce the search
      if (locationSearchTimeout) {
        clearTimeout(locationSearchTimeout);
      }
      
      locationSearchTimeout = setTimeout(() => {
        searchLocations(query, inputId);
      }, 300);
    }
    
    function showLocationLoading(inputId) {
      const wrapper = document.getElementById(inputId)?.parentElement;
      if (!wrapper) return;
      
      let dropdown = wrapper.querySelector('.location-autocomplete');
      if (!dropdown) {
        dropdown = document.createElement('div');
        dropdown.className = 'location-autocomplete';
        wrapper.appendChild(dropdown);
      }
      
      dropdown.innerHTML = '<div class="location-loading"> Searching...</div>';
      dropdown.style.display = 'block';
    }
    
    function showLocationSuggestions(inputId, results) {
      const wrapper = document.getElementById(inputId)?.parentElement;
      if (!wrapper) return;
      
      let dropdown = wrapper.querySelector('.location-autocomplete');
      if (!dropdown) {
        dropdown = document.createElement('div');
        dropdown.className = 'location-autocomplete';
        wrapper.appendChild(dropdown);
      }
      
      if (results.length === 0) {
        dropdown.innerHTML = '<div class="location-loading">No locations found</div>';
        return;
      }
      
      dropdown.innerHTML = results.map((r, idx) => {
        const name = r.name || r.display_name.split(',')[0];
        const address = r.display_name;
        return `
          <div class="location-suggestion" onclick="selectLocation('${inputId}', ${idx}, '${name.replace(/'/g, "\\'")}', ${r.lat}, ${r.lon})">
            <div class="location-suggestion-name">${name}</div>
            <div class="location-suggestion-address">${address}</div>
          </div>
        `;
      }).join('');
      
      dropdown.style.display = 'block';
    }
    
    function hideLocationSuggestions(inputId) {
      const wrapper = document.getElementById(inputId)?.parentElement;
      if (!wrapper) return;
      
      const dropdown = wrapper.querySelector('.location-autocomplete');
      if (dropdown) {
        dropdown.style.display = 'none';
      }
    }
    
    function selectLocation(inputId, idx, name, lat, lng) {
      const input = document.getElementById(inputId);
      if (input) {
        input.value = name;
      }
      
      // Store lat/lng in hidden fields
      const latInput = document.getElementById(inputId + 'Lat');
      const lngInput = document.getElementById(inputId + 'Lng');
      if (latInput) latInput.value = lat;
      if (lngInput) lngInput.value = lng;
      
      hideLocationSuggestions(inputId);
      
      // Trigger form change if applicable
      if (typeof onFormChange === 'function') {
        onFormChange();
      }
    }
    
    // Close suggestions when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.location-input-wrapper')) {
        document.querySelectorAll('.location-autocomplete').forEach(d => d.style.display = 'none');
      }
    });
    
    // Get route with caching and fallback
    async function getRoute(loc1, loc2) {
      // Same location check
      if (loc1.id === loc2.id) {
        return { distance: 0, duration: 0, source: 'same' };
      }
      
      const cacheKey = getRouteCacheKey(loc1, loc2);
      const cache = getRouteCache();
      
      // Check cache first
      if (cache[cacheKey]) {
        return { ...cache[cacheKey].data, source: 'cache' };
      }
      
      // Try OSRM
      try {
        const result = await fetchOSRMRoute(loc1, loc2);
        // Save to cache
        cache[cacheKey] = { data: result, timestamp: Date.now() };
        setRouteCache(cache);
        return { ...result, source: 'osrm' };
      } catch (error) {
        console.warn('OSRM failed, using Haversine fallback:', error.message);
        // Fallback to Haversine
        return {
          distance: calculateDistanceHaversine(loc1, loc2),
          duration: estimateTravelTimeHaversine(loc1, loc2),
          source: 'haversine'
        };
      }
    }
    
    // Synchronous versions using cache or fallback (for non-async contexts)
    function calculateDistance(loc1, loc2) {
      if (loc1.id === loc2.id) return 0;
      const cacheKey = getRouteCacheKey(loc1, loc2);
      const cache = getRouteCache();
      if (cache[cacheKey]) {
        return cache[cacheKey].data.distance;
      }
      return calculateDistanceHaversine(loc1, loc2);
    }
    
    function estimateTravelTime(loc1, loc2) {
      if (loc1.id === loc2.id) return 0;
      const cacheKey = getRouteCacheKey(loc1, loc2);
      const cache = getRouteCache();
      if (cache[cacheKey]) {
        return cache[cacheKey].data.duration;
      }
      return estimateTravelTimeHaversine(loc1, loc2);
    }
    
    // Pre-fetch common routes to populate cache
    async function prefetchCommonRoutes() {
      const cache = getRouteCache();
      const routesToFetch = [];
      
      // Depot to major locations
      const depotLoc = { id: DEPOT.id, lat: DEPOT.lat, lng: DEPOT.lng, type: 'depot' };
      for (const loc of LOCATIONS.slice(0, 10)) { // Top 10 locations
        const cacheKey = getRouteCacheKey(depotLoc, loc);
        if (!cache[cacheKey]) {
          routesToFetch.push({ from: depotLoc, to: loc, key: cacheKey });
        }
      }
      
      // Fetch in batches to avoid overwhelming OSRM
      console.log(`Prefetching ${routesToFetch.length} routes...`);
      for (let i = 0; i < routesToFetch.length; i++) {
        const route = routesToFetch[i];
        try {
          await getRoute(route.from, route.to);
          // Small delay between requests to be nice to the free API
          if (i < routesToFetch.length - 1) {
            await new Promise(r => setTimeout(r, 100));
          }
        } catch (e) {
          console.warn(`Failed to prefetch route ${route.key}:`, e);
        }
      }
      console.log('Route prefetch complete');
    }
    
    // Format travel time for display
    function formatTravelTime(hours) {
      const mins = Math.round(hours * 60);
      if (mins < 60) return `${mins} min`;
      const h = Math.floor(mins / 60);
      const m = mins % 60;
      return m > 0 ? `${h}h ${m}m` : `${h}h`;
    }
    
    // Format distance for display
    function formatDistance(km) {
      return km < 1 ? `${Math.round(km * 1000)}m` : `${km.toFixed(1)}km`;
    }
    
    // Find best next jobs for a driver/vehicle finishing at a location (async version)
    async function findBestNextJobsAsync(currentLocation, finishTime, availableJobs, limit = 5) {
      const suggestions = [];
      
      for (const job of availableJobs) {
        // Try to get location from:
        // 1. First duty's actual location coords (from API)
        // 2. job.pickupLocation (if set)
        // 3. Parse from description (legacy)
        // 4. Default to first LOCATION
        let pickupLoc = null;
        
        const firstDuty = job.duties?.[0];
        if (firstDuty?.locationLat && firstDuty?.locationLng) {
          // Use real coordinates from duty
          pickupLoc = {
            id: 'duty-loc',
            name: firstDuty.locationName || 'Duty Location',
            lat: firstDuty.locationLat,
            lng: firstDuty.locationLng
          };
        } else if (job.pickupLocation) {
          pickupLoc = job.pickupLocation;
        } else {
          // Try to parse from description (legacy fake data)
          pickupLoc = getLocation(firstDuty?.description?.split('')[0]?.trim()) || LOCATIONS[0];
        }
        
        // Use async route fetching
        const route = await getRoute(currentLocation, pickupLoc);
        const arrivalTime = finishTime + route.duration;
        const jobStartTime = job.start;
        
        const canMakeIt = arrivalTime <= jobStartTime - 0.25;
        const waitTime = Math.max(0, jobStartTime - arrivalTime);
        
        // Jobs without coordinates get a penalty in scoring
        const hasCoords = !!(firstDuty?.locationLat && firstDuty?.locationLng);
        const score = canMakeIt 
          ? (route.distance * 0.5) + (waitTime * 10) + (hasCoords ? 0 : 100)
          : 9999;
        
        suggestions.push({
          job,
          pickupLocation: pickupLoc,
          distance: route.distance,
          travelTime: route.duration,
          arrivalTime,
          waitTime,
          canMakeIt,
          score,
          routeSource: route.source,
          hasRealLocation: hasCoords
        });
      }
      
      return suggestions
        .sort((a, b) => a.score - b.score)
        .slice(0, limit);
    }
    
    // Synchronous version using cached data (for immediate display)
    function findBestNextJobs(currentLocation, finishTime, availableJobs, limit = 5) {
      const suggestions = [];
      
      for (const job of availableJobs) {
        // Try to get location from:
        // 1. First duty's actual location coords (from API)
        // 2. job.pickupLocation (if set)
        // 3. Parse from description (legacy)
        // 4. Default to first LOCATION
        let pickupLoc = null;
        
        const firstDuty = job.duties?.[0];
        if (firstDuty?.locationLat && firstDuty?.locationLng) {
          // Use real coordinates from duty
          pickupLoc = {
            id: 'duty-loc',
            name: firstDuty.locationName || 'Duty Location',
            lat: firstDuty.locationLat,
            lng: firstDuty.locationLng
          };
        } else if (job.pickupLocation) {
          pickupLoc = job.pickupLocation;
        } else {
          // Try to parse from description (legacy fake data)
          pickupLoc = getLocation(firstDuty?.description?.split('')[0]?.trim()) || LOCATIONS[0];
        }
        
        const distance = calculateDistance(currentLocation, pickupLoc);
        const travelTime = estimateTravelTime(currentLocation, pickupLoc);
        const arrivalTime = finishTime + travelTime;
        const jobStartTime = job.start;
        
        const canMakeIt = arrivalTime <= jobStartTime - 0.25;
        const waitTime = Math.max(0, jobStartTime - arrivalTime);
        
        // Jobs without coordinates get a penalty in scoring
        const hasCoords = !!(firstDuty?.locationLat && firstDuty?.locationLng);
        const score = canMakeIt 
          ? (distance * 0.5) + (waitTime * 10) + (hasCoords ? 0 : 100)
          : 9999;
        
        suggestions.push({
          job,
          pickupLocation: pickupLoc,
          distance,
          travelTime,
          arrivalTime,
          waitTime,
          canMakeIt,
          score,
          hasRealLocation: hasCoords
        });
      }
      
      return suggestions
        .sort((a, b) => a.score - b.score)
        .slice(0, limit);
    }

    const FIRST_NAMES = ['James', 'John', 'Michael', 'David', 'Robert', 'William', 'Sarah', 'Emma', 'Lisa', 'Maria'];
    const LAST_NAMES = ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis', 'Wilson'];
    
    // Adelaide-area depots
    // Single depot for now (multi-depot support planned for future)
    const DEPOT = { id: 'mile_end', name: 'Mile End', lat: -34.9219, lng: 138.5697 };

    let drivers = [];
    let vehicles = [];
    let unassignedJobs = [];
    let selectedItem = null;
    let currentDate = new Date();  // Start with today for real data
    let expandedSection = null;
    let editingDuty = null;
    let formErrors = {};
    let currentStyle = 'style-b';
    let allocationMode = 'driver'; // 'driver' or 'vehicle'
    let viewMode = 'horizontal'; // 'horizontal' or 'vertical'
    let dataSource = 'fake'; // 'fake' or 'real'
    let dispatchMeta = null; // Metadata from real API
    let showCancelledDuties = false; // Toggle to show cancelled duties on Gantt
    
    // Filter state
    let driverFilters = { search: '', status: 'all', sort: 'status' };
    let vehicleFilters = { search: '', status: 'all', sort: 'status' };
    let assignmentSearch = '';

    function changeStyle() {
      // Remove old style class
      document.body.classList.remove('style-a', 'style-b', 'style-c', 'style-d', 'style-e');
      currentStyle = document.getElementById('styleSelect').value;
      document.body.classList.add(currentStyle);
      renderAll();
    }

    function changeAllocationMode() {
      allocationMode = document.getElementById('allocationMode').value;
      selectedItem = null;
      editingDuty = null;
      formErrors = {};
      updateSectionOrder();
      renderAll();
    }

    function changeViewMode() {
      viewMode = document.getElementById('viewMode').value;
      
      const sections = ['driversSection', 'vehiclesSection', 'unassignedSection'];
      sections.forEach(id => {
        const section = document.getElementById(id);
        if (viewMode === 'vertical') {
          section.classList.add('vertical-view');
        } else {
          section.classList.remove('vertical-view');
        }
      });
      
      renderAll();
    }

    // ============================================
    // DATA SOURCE MANAGEMENT
    // ============================================
    
    async function changeDataSource() {
      dataSource = document.getElementById('dataSourceSelect').value;
      selectedItem = null;
      editingDuty = null;
      formErrors = {};
      
      if (dataSource === 'real') {
        // Reset to today when switching to real data
        currentDate = new Date();
        await loadDispatchData();
      } else {
        // Generate fake data
        currentDate = new Date(2025, 6, 14); // Reset to fake date
        loadFakeData();
        syncAllVehicleAssignments();
        renderAll();
      }
      
      document.getElementById('currentDate').textContent = formatDate(currentDate);
    }
    
    async function loadDispatchData() {
      if (dataSource === 'fake') {
        loadFakeData();
        syncAllVehicleAssignments();
        renderAll();
        return;
      }
      
      // Show loading state
      const driverRows = document.getElementById('driverRows');
      const vehicleRows = document.getElementById('vehicleRows');
      const unassignedRows = document.getElementById('unassignedRows');
      
      if (driverRows) driverRows.innerHTML = '<div style="padding: 20px; color: var(--text-secondary);">Loading dispatch data...</div>';
      if (vehicleRows) vehicleRows.innerHTML = '<div style="padding: 20px; color: var(--text-secondary);">Loading...</div>';
      if (unassignedRows) unassignedRows.innerHTML = '<div style="padding: 20px; color: var(--text-secondary);">Loading...</div>';
      
      try {
        const dateStr = formatDateISO(currentDate);
        const result = await apiRequest(`/dispatch/${dateStr}`);
        
        if (result.data) {
          const data = result.data;
          
          // Map API response to frontend format
          // Ensure each driver has a shifts array, and each shift has duties
          drivers = (data.drivers || []).map(d => ({
            ...d,
            shifts: (d.shifts || []).map(s => ({
              ...s,
              duties: s.duties || []
            }))
          }));
          
          // Ensure each vehicle has a shifts array, and each shift has duties
          vehicles = (data.vehicles || []).map(v => ({
            ...v,
            shifts: (v.shifts || []).map(s => ({
              ...s,
              duties: s.duties || []
            }))
          }));
          
          // Ensure each unassigned job has a duties array
          unassignedJobs = (data.unassigned || []).map(j => ({
            ...j,
            duties: j.duties || []
          }));
          
          dispatchMeta = data._meta || null;
          
          // Update stats
          if (data.stats) {
            updateDispatchStats(data.stats);
          }
          
          // Show TODOs/warnings if any
          if (dispatchMeta && dispatchMeta.todos && dispatchMeta.todos.length > 0) {
            console.warn('Dispatch TODOs:', dispatchMeta.todos);
          }
          
          // Sync vehicle assignments (with defensive checks already in place)
          syncAllVehicleAssignments();
          
          renderAll();
          
          // Show success toast with source info
          const rosterInfo = dispatchMeta?.publishedRosters?.length 
            ? `from ${dispatchMeta.publishedRosters.length} published roster(s)` 
            : 'no published rosters';
          showToast(`Loaded real data - ${rosterInfo}`, 'success');
        }
      } catch (err) {
        console.error('Failed to load dispatch data:', err);
        showToast(`Failed to load: ${err.message}`, 'error');
        
        // Show error in UI
        if (driverRows) driverRows.innerHTML = `<div style="padding: 20px; color: var(--accent-red);">Error: ${err.message}</div>`;
      }
    }
    
    function updateDispatchStats(stats) {
      const statElements = {
        'statDriversAvail': stats.drivers_available,
        'statDriversWork': stats.drivers_working,
        'statDriversLeave': stats.drivers_leave,
        'statVehiclesAvail': stats.vehicles_available,
        'statVehiclesMaint': stats.vehicles_maintenance,
        'statUnassigned': stats.unassigned_count,
        'driverAvail': stats.drivers_available,
        'driverLeave': stats.drivers_leave,
        'vehicleAvail': stats.vehicles_available,
        'vehicleMaint': stats.vehicles_maintenance,
        'driverCount': stats.drivers_working + stats.drivers_available + stats.drivers_leave,
        'vehicleCount': stats.vehicles_in_use + stats.vehicles_available + stats.vehicles_maintenance,
        'unassignedCount': stats.unassigned_count
      };
      
      for (const [id, value] of Object.entries(statElements)) {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
      }
    }
    
    function loadFakeData() {
      vehicleBookings.clear();
      vehicles = generateVehicles(80);
      drivers = generateDrivers(104);
      unassignedJobs = generateUnassignedJobs(12);
      
      // Add test charters
      const testCharters = [
        { pickup: 'glenelg', dropoff: 'oval', start: 10, customer: 'Beach Wedding' },
        { pickup: 'airport', dropoff: 'convention', start: 11, customer: 'Conference Group' },
        { pickup: 'barossa', dropoff: 'cbd', start: 12, customer: 'Wine Tour' },
        { pickup: 'hahndorf', dropoff: 'marion', start: 13, customer: 'German Club' },
        { pickup: 'victor', dropoff: 'fmc', start: 14, customer: 'Medical Transfer' },
        { pickup: 'zoo', dropoff: 'flinders', start: 15, customer: 'School Excursion' },
        { pickup: 'henley', dropoff: 'modbury', start: 16, customer: 'Sports Team' },
        { pickup: 'norwood', dropoff: 'airport', start: 17, customer: 'Airport Shuttle' },
      ];
      
      testCharters.forEach((tc, i) => {
        const pickupLoc = LOCATIONS.find(l => l.id === tc.pickup);
        const dropoffLoc = LOCATIONS.find(l => l.id === tc.dropoff);
        const duration = 2 + Math.floor(Math.random() * 2);
        const end = tc.start + duration;
        
        unassignedJobs.push({
          id: `CHT-T${String(i + 1).padStart(2, '0')}`,
          name: `Charter #${200 + i}`,
          type: 'charter',
          start: tc.start,
          end: end,
          depot: DEPOT,
          customer: tc.customer,
          pickupLocation: pickupLoc,
          dropoffLocation: dropoffLoc,
          duties: generateJobDuties(tc.start, end, true, pickupLoc, dropoffLoc)
        });
      });
      
      drivers.sort((a, b) => ({ leave: 0, working: 1, available: 2 }[a.status] - { leave: 0, working: 1, available: 2 }[b.status]));
      dispatchMeta = null;
    }
    
    function formatDateISO(date) {
      return date.toISOString().split('T')[0];
    }

    // Vertical view rendering
    const VERTICAL_START_HOUR = 5;  // 05:00
    const VERTICAL_END_HOUR = 24;   // 24:00 (midnight)
    const VERTICAL_SLOT_HEIGHT = 30; // pixels per 30-min slot
    const VERTICAL_SLOTS = (VERTICAL_END_HOUR - VERTICAL_START_HOUR) * 2; // 38 slots
    
    function timeToVerticalPosition(hour) {
      const slotsFromStart = (hour - VERTICAL_START_HOUR) * 2;
      return slotsFromStart * VERTICAL_SLOT_HEIGHT;
    }
    
    function renderVerticalTimeColumn() {
      let html = '';
      for (let h = VERTICAL_START_HOUR; h < VERTICAL_END_HOUR; h++) {
        html += `<div class="vertical-time-slot hour-mark">${String(h).padStart(2, '0')}:00</div>`;
        html += `<div class="vertical-time-slot">${String(h).padStart(2, '0')}:30</div>`;
      }
      return html;
    }
    
    function renderVerticalGridLines() {
      let html = '';
      for (let i = 0; i < VERTICAL_SLOTS; i++) {
        const isHour = i % 2 === 0;
        html += `<div class="vertical-grid-line ${isHour ? 'hour-mark' : ''}" style="top: ${i * VERTICAL_SLOT_HEIGHT}px;"></div>`;
      }
      return html;
    }
    
    function renderDriverVertical() {
      const container = document.getElementById('driverVertical');
      if (!container || viewMode !== 'vertical') return;
      
      const filteredDrivers = getFilteredDrivers();
      
      // Build headers
      let headersHtml = '';
      filteredDrivers.forEach((driver, idx) => {
        const isSelected = selectedItem?.type === 'driver' && selectedItem?.index === drivers.indexOf(driver);
        const globalIdx = drivers.indexOf(driver);
        headersHtml += `
          <div class="vertical-column-header ${isSelected ? 'selected' : ''}" onclick="selectItem('driver', ${globalIdx})">
            <div class="vertical-column-name">${driver.name}</div>
            <div class="vertical-column-subtitle">${driver.id}  ${driver.status}</div>
          </div>
        `;
      });
      
      // Build body columns
      let columnsHtml = '';
      filteredDrivers.forEach((driver, idx) => {
        const isSelected = selectedItem?.type === 'driver' && selectedItem?.index === drivers.indexOf(driver);
        const globalIdx = drivers.indexOf(driver);
        
        let blocksHtml = '';
        if (driver.status === 'leave') {
          blocksHtml = `
            <div class="vertical-block leave" style="top: 0; height: ${VERTICAL_SLOTS * VERTICAL_SLOT_HEIGHT}px;">
              <div class="vertical-block-title">ON LEAVE</div>
            </div>
          `;
        } else {
          (driver.shifts || []).forEach((shift) => {
            const top = timeToVerticalPosition(shift.start);
            const height = (shift.end - shift.start) * 2 * VERTICAL_SLOT_HEIGHT;
            const isCharter = shift.type === 'charter';
            
            let vehicleInfo = '';
            if (shift.duties && shift.duties.length > 0) {
              const vehicleIds = [...new Set(shift.duties.filter(d => d.vehicle).map(d => d.vehicle))];
              vehicleInfo = vehicleIds.join(', ');
            }
            
            blocksHtml += `
              <div class="vertical-block ${isCharter ? 'charter' : ''}" 
                   style="top: ${top}px; height: ${Math.max(height, 30)}px;"
                   onclick="event.stopPropagation(); selectItem('driver', ${globalIdx})"
                   title="${shift.name}: ${formatTime(shift.start)} - ${formatTime(shift.end)}">
                <div class="vertical-block-title">${shift.name}</div>
                <div class="vertical-block-time">${formatTime(shift.start)} - ${formatTime(shift.end)}</div>
                ${vehicleInfo ? `<div class="vertical-block-details">${vehicleInfo}</div>` : ''}
              </div>
            `;
          });
        }
        
        columnsHtml += `
          <div class="vertical-column ${isSelected ? 'selected' : ''}" onclick="selectItem('driver', ${globalIdx})">
            <div class="vertical-column-body">
              ${renderVerticalGridLines()}
              ${blocksHtml}
            </div>
          </div>
        `;
      });
      
      const html = `
        <div class="vertical-wrapper">
          <div class="vertical-header-row">
            <div class="vertical-time-header">Time</div>
            <div class="vertical-headers-scroll" id="driverHeadersScroll">${headersHtml}</div>
          </div>
          <div class="vertical-body-row">
            <div class="vertical-time-column" id="driverTimeColumn">
              <div class="vertical-time-body">${renderVerticalTimeColumn()}</div>
            </div>
            <div class="vertical-columns-scroll" id="driverColumnsScroll">${columnsHtml}</div>
          </div>
        </div>
      `;
      
      container.innerHTML = html;
      
      // Sync scrolling
      const columnsScroll = document.getElementById('driverColumnsScroll');
      const headersScroll = document.getElementById('driverHeadersScroll');
      const timeColumn = document.getElementById('driverTimeColumn');
      
      if (columnsScroll) {
        columnsScroll.addEventListener('scroll', () => {
          if (headersScroll) headersScroll.scrollLeft = columnsScroll.scrollLeft;
          if (timeColumn) timeColumn.scrollTop = columnsScroll.scrollTop;
        });
      }
    }
    
    function renderVehicleVertical() {
      const container = document.getElementById('vehicleVertical');
      if (!container || viewMode !== 'vertical') return;
      
      const filteredVehicles = getFilteredVehicles();
      
      // Build headers
      let headersHtml = '';
      filteredVehicles.forEach((vehicle, idx) => {
        const isSelected = selectedItem?.type === 'vehicle' && selectedItem?.index === vehicles.indexOf(vehicle);
        const globalIdx = vehicles.indexOf(vehicle);
        headersHtml += `
          <div class="vertical-column-header ${isSelected ? 'selected' : ''}" onclick="selectItem('vehicle', ${globalIdx})">
            <div class="vertical-column-name">${vehicle.id}</div>
            <div class="vertical-column-subtitle">${vehicle.capacity} seats  ${vehicle.status}</div>
          </div>
        `;
      });
      
      // Build body columns
      let columnsHtml = '';
      filteredVehicles.forEach((vehicle, idx) => {
        const isSelected = selectedItem?.type === 'vehicle' && selectedItem?.index === vehicles.indexOf(vehicle);
        const globalIdx = vehicles.indexOf(vehicle);
        
        let blocksHtml = '';
        if (vehicle.status === 'maintenance') {
          const maintShift = (vehicle.shifts || []).find(s => s.type === 'maintenance');
          if (maintShift) {
            const top = timeToVerticalPosition(maintShift.start);
            const height = (maintShift.end - maintShift.start) * 2 * VERTICAL_SLOT_HEIGHT;
            blocksHtml = `
              <div class="vertical-block maintenance" style="top: ${top}px; height: ${Math.max(height, 30)}px;">
                <div class="vertical-block-title">MAINTENANCE</div>
                <div class="vertical-block-time">${formatTime(maintShift.start)} - ${formatTime(maintShift.end)}</div>
              </div>
            `;
          }
        } else {
          (vehicle.shifts || []).filter(s => s.type !== 'maintenance').forEach((shift) => {
            const top = timeToVerticalPosition(shift.start);
            const height = (shift.end - shift.start) * 2 * VERTICAL_SLOT_HEIGHT;
            const isCharter = shift.type === 'charter';
            
            let driverInfo = '';
            if (shift.duties && shift.duties.length > 0) {
              const driverNames = [...new Set(shift.duties.filter(d => d.driver).map(d => d.driver))];
              driverInfo = driverNames.join(', ');
            }
            
            blocksHtml += `
              <div class="vertical-block ${isCharter ? 'charter' : ''}" 
                   style="top: ${top}px; height: ${Math.max(height, 30)}px;"
                   onclick="event.stopPropagation(); selectItem('vehicle', ${globalIdx})"
                   title="${shift.name}: ${formatTime(shift.start)} - ${formatTime(shift.end)}">
                <div class="vertical-block-title">${shift.name}</div>
                <div class="vertical-block-time">${formatTime(shift.start)} - ${formatTime(shift.end)}</div>
                ${driverInfo ? `<div class="vertical-block-details">${driverInfo}</div>` : ''}
              </div>
            `;
          });
        }
        
        columnsHtml += `
          <div class="vertical-column ${isSelected ? 'selected' : ''}" onclick="selectItem('vehicle', ${globalIdx})">
            <div class="vertical-column-body">
              ${renderVerticalGridLines()}
              ${blocksHtml}
            </div>
          </div>
        `;
      });
      
      const html = `
        <div class="vertical-wrapper">
          <div class="vertical-header-row">
            <div class="vertical-time-header">Time</div>
            <div class="vertical-headers-scroll" id="vehicleHeadersScroll">${headersHtml}</div>
          </div>
          <div class="vertical-body-row">
            <div class="vertical-time-column" id="vehicleTimeColumn">
              <div class="vertical-time-body">${renderVerticalTimeColumn()}</div>
            </div>
            <div class="vertical-columns-scroll" id="vehicleColumnsScroll">${columnsHtml}</div>
          </div>
        </div>
      `;
      
      container.innerHTML = html;
      
      // Sync scrolling
      const columnsScroll = document.getElementById('vehicleColumnsScroll');
      const headersScroll = document.getElementById('vehicleHeadersScroll');
      const timeColumn = document.getElementById('vehicleTimeColumn');
      
      if (columnsScroll) {
        columnsScroll.addEventListener('scroll', () => {
          if (headersScroll) headersScroll.scrollLeft = columnsScroll.scrollLeft;
          if (timeColumn) timeColumn.scrollTop = columnsScroll.scrollTop;
        });
      }
    }
    
    function renderUnassignedVertical() {
      const container = document.getElementById('unassignedVertical');
      if (!container || viewMode !== 'vertical') return;
      
      const filteredJobs = getFilteredJobs();
      
      // Build headers
      let headersHtml = '';
      filteredJobs.forEach((job, idx) => {
        const isSelected = selectedItem?.type === 'job' && selectedItem?.index === unassignedJobs.indexOf(job);
        const globalIdx = unassignedJobs.indexOf(job);
        headersHtml += `
          <div class="vertical-column-header ${isSelected ? 'selected' : ''}" onclick="selectItem('job', ${globalIdx})">
            <div class="vertical-column-name">${job.name}</div>
            <div class="vertical-column-subtitle">${job.id}</div>
          </div>
        `;
      });
      
      // Build body columns
      let columnsHtml = '';
      filteredJobs.forEach((job, idx) => {
        const isSelected = selectedItem?.type === 'job' && selectedItem?.index === unassignedJobs.indexOf(job);
        const globalIdx = unassignedJobs.indexOf(job);
        
        const top = timeToVerticalPosition(job.start);
        const height = (job.end - job.start) * 2 * VERTICAL_SLOT_HEIGHT;
        const isCharter = job.type === 'charter';
        
        const blockHtml = `
          <div class="vertical-block unassigned ${isCharter ? 'charter' : ''}" 
               style="top: ${top}px; height: ${Math.max(height, 30)}px;"
               onclick="event.stopPropagation(); selectItem('job', ${globalIdx})"
               title="${job.name}: ${formatTime(job.start)} - ${formatTime(job.end)}">
            <div class="vertical-block-title">${job.name}</div>
            <div class="vertical-block-time">${formatTime(job.start)} - ${formatTime(job.end)}</div>
            ${job.customer ? `<div class="vertical-block-details">${job.customer}</div>` : ''}
          </div>
        `;
        
        columnsHtml += `
          <div class="vertical-column ${isSelected ? 'selected' : ''}" onclick="selectItem('job', ${globalIdx})">
            <div class="vertical-column-body">
              ${renderVerticalGridLines()}
              ${blockHtml}
            </div>
          </div>
        `;
      });
      
      const html = `
        <div class="vertical-wrapper">
          <div class="vertical-header-row">
            <div class="vertical-time-header">Time</div>
            <div class="vertical-headers-scroll" id="unassignedHeadersScroll">${headersHtml}</div>
          </div>
          <div class="vertical-body-row">
            <div class="vertical-time-column" id="unassignedTimeColumn">
              <div class="vertical-time-body">${renderVerticalTimeColumn()}</div>
            </div>
            <div class="vertical-columns-scroll" id="unassignedColumnsScroll">${columnsHtml}</div>
          </div>
        </div>
      `;
      
      container.innerHTML = html;
      
      // Sync scrolling
      const columnsScroll = document.getElementById('unassignedColumnsScroll');
      const headersScroll = document.getElementById('unassignedHeadersScroll');
      const timeColumn = document.getElementById('unassignedTimeColumn');
      
      if (columnsScroll) {
        columnsScroll.addEventListener('scroll', () => {
          if (headersScroll) headersScroll.scrollLeft = columnsScroll.scrollLeft;
          if (timeColumn) timeColumn.scrollTop = columnsScroll.scrollTop;
        });
      }
    }

    function updateSectionOrder() {
      const container = document.querySelector('.heatmap-left');
      const driversSection = document.getElementById('driversSection');
      const vehiclesSection = document.getElementById('vehiclesSection');
      const unassignedSection = document.getElementById('unassignedSection');
      const resizeHandle1 = document.getElementById('resizeDriverVehicle');
      const resizeHandle2 = document.getElementById('resizeVehicleUnassigned');
      
      // Reset any collapsed/expanded states
      [driversSection, vehiclesSection, unassignedSection].forEach(s => {
        s.classList.remove('expanded');
        s.style.flex = '';
        s.style.height = '';
      });
      expandedSection = null;
      
      if (allocationMode === 'vehicle') {
        // Vehicle first, then drivers, then unassigned
        // Clear and rebuild
        container.innerHTML = '';
        container.appendChild(vehiclesSection);
        container.appendChild(resizeHandle1);
        container.appendChild(driversSection);
        container.appendChild(resizeHandle2);
        container.appendChild(unassignedSection);
        
        // Update resize handle data attributes
        resizeHandle1.dataset.above = 'vehiclesSection';
        resizeHandle1.dataset.below = 'driversSection';
        resizeHandle2.dataset.above = 'driversSection';
        resizeHandle2.dataset.below = 'unassignedSection';
        
        // Adjust flex values
        vehiclesSection.style.flex = '1.2';
        driversSection.style.flex = '1';
        unassignedSection.style.flex = '0.6';
      } else {
        // Driver first (default)
        container.innerHTML = '';
        container.appendChild(driversSection);
        container.appendChild(resizeHandle1);
        container.appendChild(vehiclesSection);
        container.appendChild(resizeHandle2);
        container.appendChild(unassignedSection);
        
        // Update resize handle data attributes
        resizeHandle1.dataset.above = 'driversSection';
        resizeHandle1.dataset.below = 'vehiclesSection';
        resizeHandle2.dataset.above = 'vehiclesSection';
        resizeHandle2.dataset.below = 'unassignedSection';
        
        // Reset flex values
        driversSection.style.flex = '1.2';
        vehiclesSection.style.flex = '1';
        unassignedSection.style.flex = '0.6';
      }
    }

    // Track vehicle bookings during data generation to prevent conflicts
    const vehicleBookings = new Map(); // vehicleId -> [{start, end}]
    
    function isVehicleAvailable(vehicleId, start, end) {
      if (!vehicleId) return true;
      const bookings = vehicleBookings.get(vehicleId) || [];
      for (const booking of bookings) {
        // Check for overlap
        if (start < booking.end && end > booking.start) {
          return false;
        }
      }
      return true;
    }
    
    function bookVehicle(vehicleId, start, end) {
      if (!vehicleId) return;
      if (!vehicleBookings.has(vehicleId)) {
        vehicleBookings.set(vehicleId, []);
      }
      vehicleBookings.get(vehicleId).push({ start, end });
    }
    
    function findAvailableVehicle(start, end) {
      const availableVehicles = vehicles.filter(v => v.status !== 'maintenance');
      // Shuffle to distribute assignments
      const shuffled = availableVehicles.sort(() => Math.random() - 0.5);
      
      for (const vehicle of shuffled) {
        if (isVehicleAvailable(vehicle.id, start, end)) {
          return vehicle.id;
        }
      }
      return null; // No vehicle available
    }
    
    function generateDuties(shiftStart, shiftEnd, isCharter = false, pickupLoc = null, destLoc = null) {
      const duties = [];
      let currentTime = shiftStart;
      
      // Find a vehicle that's actually available for this entire shift
      const vehicleId = findAvailableVehicle(shiftStart, shiftEnd);
      
      // Book the vehicle for this shift if found
      if (vehicleId) {
        bookVehicle(vehicleId, shiftStart, shiftEnd);
      }
      
      if (isCharter) {
        // Use provided locations or pick random ones
        if (!pickupLoc) pickupLoc = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
        if (!destLoc) {
          do {
            destLoc = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
          } while (destLoc.id === pickupLoc.id && LOCATIONS.length > 1);
        }
        
        const travelTime = estimateTravelTime(pickupLoc, destLoc);
        
        duties.push({ id: `d-${Date.now()}-1`, type: 'dead', start: currentTime, end: currentTime + 0.5, description: `Dead run to ${pickupLoc.name}`, vehicle: vehicleId, locationId: pickupLoc.id });
        currentTime += 0.5;
        duties.push({ id: `d-${Date.now()}-2`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: `Charter pickup at ${pickupLoc.name}`, vehicle: null, locationId: pickupLoc.id });
        currentTime += 0.25;
        duties.push({ id: `d-${Date.now()}-3`, type: 'charter', start: currentTime, end: currentTime + travelTime, description: `${pickupLoc.name}  ${destLoc.name}`, vehicle: vehicleId, fromLocationId: pickupLoc.id, toLocationId: destLoc.id });
        currentTime += travelTime;
        
        const remainingTime = shiftEnd - currentTime - travelTime - 0.5;
        if (remainingTime > 0.5) {
          duties.push({ id: `d-${Date.now()}-4`, type: 'waiting', start: currentTime, end: currentTime + remainingTime, description: `Waiting at ${destLoc.name}`, vehicle: null, locationId: destLoc.id });
          currentTime += remainingTime;
        }
        
        duties.push({ id: `d-${Date.now()}-5`, type: 'charter', start: currentTime, end: currentTime + travelTime, description: `${destLoc.name}  ${pickupLoc.name}`, vehicle: vehicleId, fromLocationId: destLoc.id, toLocationId: pickupLoc.id });
        currentTime += travelTime;
        duties.push({ id: `d-${Date.now()}-6`, type: 'dead', start: currentTime, end: shiftEnd, description: `Dead run to depot`, vehicle: vehicleId, locationId: null });
      } else {
        const route = ROUTES[Math.floor(Math.random() * ROUTES.length)];
        const totalDuration = shiftEnd - shiftStart;
        
        duties.push({ id: `d-${Date.now()}-1`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: 'Sign on, pre-trip', vehicle: null });
        currentTime += 0.25;
        
        const firstDriveEnd = currentTime + Math.min(2 + Math.random(), (shiftEnd - currentTime) / 2);
        duties.push({ id: `d-${Date.now()}-2`, type: 'driving', start: currentTime, end: firstDriveEnd, description: `${route} - Outbound`, vehicle: vehicleId });
        currentTime = firstDriveEnd;
        
        duties.push({ id: `d-${Date.now()}-3`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: 'Turnaround', vehicle: null });
        currentTime += 0.25;
        
        const secondDriveEnd = currentTime + Math.min(2, shiftEnd - currentTime - 1.5);
        if (secondDriveEnd > currentTime + 0.5) {
          duties.push({ id: `d-${Date.now()}-4`, type: 'driving', start: currentTime, end: secondDriveEnd, description: `${route} - Inbound`, vehicle: vehicleId });
          currentTime = secondDriveEnd;
        }
        
        if (totalDuration > 4 && currentTime < shiftEnd - 1.5) {
          duties.push({ id: `d-${Date.now()}-5`, type: 'break', start: currentTime, end: currentTime + 0.5, description: 'Meal break', vehicle: null });
          currentTime += 0.5;
          
          if (currentTime < shiftEnd - 0.5) {
            duties.push({ id: `d-${Date.now()}-6`, type: 'driving', start: currentTime, end: shiftEnd - 0.25, description: `${route} - Final`, vehicle: vehicleId });
            currentTime = shiftEnd - 0.25;
          }
        }
        
        if (currentTime < shiftEnd) {
          duties.push({ id: `d-${Date.now()}-7`, type: 'oov', start: currentTime, end: shiftEnd, description: 'Sign off', vehicle: null });
        }
      }
      
      return { duties, pickupLocation: pickupLoc, dropoffLocation: destLoc };
    }

    function generateDrivers(count) {
      const result = [];
      for (let i = 0; i < count; i++) {
        const firstName = FIRST_NAMES[Math.floor(Math.random() * FIRST_NAMES.length)];
        const lastName = LAST_NAMES[Math.floor(Math.random() * LAST_NAMES.length)];
        
        const rand = Math.random();
        let status, shifts = [];
        
        if (rand < 0.12) {
          status = 'leave';
        } else if (rand < 0.28) {
          status = 'available';
        } else {
          status = 'working';
          const numShifts = Math.random() < 0.85 ? 1 : 2;
          let lastEnd = 5;
          
          for (let s = 0; s < numShifts; s++) {
            const start = lastEnd + Math.floor(Math.random() * 2);
            const duration = 3 + Math.floor(Math.random() * 5);
            const end = Math.min(start + duration, 22);
            
            if (start < 21 && end - start >= 2) {
              const isCharter = Math.random() < 0.2;
              const dutyResult = generateDuties(start, end, isCharter);
              shifts.push({
                id: `shift-${i}-${s}`,
                name: isCharter ? `Charter #${Math.floor(Math.random() * 100)}` : `SHIFT ${Math.floor(Math.random() * 400) + 100}`,
                type: isCharter ? 'charter' : 'shift',
                start, end,
                duties: dutyResult.duties,
                pickupLocation: dutyResult.pickupLocation,
                dropoffLocation: dutyResult.dropoffLocation
              });
            }
            lastEnd = end + 1;
          }
          if (shifts.length === 0) status = 'available';
        }
        
        result.push({
          id: `D${String(i + 1).padStart(3, '0')}`,
          name: `${lastName}, ${firstName.charAt(0)}`,
          fullName: `${firstName} ${lastName}`,
          phone: `04${Math.floor(Math.random() * 90000000 + 10000000)}`,
          licence: `DL${Math.floor(Math.random() * 900000 + 100000)}`,
          depot: DEPOT, status, shifts
        });
      }
      return result;
    }

    function generateVehicles(count) {
      const result = [];
      for (let i = 0; i < count; i++) {
        const prefix = ['BUS', 'MB', 'VH'][Math.floor(Math.random() * 3)];
        const number = String(Math.floor(Math.random() * 900) + 100);
        
        const rand = Math.random();
        let status, shifts = [];
        
        if (rand < 0.12) {
          // Only maintenance vehicles get pre-generated shifts
          status = 'maintenance';
          shifts.push({
            id: `vshift-maint-${i}`,
            name: 'MAINTENANCE',
            type: 'maintenance',
            start: 5,
            end: 23,
            duties: [{
              id: `vd-maint-${i}`,
              type: 'maintenance',
              start: 5,
              end: 23,
              description: 'Scheduled maintenance',
              driver: null
            }]
          });
        } else {
          // All other vehicles start empty - their schedules come from driver duty assignments
          status = 'available';
        }
        
        result.push({
          id: `${prefix}-${number}`,
          rego: `${String.fromCharCode(65 + Math.floor(Math.random() * 26))}${String.fromCharCode(65 + Math.floor(Math.random() * 26))}${String.fromCharCode(65 + Math.floor(Math.random() * 26))}-${Math.floor(Math.random() * 900) + 100}`,
          capacity: [45, 50, 55, 60, 70][Math.floor(Math.random() * 5)],
          depot: DEPOT, status, shifts
        });
      }
      return result;
    }

    // Generate duties for vehicle-centric view (driver assignment instead of vehicle)
    // Same structure as driver duties - sign on, driving, turnaround, break, sign off
    function generateVehicleDuties(shiftStart, shiftEnd, isCharter, assignedDriver, driverId) {
      const duties = [];
      let currentTime = shiftStart;
      
      if (isCharter) {
        const pickupLoc = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
        const destLoc = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
        
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'dead', start: currentTime, end: currentTime + 0.5, description: `Dead run to ${pickupLoc}`, driver: assignedDriver, driverId: driverId });
        currentTime += 0.5;
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: `Charter pickup`, driver: null, driverId: null });
        currentTime += 0.25;
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: currentTime + 1, description: `${pickupLoc}  ${destLoc}`, driver: assignedDriver, driverId: driverId });
        currentTime += 1;
        
        if (shiftEnd - currentTime > 2) {
          duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'waiting', start: currentTime, end: shiftEnd - 1.25, description: `Waiting at ${destLoc}`, driver: null, driverId: null });
          currentTime = shiftEnd - 1.25;
        }
        
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: currentTime + 0.75, description: `Return to ${pickupLoc}`, driver: assignedDriver, driverId: driverId });
        currentTime += 0.75;
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'dead', start: currentTime, end: shiftEnd, description: `Dead run to depot`, driver: assignedDriver, driverId: driverId });
      } else {
        const route = ROUTES[Math.floor(Math.random() * ROUTES.length)];
        const totalDuration = shiftEnd - shiftStart;
        
        // Sign on, pre-trip
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: 'Sign on, pre-trip', driver: null, driverId: null });
        currentTime += 0.25;
        
        // First drive
        const firstDriveEnd = currentTime + Math.min(2 + Math.random(), (shiftEnd - currentTime) / 2);
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: firstDriveEnd, description: `${route} - Outbound`, driver: assignedDriver, driverId: driverId });
        currentTime = firstDriveEnd;
        
        // Turnaround
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: 'Turnaround', driver: null, driverId: null });
        currentTime += 0.25;
        
        // Second drive
        const secondDriveEnd = currentTime + Math.min(2, shiftEnd - currentTime - 1.5);
        if (secondDriveEnd > currentTime + 0.5) {
          // Randomly unassign some drivers for this leg
          const hasDriver = assignedDriver && Math.random() > 0.15;
          duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: secondDriveEnd, description: `${route} - Inbound`, driver: hasDriver ? assignedDriver : null, driverId: hasDriver ? driverId : null });
          currentTime = secondDriveEnd;
        }
        
        // Meal break if shift is long enough
        if (totalDuration > 4 && currentTime < shiftEnd - 1.5) {
          duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'break', start: currentTime, end: currentTime + 0.5, description: 'Meal break', driver: null, driverId: null });
          currentTime += 0.5;
          
          // Final drive after break
          if (currentTime < shiftEnd - 0.5) {
            duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: shiftEnd - 0.25, description: `${route} - Final`, driver: assignedDriver, driverId: driverId });
            currentTime = shiftEnd - 0.25;
          }
        }
        
        // Sign off
        if (currentTime < shiftEnd) {
          duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'oov', start: currentTime, end: shiftEnd, description: 'Sign off', driver: null, driverId: null });
        }
      }
      
      return duties;
    }

    function generateUnassignedJobs(count) {
      const result = [];
      for (let i = 0; i < count; i++) {
        const start = 6 + Math.floor(Math.random() * 12);
        const duration = 2 + Math.floor(Math.random() * 4);
        const end = Math.min(start + duration, 23);
        const isCharter = Math.random() < 0.5;
        
        // For charters, pick random pickup and dropoff locations
        const pickupLocation = isCharter ? LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)] : null;
        let dropoffLocation = null;
        if (isCharter) {
          // Ensure dropoff is different from pickup
          do {
            dropoffLocation = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
          } while (dropoffLocation.id === pickupLocation.id && LOCATIONS.length > 1);
        }
        
        const duties = generateJobDuties(start, end, isCharter, pickupLocation, dropoffLocation);
        
        result.push({
          id: isCharter ? `CHT-${String(i + 1).padStart(3, '0')}` : `JOB-${String(i + 1).padStart(3, '0')}`,
          name: isCharter ? `Charter #${Math.floor(Math.random() * 100) + 1}` : `SHIFT ${Math.floor(Math.random() * 400) + 100}`,
          type: isCharter ? 'charter' : 'shift',
          start, end,
          depot: DEPOT,
          customer: isCharter ? ['ABC Tours', 'School Group', 'Sports Club', 'Corporate', 'Wedding'][Math.floor(Math.random() * 5)] : null,
          pickupLocation,
          dropoffLocation,
          duties
        });
      }
      return result;
    }
    
    // Generate duties for an unassigned job (no driver or vehicle assigned yet)
    function generateJobDuties(shiftStart, shiftEnd, isCharter = false, pickupLoc = null, destLoc = null) {
      const duties = [];
      let currentTime = shiftStart;
      
      if (isCharter) {
        // Use provided locations or pick random ones
        if (!pickupLoc) pickupLoc = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
        if (!destLoc) destLoc = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
        
        // Calculate realistic travel times
        const deadRunTime = 0.5; // Fixed for now, could calculate from depot
        const travelTime = estimateTravelTime(pickupLoc, destLoc);
        const returnTime = travelTime; // Same for return
        
        duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'dead', start: currentTime, end: currentTime + deadRunTime, description: `Dead run to ${pickupLoc.name}`, locationId: pickupLoc.id });
        currentTime += deadRunTime;
        duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: `Charter pickup at ${pickupLoc.name}`, locationId: pickupLoc.id });
        currentTime += 0.25;
        duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'charter', start: currentTime, end: currentTime + travelTime, description: `${pickupLoc.name}  ${destLoc.name}`, fromLocationId: pickupLoc.id, toLocationId: destLoc.id });
        currentTime += travelTime;
        
        // Waiting time at destination if there's time
        const remainingTime = shiftEnd - currentTime - returnTime - 0.5;
        if (remainingTime > 0.5) {
          duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'waiting', start: currentTime, end: currentTime + remainingTime, description: `Waiting at ${destLoc.name}`, locationId: destLoc.id });
          currentTime += remainingTime;
        }
        
        duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'charter', start: currentTime, end: currentTime + returnTime, description: `${destLoc.name}  ${pickupLoc.name}`, fromLocationId: destLoc.id, toLocationId: pickupLoc.id });
        currentTime += returnTime;
        duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'dead', start: currentTime, end: shiftEnd, description: `Dead run to depot`, locationId: null });
      } else {
        const route = ROUTES[Math.floor(Math.random() * ROUTES.length)];
        const totalDuration = shiftEnd - shiftStart;
        
        // Sign on, pre-trip
        duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: 'Sign on, pre-trip' });
        currentTime += 0.25;
        
        // First drive
        const firstDriveEnd = currentTime + Math.min(2 + Math.random(), (shiftEnd - currentTime) / 2);
        duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: firstDriveEnd, description: `${route} - Outbound` });
        currentTime = firstDriveEnd;
        
        // Turnaround
        duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: 'Turnaround' });
        currentTime += 0.25;
        
        // Second drive
        const secondDriveEnd = currentTime + Math.min(2, shiftEnd - currentTime - 1.5);
        if (secondDriveEnd > currentTime + 0.5) {
          duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: secondDriveEnd, description: `${route} - Inbound` });
          currentTime = secondDriveEnd;
        }
        
        // Meal break if shift is long enough
        if (totalDuration > 4 && currentTime < shiftEnd - 1.5) {
          duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'break', start: currentTime, end: currentTime + 0.5, description: 'Meal break' });
          currentTime += 0.5;
          
          // Final drive after break
          if (currentTime < shiftEnd - 0.5) {
            duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: shiftEnd - 0.25, description: `${route} - Final` });
            currentTime = shiftEnd - 0.25;
          }
        }
        
        // Sign off
        if (currentTime < shiftEnd) {
          duties.push({ id: `jd-${Date.now()}-${Math.random()}`, type: 'oov', start: currentTime, end: shiftEnd, description: 'Sign off' });
        }
      }
      
      return duties;
    }
    
    // Sync all existing vehicle assignments from driver duties to vehicle schedules
    function syncAllVehicleAssignments() {
      drivers.forEach(driver => {
        if (!driver.shifts) return;
        driver.shifts.forEach(shift => {
          if (!shift.duties) return;
          shift.duties.forEach(duty => {
            if (duty.vehicle) {
              syncVehicleSchedule(duty.vehicle, duty, driver, shift);
            }
          });
        });
      });
    }
    
    // Check if a vehicle is available for a given time slot (runtime check)
    function isVehicleAvailableForDuty(vehicleId, start, end, excludeDutyId = null) {
      if (!vehicleId) return true;
      
      // Check all driver duties for conflicts
      for (const driver of drivers) {
        for (const shift of driver.shifts) {
          for (const duty of shift.duties) {
            if (excludeDutyId && duty.id === excludeDutyId) continue;
            if (duty.cancelled) continue; // Skip cancelled duties
            if (duty.vehicle === vehicleId) {
              // Check for overlap
              if (start < duty.end && end > duty.start) {
                return false;
              }
            }
          }
        }
      }
      return true;
    }
    
    // Initial data load will happen in init() - calling loadFakeData()

    function formatDate(date) {
      const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      return `${days[date.getDay()]} ${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
    }

    async function changeDate(delta) {
      currentDate.setDate(currentDate.getDate() + delta);
      document.getElementById('currentDate').textContent = formatDate(currentDate);
      selectedItem = null;  // Clear selection when changing date
      
      // Reload data when changing date
      if (dataSource === 'real') {
        await loadDispatchData();
      } else {
        // For fake data, just re-render (data doesn't change by date in fake mode)
        renderAll();
      }
    }
    
    // Generate tooltip HTML for duty blocks
    function renderDutyTooltip(duty, shiftName = '') {
      const dt = DUTY_TYPES[duty.type] || DUTY_TYPES.driving;
      const hours = (duty.end - duty.start).toFixed(2);
      const desc = duty.description || shiftName || dt.label;
      const locationText = duty.locationName || duty.location || '';
      const vehicleText = duty.vehicle || '';
      
      return `
        <div class="timeline-duty-tooltip">
          <div class="tooltip-title">${desc}</div>
          <div class="tooltip-row"><span class="tooltip-label">Time</span><span class="tooltip-value">${formatTime(duty.start)} - ${formatTime(duty.end)}</span></div>
          <div class="tooltip-row"><span class="tooltip-label">Type</span><span class="tooltip-value">${dt.label}</span></div>
          <div class="tooltip-row"><span class="tooltip-label">Hours</span><span class="tooltip-value">${hours}h</span></div>
          ${vehicleText ? `<div class="tooltip-row"><span class="tooltip-label">Vehicle</span><span class="tooltip-value">${vehicleText}</span></div>` : ''}
          ${locationText ? `<div class="tooltip-row"><span class="tooltip-label">Location</span><span class="tooltip-value">${locationText}</span></div>` : ''}
        </div>
      `;
    }
    
    // Get short label for duty block (abbreviated when narrow)
    function getDutyShortLabel(duty, width) {
      const dt = DUTY_TYPES[duty.type] || DUTY_TYPES.driving;
      // If very narrow (< 3%), show nothing or just type code
      if (width < 3) return '';
      // If narrow (< 6%), show just type
      if (width < 6) return dt.code || dt.label.charAt(0);
      // Otherwise show description truncated
      const desc = duty.description || dt.label;
      return desc.length > 12 ? desc.substring(0, 10) + '' : desc;
    }
    
    // Generate tooltip HTML for shift bars (styles B/C/D/E)
    function renderShiftTooltip(shift) {
      const totalHours = (shift.end - shift.start).toFixed(2);
      const duties = shift.duties || [];
      
      let dutiesHTML = '';
      if (duties.length > 0) {
        dutiesHTML = `<div class="tooltip-duties">`;
        duties.slice(0, 5).forEach(duty => {
          const dt = DUTY_TYPES[duty.type] || DUTY_TYPES.driving;
          const desc = duty.description || dt.label;
          dutiesHTML += `
            <div class="tooltip-duty">
              <div class="tooltip-duty-type ${duty.type}"></div>
              <span>${formatTime(duty.start)}-${formatTime(duty.end)}</span>
              <span style="flex:1; overflow:hidden; text-overflow:ellipsis;">${desc}</span>
            </div>
          `;
        });
        if (duties.length > 5) {
          dutiesHTML += `<div style="color: var(--text-muted); font-style: italic;">+${duties.length - 5} more...</div>`;
        }
        dutiesHTML += `</div>`;
      }
      
      return `
        <div class="shift-tooltip">
          <div class="tooltip-title">${shift.name}</div>
          <div class="tooltip-row"><span class="tooltip-label">Time</span><span class="tooltip-value">${formatTime(shift.start)} - ${formatTime(shift.end)}</span></div>
          <div class="tooltip-row"><span class="tooltip-label">Hours</span><span class="tooltip-value">${totalHours}h</span></div>
          <div class="tooltip-row"><span class="tooltip-label">Duties</span><span class="tooltip-value">${duties.length}</span></div>
          ${dutiesHTML}
        </div>
      `;
    }

    function formatTime(hour) {
      const h = Math.floor(hour);
      const m = Math.round((hour - h) * 60);
      return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
    }

    function parseTime(timeStr) {
      if (!timeStr) return 0;
      
      // Remove any spaces and convert to string
      const str = String(timeStr).trim().replace(/\s/g, '');
      
      // If it contains a colon, parse as HH:MM or H:MM
      if (str.includes(':')) {
        const [h, m] = str.split(':').map(Number);
        return h + (m || 0) / 60;
      }
      
      // Handle pure numeric input (e.g., "0730", "730", "1430")
      const num = str.replace(/\D/g, ''); // Remove any non-digits
      
      if (num.length === 0) return 0;
      
      if (num.length <= 2) {
        // Just hours: "7"  7:00, "14"  14:00
        return parseInt(num, 10);
      } else if (num.length === 3) {
        // H:MM format: "730"  7:30
        const h = parseInt(num.charAt(0), 10);
        const m = parseInt(num.slice(1), 10);
        return h + m / 60;
      } else {
        // HHMM format: "0730"  07:30, "1430"  14:30
        const h = parseInt(num.slice(0, 2), 10);
        const m = parseInt(num.slice(2, 4), 10);
        return h + m / 60;
      }
    }
    
    // Format time input as user types (auto-insert colon)
    function formatTimeInput(input) {
      let val = input.value.replace(/[^\d:]/g, ''); // Keep only digits and colon
      
      // If they've typed 3-4 digits without a colon, auto-format
      if (!val.includes(':') && val.length >= 3) {
        if (val.length === 3) {
          val = val.charAt(0) + ':' + val.slice(1);
        } else if (val.length >= 4) {
          val = val.slice(0, 2) + ':' + val.slice(2, 4);
        }
      }
      
      input.value = val;
    }

    function showToast(message, isError = false) {
      const toast = document.getElementById('toast');
      document.getElementById('toastMessage').textContent = message;
      toast.classList.toggle('error', isError);
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 3000);
    }

    function timeToPercent(hour) {
      return ((hour - 5) / 19) * 100;
    }

    function toMinutes(decimalHours) {
      return Math.round(decimalHours * 60);
    }

    function isVehicleAvailableForPeriod(vehicle, start, end) {
      if (vehicle.status === 'maintenance') return false;
      const startMins = toMinutes(start);
      const endMins = toMinutes(end);
      for (const shift of vehicle.shifts || []) {
        if (shift.type === 'maintenance') continue;
        const shiftStartMins = toMinutes(shift.start);
        const shiftEndMins = toMinutes(shift.end);
        if (shiftStartMins < endMins && shiftEndMins > startMins) {
          return false;
        }
      }
      return true;
    }

    function getAvailableVehiclesForPeriod(start, end) {
      return vehicles.filter(v => isVehicleAvailableForPeriod(v, start, end));
    }

    function getShiftVehicleStatus(shift) {
      // Only consider active (non-cancelled) duties
      const activeDuties = shift.duties.filter(d => !d.cancelled);
      const drivingDuties = activeDuties.filter(d => VEHICLE_REQUIRED_TYPES.includes(d.type));
      if (drivingDuties.length === 0) return { status: 'complete', label: 'N/A', assigned: 0, total: 0 };
      
      const withVehicle = drivingDuties.filter(d => d.vehicle);
      if (withVehicle.length === drivingDuties.length) return { status: 'complete', label: 'All assigned', assigned: withVehicle.length, total: drivingDuties.length };
      if (withVehicle.length === 0) return { status: 'none', label: 'No vehicles', assigned: 0, total: drivingDuties.length };
      return { status: 'partial', label: `${withVehicle.length}/${drivingDuties.length} assigned`, assigned: withVehicle.length, total: drivingDuties.length };
    }

    function findOverlappingDuty(duties, start, end, excludeId = null) {
      const startMins = toMinutes(start);
      const endMins = toMinutes(end);
      return duties.find(d => {
        if (d.id === excludeId) return false;
        if (d.cancelled) return false; // Skip cancelled duties
        const dStartMins = toMinutes(d.start);
        const dEndMins = toMinutes(d.end);
        return (startMins < dEndMins && endMins > dStartMins);
      });
    }

    function findAvailableSlots(duties, shiftStart, shiftEnd, minDuration = 0.25) {
      const slots = [];
      // Only consider active (non-cancelled) duties
      const activeDuties = duties.filter(d => !d.cancelled);
      const sortedDuties = [...activeDuties].sort((a, b) => a.start - b.start);
      let currentTime = shiftStart;
      const minDurationMins = toMinutes(minDuration);
      
      for (const duty of sortedDuties) {
        const gapMins = toMinutes(duty.start) - toMinutes(currentTime);
        if (gapMins >= minDurationMins) {
          slots.push({ start: currentTime, end: duty.start });
        }
        currentTime = Math.max(currentTime, duty.end);
      }
      
      const endGapMins = toMinutes(shiftEnd) - toMinutes(currentTime);
      if (endGapMins >= minDurationMins) {
        slots.push({ start: currentTime, end: shiftEnd });
      }
      
      return slots;
    }

    function validateDutyForm(data, duties, shiftStart, shiftEnd, excludeId = null, driver = null, currentShiftId = null) {
      const errors = {};
      
      if (isNaN(data.start) || isNaN(data.end)) {
        errors.time = 'Invalid time format (use HH:MM or HHMM, e.g., 07:30 or 0730)';
        return errors;
      }
      
      if (data.start < 0 || data.start > 24 || data.end < 0 || data.end > 24) {
        errors.time = 'Time must be between 00:00 and 24:00';
        return errors;
      }
      
      const startMins = toMinutes(data.start);
      const endMins = toMinutes(data.end);
      
      if (startMins >= endMins) {
        errors.time = 'End time must be after start time';
        return errors;
      }
      
      // Check for overlaps with other duties in this shift
      const overlap = findOverlappingDuty(duties, data.start, data.end, excludeId);
      if (overlap) {
        errors.overlap = `Overlaps with duty at ${formatTime(overlap.start)}-${formatTime(overlap.end)}`;
        return errors;
      }
      
      // Check for overlaps with OTHER shifts for this driver
      if (driver && currentShiftId) {
        const overlapOtherShift = driver.shifts.find(s => {
          if (s.id === currentShiftId) return false;
          return data.start < s.end && data.end > s.start;
        });
        
        if (overlapOtherShift) {
          errors.overlap = `Overlaps with ${overlapOtherShift.name || 'another shift'} (${formatTime(overlapOtherShift.start)}-${formatTime(overlapOtherShift.end)})`;
          return errors;
        }
      }
      
      // Check vehicle availability (if a vehicle is selected)
      if (data.vehicle && !isVehicleAvailableForDuty(data.vehicle, data.start, data.end, excludeId)) {
        errors.vehicle = `${data.vehicle} is already assigned during this time`;
      }
      
      return errors;
    }

    function getFilteredDrivers() {
      let result = drivers;
      
      // Apply search filter
      if (driverFilters.search) {
        const search = driverFilters.search.toLowerCase();
        result = result.filter(d => 
          d.name.toLowerCase().includes(search) || 
          d.fullName.toLowerCase().includes(search) ||
          d.id.toLowerCase().includes(search)
        );
      }
      
      // Apply status filter
      if (driverFilters.status !== 'all') {
        if (driverFilters.status === 'active') {
          result = result.filter(d => d.status !== 'leave');
        } else {
          result = result.filter(d => d.status === driverFilters.status);
        }
      }
      
      // Apply sort
      result = [...result].sort((a, b) => {
        switch (driverFilters.sort) {
          case 'name':
            return a.name.localeCompare(b.name);
          case 'status':
          default:
            const statusOrder = { leave: 0, working: 1, available: 2 };
            return statusOrder[a.status] - statusOrder[b.status];
        }
      });
      
      return result;
    }

    function getFilteredVehicles() {
      let result = vehicles;
      
      // Apply search filter
      if (vehicleFilters.search) {
        const search = vehicleFilters.search.toLowerCase();
        result = result.filter(v => 
          v.id.toLowerCase().includes(search) || 
          v.rego.toLowerCase().includes(search)
        );
      }
      
      // Apply status filter
      if (vehicleFilters.status !== 'all') {
        if (vehicleFilters.status === 'active') {
          result = result.filter(v => v.status !== 'maintenance');
        } else {
          result = result.filter(v => v.status === vehicleFilters.status);
        }
      }
      
      // Apply sort
      result = [...result].sort((a, b) => {
        switch (vehicleFilters.sort) {
          case 'id':
            return a.id.localeCompare(b.id);
          case 'status':
          default:
            const statusOrder = { maintenance: 0, inuse: 1, available: 2 };
            return statusOrder[a.status] - statusOrder[b.status];
        }
      });
      
      return result;
    }

    function getFilteredJobs() {
      return unassignedJobs;
    }
    
    function applyDriverFilters() {
      driverFilters.search = document.getElementById('driverSearch')?.value || '';
      driverFilters.status = document.getElementById('driverStatusFilter')?.value || 'all';
      driverFilters.sort = document.getElementById('driverSort')?.value || 'status';
      renderDriverRows();
      if (viewMode === 'vertical') {
        renderDriverVertical();
      }
      updateStats();
    }
    
    function applyVehicleFilters() {
      vehicleFilters.search = document.getElementById('vehicleSearch')?.value || '';
      vehicleFilters.status = document.getElementById('vehicleStatusFilter')?.value || 'all';
      vehicleFilters.sort = document.getElementById('vehicleSort')?.value || 'status';
      renderVehicleRows();
      if (viewMode === 'vertical') {
        renderVehicleVertical();
      }
      updateStats();
    }
    
    function toggleShowCancelled() {
      showCancelledDuties = !showCancelledDuties;
      const btn = document.getElementById('showCancelledBtn');
      if (btn) {
        btn.classList.toggle('active', showCancelledDuties);
      }
      renderDriverRows();
      if (viewMode === 'vertical') {
        renderDriverVertical();
      }
    }

    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      const wasCollapsed = section.classList.contains('collapsed');
      
      section.classList.toggle('collapsed');
      
      // Clear custom height when collapsing
      if (!wasCollapsed) {
        section.style.flex = '';
        section.style.height = '';
      } else {
        // When expanding, redistribute space
        redistributeSectionSpace();
      }
    }
    
    function redistributeSectionSpace() {
      const sections = ['driversSection', 'vehiclesSection', 'unassignedSection'];
      const expandedSections = sections.filter(id => {
        const section = document.getElementById(id);
        return !section.classList.contains('collapsed');
      });
      
      // Reset flex for expanded sections
      expandedSections.forEach(id => {
        const section = document.getElementById(id);
        if (id === 'unassignedSection') {
          section.style.flex = '0.6';
        } else if (allocationMode === 'vehicle') {
          section.style.flex = id === 'vehiclesSection' ? '1.2' : '1';
        } else {
          section.style.flex = id === 'driversSection' ? '1.2' : '1';
        }
      });
    }

    function expandSection(sectionId) {
      const sections = document.querySelectorAll('.heatmap-section');
      if (expandedSection === sectionId) {
        document.getElementById(sectionId).classList.remove('expanded');
        expandedSection = null;
        // Restore default flex values
        resetSectionSizes();
      } else {
        sections.forEach(s => {
          s.classList.remove('expanded');
          s.style.flex = '';
          s.style.height = '';
        });
        document.getElementById(sectionId).classList.remove('collapsed');
        document.getElementById(sectionId).classList.add('expanded');
        expandedSection = sectionId;
      }
    }
    
    function resetSectionSizes() {
      const driversSection = document.getElementById('driversSection');
      const vehiclesSection = document.getElementById('vehiclesSection');
      const unassignedSection = document.getElementById('unassignedSection');
      
      driversSection.style.flex = '';
      driversSection.style.height = '';
      vehiclesSection.style.flex = '';
      vehiclesSection.style.height = '';
      unassignedSection.style.flex = '';
      unassignedSection.style.height = '';
    }

    // Section resize functionality
    let resizeState = null;
    
    function initResizeHandles() {
      const handles = document.querySelectorAll('.section-resize-handle');
      
      handles.forEach(handle => {
        handle.addEventListener('mousedown', startResize);
      });
      
      document.addEventListener('mousemove', doResize);
      document.addEventListener('mouseup', stopResize);
    }
    
    function startResize(e) {
      const handle = e.target;
      const aboveId = handle.dataset.above;
      const belowId = handle.dataset.below;
      const aboveSection = document.getElementById(aboveId);
      const belowSection = document.getElementById(belowId);
      
      // If both sections are collapsed, do nothing
      if (aboveSection.classList.contains('collapsed') && belowSection.classList.contains('collapsed')) {
        return;
      }
      
      // If one section is collapsed, expand it first
      if (aboveSection.classList.contains('collapsed')) {
        aboveSection.classList.remove('collapsed');
        aboveSection.style.flex = '0 0 100px';
      }
      if (belowSection.classList.contains('collapsed')) {
        belowSection.classList.remove('collapsed');
        belowSection.style.flex = '0 0 100px';
      }
      
      // Clear expanded state
      if (expandedSection) {
        document.getElementById(expandedSection).classList.remove('expanded');
        expandedSection = null;
      }
      
      const container = document.querySelector('.heatmap-left');
      const containerRect = container.getBoundingClientRect();
      
      resizeState = {
        handle,
        aboveSection,
        belowSection,
        startY: e.clientY,
        aboveStartHeight: aboveSection.getBoundingClientRect().height,
        belowStartHeight: belowSection.getBoundingClientRect().height,
        containerHeight: containerRect.height
      };
      
      handle.classList.add('active');
      aboveSection.classList.add('resizing');
      belowSection.classList.add('resizing');
      document.body.style.cursor = 'ns-resize';
      document.body.style.userSelect = 'none';
      
      e.preventDefault();
    }
    
    function doResize(e) {
      if (!resizeState) return;
      
      const { handle, aboveSection, belowSection, startY, aboveStartHeight, belowStartHeight } = resizeState;
      const deltaY = e.clientY - startY;
      
      const minHeight = 50; // Minimum section height (smaller for more control)
      
      let newAboveHeight = aboveStartHeight + deltaY;
      let newBelowHeight = belowStartHeight - deltaY;
      
      // Enforce minimum heights
      if (newAboveHeight < minHeight) {
        newAboveHeight = minHeight;
        newBelowHeight = aboveStartHeight + belowStartHeight - minHeight;
      }
      if (newBelowHeight < minHeight) {
        newBelowHeight = minHeight;
        newAboveHeight = aboveStartHeight + belowStartHeight - minHeight;
      }
      
      // Apply heights using flex-basis
      aboveSection.style.flex = `0 0 ${newAboveHeight}px`;
      belowSection.style.flex = `0 0 ${newBelowHeight}px`;
    }
    
    function stopResize() {
      if (!resizeState) return;
      
      const { handle, aboveSection, belowSection } = resizeState;
      
      handle.classList.remove('active');
      aboveSection.classList.remove('resizing');
      belowSection.classList.remove('resizing');
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      
      resizeState = null;
    }

    // Panel (sidebar) resize functionality
    let panelResizeState = null;
    
    function initPanelResize() {
      const handle = document.getElementById('panelResizeHandle');
      if (handle) {
        handle.addEventListener('mousedown', startPanelResize);
      }
      
      document.addEventListener('mousemove', doPanelResize);
      document.addEventListener('mouseup', stopPanelResize);
    }
    
    function startPanelResize(e) {
      const handle = e.target;
      const panel = document.getElementById('detailPanel');
      
      panelResizeState = {
        handle,
        panel,
        startX: e.clientX,
        startWidth: panel.getBoundingClientRect().width
      };
      
      handle.classList.add('active');
      panel.classList.add('resizing');
      document.body.style.cursor = 'ew-resize';
      document.body.style.userSelect = 'none';
      
      e.preventDefault();
    }
    
    function doPanelResize(e) {
      if (!panelResizeState) return;
      
      const { handle, panel, startX, startWidth } = panelResizeState;
      const deltaX = startX - e.clientX; // Inverted because dragging left increases width
      
      const minWidth = 280;
      const maxWidth = 800;
      
      let newWidth = startWidth + deltaX;
      
      // Enforce min/max widths
      newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
      
      panel.style.width = `${newWidth}px`;
    }
    
    function stopPanelResize() {
      if (!panelResizeState) return;
      
      const { handle, panel } = panelResizeState;
      
      handle.classList.remove('active');
      panel.classList.remove('resizing');
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      
      panelResizeState = null;
    }

    function popoutSection(type) { showToast('Pop-out opened'); }

    function renderTimelineHeader(containerId) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';
      for (let h = 5; h <= 23; h++) {
        const div = document.createElement('div');
        div.className = 'timeline-hour';
        div.textContent = String(h).padStart(2, '0');
        container.appendChild(div);
      }
    }

    // ============================================
    // RENDERING - TIMELINE (STYLE-AWARE)
    // ============================================

    function renderDriverRowStyleA(driver, idx) {
      const statusClass = driver.status === 'leave' ? 'leave' : driver.status === 'available' ? 'available' : 'busy';
      
      let blocksHTML = '';
      
      if (driver.status === 'leave') {
        blocksHTML = `<div class="timeline-duty leave" style="left: 0%; width: 100%;">LEAVE</div>`;
      } else {
        (driver.shifts || []).forEach(shift => {
          // Filter out cancelled duties for Gantt display (unless toggle is on)
          const activeDuties = (shift.duties || []).filter(d => !d.cancelled);
          const cancelledDuties = showCancelledDuties ? (shift.duties || []).filter(d => d.cancelled) : [];
          
          if (activeDuties.length === 0 && cancelledDuties.length === 0) return;
          
          // Only show shift label if there are active duties
          if (activeDuties.length > 0) {
            const shiftLeft = timeToPercent(shift.start);
            blocksHTML += `<div class="shift-label" style="left: ${shiftLeft}%">${shift.name}</div>`;
          }
          
          // Render active duties
          activeDuties.forEach(duty => {
            const left = timeToPercent(duty.start);
            const width = Math.max(timeToPercent(duty.end) - left, 0.5);
            const shortLabel = getDutyShortLabel(duty, width);
            blocksHTML += `<div class="timeline-duty ${duty.type}" style="left: ${left}%; width: ${width}%;">
              <span class="duty-text">${shortLabel}</span>
              ${renderDutyTooltip(duty, shift.name)}
            </div>`;
            
            // Show vehicle indicator for any duty with a vehicle assigned
            if (duty.vehicle) {
              blocksHTML += `<div class="vehicle-status-bar" style="left: ${left}%; width: ${width}%;"></div>`;
            }
          });
          
          // Render cancelled duties as ghost bars
          cancelledDuties.forEach(duty => {
            const left = timeToPercent(duty.start);
            const width = Math.max(timeToPercent(duty.end) - left, 0.5);
            blocksHTML += `<div class="timeline-duty cancelled-ghost" style="left: ${left}%; width: ${width}%;" title="CANCELLED: ${duty.description}${duty.cancelReason ? ' (' + duty.cancelReason + ')' : ''}"></div>`;
          });
        });
      }
      
      return `
        <div class="heatmap-row ${selectedItem?.type === 'driver' && selectedItem?.index === idx ? 'selected' : ''}" 
             onclick="selectItem('driver', ${idx})">
          <div class="row-label">
            <div class="row-status ${statusClass}"></div>
            <span class="row-name">${driver.name}</span>
          </div>
          <div class="row-timeline">${blocksHTML}</div>
        </div>
      `;
    }

    function renderDriverRowStyleBCD(driver, idx, style) {
      const statusClass = driver.status === 'leave' ? 'leave' : driver.status === 'available' ? 'available' : 'busy';
      
      let blocksHTML = '';
      
      if (driver.status === 'leave') {
        blocksHTML = `<div class="timeline-duty leave" style="left: 0%; width: 100%;">LEAVE</div>`;
      } else {
        (driver.shifts || []).forEach(shift => {
          const allDuties = shift.duties || [];
          const activeDuties = allDuties.filter(d => !d.cancelled);
          const cancelledDuties = allDuties.filter(d => d.cancelled);
          
          if (activeDuties.length === 0 && !showCancelledDuties) return;
          if (allDuties.length === 0) return;
          
          const shiftTypeClass = shift.type === 'charter' ? 'charter' : (shift.type === 'adhoc' ? 'adhoc' : 'regular');
          
          if (showCancelledDuties) {
            // Show all duties in one bar
            const dutiesToRender = [...allDuties].sort((a, b) => a.start - b.start);
            const shiftStart = Math.min(...dutiesToRender.map(d => d.start));
            const shiftEnd = Math.max(...dutiesToRender.map(d => d.end));
            const shiftLeft = timeToPercent(shiftStart);
            const shiftWidth = timeToPercent(shiftEnd) - shiftLeft;
            const shiftDuration = shiftEnd - shiftStart;
            
            let segmentsHTML = '';
            let vehicleStripHTML = '';
            
            dutiesToRender.forEach(duty => {
              const dutyWidth = ((duty.end - duty.start) / shiftDuration) * 100;
              const dutyLeft = ((duty.start - shiftStart) / shiftDuration) * 100;
              const isCancelled = duty.cancelled;
              
              if (isCancelled) {
                segmentsHTML += `<div class="segment cancelled-ghost" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="CANCELLED: ${duty.description}${duty.cancelReason ? ' (' + duty.cancelReason + ')' : ''}"></div>`;
                vehicleStripHTML += `<div class="vehicle-segment none" style="left: ${dutyLeft}%; width: ${dutyWidth}%; opacity: 0.3;"></div>`;
              } else {
                segmentsHTML += `<div class="segment ${duty.type}" style="left: ${dutyLeft}%; width: ${dutyWidth}%;"></div>`;
                if (duty.vehicle) {
                  vehicleStripHTML += `<div class="vehicle-segment assigned" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="${duty.vehicle}">${duty.vehicle}</div>`;
                } else if (VEHICLE_REQUIRED_TYPES.includes(duty.type)) {
                  vehicleStripHTML += `<div class="vehicle-segment missing" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="No vehicle"></div>`;
                } else {
                  vehicleStripHTML += `<div class="vehicle-segment none" style="left: ${dutyLeft}%; width: ${dutyWidth}%;"></div>`;
                }
              }
            });
            
            blocksHTML += `
              <div class="shift-bar ${shiftTypeClass}" style="left: ${shiftLeft}%; width: ${shiftWidth}%;">
                ${segmentsHTML}
                <div class="shift-label">${shift.name}</div>
                <div class="vehicle-strip">${vehicleStripHTML}</div>
                ${renderShiftTooltip(shift)}
              </div>
            `;
          } else {
            // Group contiguous active duties into separate bars
            const sortedActive = [...activeDuties].sort((a, b) => a.start - b.start);
            const groups = [];
            let currentGroup = [];
            
            sortedActive.forEach(duty => {
              if (currentGroup.length === 0) {
                currentGroup.push(duty);
              } else {
                const lastDuty = currentGroup[currentGroup.length - 1];
                // Check if this duty is contiguous (starts when last one ends)
                if (Math.abs(duty.start - lastDuty.end) < 0.01) {
                  currentGroup.push(duty);
                } else {
                  groups.push(currentGroup);
                  currentGroup = [duty];
                }
              }
            });
            if (currentGroup.length > 0) {
              groups.push(currentGroup);
            }
            
            // Render each group as a separate shift bar
            groups.forEach((group, groupIdx) => {
              const groupStart = Math.min(...group.map(d => d.start));
              const groupEnd = Math.max(...group.map(d => d.end));
              const groupLeft = timeToPercent(groupStart);
              const groupWidth = timeToPercent(groupEnd) - groupLeft;
              const groupDuration = groupEnd - groupStart;
              
              let segmentsHTML = '';
              let vehicleStripHTML = '';
              
              group.forEach(duty => {
                const dutyWidth = ((duty.end - duty.start) / groupDuration) * 100;
                const dutyLeft = ((duty.start - groupStart) / groupDuration) * 100;
                
                segmentsHTML += `<div class="segment ${duty.type}" style="left: ${dutyLeft}%; width: ${dutyWidth}%;"></div>`;
                if (duty.vehicle) {
                  vehicleStripHTML += `<div class="vehicle-segment assigned" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="${duty.vehicle}">${duty.vehicle}</div>`;
                } else if (VEHICLE_REQUIRED_TYPES.includes(duty.type)) {
                  vehicleStripHTML += `<div class="vehicle-segment missing" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="No vehicle"></div>`;
                } else {
                  vehicleStripHTML += `<div class="vehicle-segment none" style="left: ${dutyLeft}%; width: ${dutyWidth}%;"></div>`;
                }
              });
              
              // Only show shift name on first group
              const label = groupIdx === 0 ? shift.name : '';
              
              blocksHTML += `
                <div class="shift-bar ${shiftTypeClass}" style="left: ${groupLeft}%; width: ${groupWidth}%;">
                  ${segmentsHTML}
                  ${label ? `<div class="shift-label">${label}</div>` : ''}
                  <div class="vehicle-strip">${vehicleStripHTML}</div>
                  ${groupIdx === 0 ? renderShiftTooltip(shift) : ''}
                </div>
              `;
            });
          }
        });
      }
      
      return `
        <div class="heatmap-row ${selectedItem?.type === 'driver' && selectedItem?.index === idx ? 'selected' : ''}" 
             onclick="selectItem('driver', ${idx})">
          <div class="row-label">
            <div class="row-status ${statusClass}"></div>
            <span class="row-name">${driver.name}</span>
          </div>
          <div class="row-timeline">${blocksHTML}</div>
        </div>
      `;
    }

    function renderDriverRowStyleE(driver, idx) {
      const statusClass = driver.status === 'leave' ? 'leave' : driver.status === 'available' ? 'available' : 'busy';
      
      let blocksHTML = '';
      
      if (driver.status === 'leave') {
        blocksHTML = `<div class="timeline-duty leave" style="left: 0%; width: 100%;">LEAVE</div>`;
      } else {
        (driver.shifts || []).forEach(shift => {
          const allDuties = shift.duties || [];
          const activeDuties = allDuties.filter(d => !d.cancelled);
          
          if (activeDuties.length === 0 && !showCancelledDuties) return;
          if (allDuties.length === 0) return;
          
          if (showCancelledDuties) {
            // Show all duties in one bar
            const dutiesToRender = [...allDuties].sort((a, b) => a.start - b.start);
            const shiftStart = Math.min(...dutiesToRender.map(d => d.start));
            const shiftEnd = Math.max(...dutiesToRender.map(d => d.end));
            const shiftLeft = timeToPercent(shiftStart);
            const shiftWidth = timeToPercent(shiftEnd) - shiftLeft;
            const shiftDuration = shiftEnd - shiftStart;
            
            let segmentsHTML = '';
            let vehicleStripHTML = '';
            
            dutiesToRender.forEach(duty => {
              const dutyLeft = ((duty.start - shiftStart) / shiftDuration) * 100;
              const dutyWidth = ((duty.end - duty.start) / shiftDuration) * 100;
              const isCancelled = duty.cancelled;
              const segmentClass = isCancelled ? 'segment cancelled-ghost' : `segment ${duty.type}`;
              const tooltip = isCancelled ? ` title="CANCELLED: ${duty.description}${duty.cancelReason ? ' (' + duty.cancelReason + ')' : ''}"` : '';
              
              segmentsHTML += `<div class="${segmentClass}" style="left: ${dutyLeft}%; width: ${dutyWidth}%;"${tooltip}></div>`;
              
              if (!isCancelled) {
                if (duty.vehicle) {
                  vehicleStripHTML += `<div class="vehicle-segment assigned" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="${duty.vehicle}">${duty.vehicle}</div>`;
                } else if (VEHICLE_REQUIRED_TYPES.includes(duty.type)) {
                  vehicleStripHTML += `<div class="vehicle-segment missing" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="No vehicle"></div>`;
                } else {
                  vehicleStripHTML += `<div class="vehicle-segment none" style="left: ${dutyLeft}%; width: ${dutyWidth}%;"></div>`;
                }
              } else {
                vehicleStripHTML += `<div class="vehicle-segment none" style="left: ${dutyLeft}%; width: ${dutyWidth}%; opacity: 0.3;"></div>`;
              }
            });
            
            blocksHTML += `
              <div class="shift-bar" style="left: ${shiftLeft}%; width: ${shiftWidth}%;">
                ${segmentsHTML}
                <div class="shift-label">${shift.name}</div>
                <div class="vehicle-strip">${vehicleStripHTML}</div>
                ${renderShiftTooltip(shift)}
              </div>
            `;
          } else {
            // Group contiguous active duties into separate bars
            const sortedActive = [...activeDuties].sort((a, b) => a.start - b.start);
            const groups = [];
            let currentGroup = [];
            
            sortedActive.forEach(duty => {
              if (currentGroup.length === 0) {
                currentGroup.push(duty);
              } else {
                const lastDuty = currentGroup[currentGroup.length - 1];
                if (Math.abs(duty.start - lastDuty.end) < 0.01) {
                  currentGroup.push(duty);
                } else {
                  groups.push(currentGroup);
                  currentGroup = [duty];
                }
              }
            });
            if (currentGroup.length > 0) {
              groups.push(currentGroup);
            }
            
            groups.forEach((group, groupIdx) => {
              const groupStart = Math.min(...group.map(d => d.start));
              const groupEnd = Math.max(...group.map(d => d.end));
              const groupLeft = timeToPercent(groupStart);
              const groupWidth = timeToPercent(groupEnd) - groupLeft;
              const groupDuration = groupEnd - groupStart;
              
              let segmentsHTML = '';
              let vehicleStripHTML = '';
              
              group.forEach(duty => {
                const dutyWidth = ((duty.end - duty.start) / groupDuration) * 100;
                const dutyLeft = ((duty.start - groupStart) / groupDuration) * 100;
                
                segmentsHTML += `<div class="segment ${duty.type}" style="left: ${dutyLeft}%; width: ${dutyWidth}%;"></div>`;
                if (duty.vehicle) {
                  vehicleStripHTML += `<div class="vehicle-segment assigned" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="${duty.vehicle}">${duty.vehicle}</div>`;
                } else if (VEHICLE_REQUIRED_TYPES.includes(duty.type)) {
                  vehicleStripHTML += `<div class="vehicle-segment missing" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="No vehicle"></div>`;
                } else {
                  vehicleStripHTML += `<div class="vehicle-segment none" style="left: ${dutyLeft}%; width: ${dutyWidth}%;"></div>`;
                }
              });
              
              const label = groupIdx === 0 ? shift.name : '';
              
              blocksHTML += `
                <div class="shift-bar" style="left: ${groupLeft}%; width: ${groupWidth}%;">
                  ${segmentsHTML}
                  ${label ? `<div class="shift-label">${label}</div>` : ''}
                  <div class="vehicle-strip">${vehicleStripHTML}</div>
                  ${groupIdx === 0 ? renderShiftTooltip(shift) : ''}
                </div>
              `;
            });
          }
        });
      }
      
      return `
        <div class="heatmap-row ${selectedItem?.type === 'driver' && selectedItem?.index === idx ? 'selected' : ''}" 
             onclick="selectItem('driver', ${idx})">
          <div class="row-label">
            <div class="row-status ${statusClass}"></div>
            <span class="row-name">${driver.name}</span>
          </div>
          <div class="row-timeline">${blocksHTML}</div>
        </div>
      `;
    }

    function renderDriverRows() {
      const container = document.getElementById('driverRows');
      const filtered = getFilteredDrivers();
      
      container.innerHTML = filtered.map(driver => {
        const idx = drivers.indexOf(driver);
        
        if (currentStyle === 'style-a') {
          return renderDriverRowStyleA(driver, idx);
        } else if (currentStyle === 'style-e') {
          return renderDriverRowStyleE(driver, idx);
        } else {
          return renderDriverRowStyleBCD(driver, idx, currentStyle);
        }
      }).join('');
    }

    function renderVehicleRows() {
      const container = document.getElementById('vehicleRows');
      const filtered = getFilteredVehicles();
      
      container.innerHTML = filtered.map(vehicle => {
        const idx = vehicles.indexOf(vehicle);
        const statusClass = vehicle.status === 'maintenance' ? 'maintenance' : vehicle.status === 'available' ? 'available' : 'busy';
        
        let blocksHTML = '';
        
        if (currentStyle === 'style-a') {
          // Style A: Fragmented blocks showing duties
          
          // Helper to check if a synced duty's source is cancelled
          const isDutyCancelled = (duty) => {
            if (duty.cancelled) return true;
            if (duty.syncedDutyId) {
              for (const driver of drivers) {
                for (const dShift of driver.shifts || []) {
                  const sourceDuty = (dShift.duties || []).find(d => d.id === duty.syncedDutyId);
                  if (sourceDuty) {
                    return sourceDuty.cancelled === true;
                  }
                }
              }
            }
            return false;
          };
          
          if (allocationMode === 'vehicle' && vehicle.shifts) {
            // Vehicle-centric: show duties with driver assignment indicators
            (vehicle.shifts || []).forEach(shift => {
              const allDuties = shift.duties || [];
              const activeDuties = allDuties.filter(d => !isDutyCancelled(d));
              const cancelledDuties = allDuties.filter(d => isDutyCancelled(d));
              
              if (activeDuties.length === 0 && !showCancelledDuties) return;
              
              const shiftLeft = timeToPercent(shift.start);
              blocksHTML += `<div class="shift-label" style="left: ${shiftLeft}%">${shift.name}</div>`;
              
              // Render active duties
              activeDuties.forEach(duty => {
                const left = timeToPercent(duty.start);
                const width = Math.max(timeToPercent(duty.end) - left, 0.5);
                const shortLabel = getDutyShortLabel(duty, width);
                blocksHTML += `<div class="timeline-duty ${duty.type}" style="left: ${left}%; width: ${width}%;">
                  <span class="duty-text">${shortLabel}</span>
                  ${renderDutyTooltip(duty, shift.name)}
                </div>`;
                
                // Show driver assignment status (green bar if driver assigned)
                if (DRIVER_REQUIRED_TYPES.includes(duty.type) && (duty.driver || duty.driverId)) {
                  blocksHTML += `<div class="vehicle-status-bar" style="left: ${left}%; width: ${width}%;"></div>`;
                }
              });
              
              // Render cancelled duties as ghost bars
              if (showCancelledDuties) {
                cancelledDuties.forEach(duty => {
                  const left = timeToPercent(duty.start);
                  const width = Math.max(timeToPercent(duty.end) - left, 0.5);
                  blocksHTML += `<div class="timeline-duty cancelled-ghost" style="left: ${left}%; width: ${width}%;" title="CANCELLED: ${duty.description || ''}"></div>`;
                });
              }
            });
          } else {
            // Driver-centric: simple blocks with tooltip
            (vehicle.shifts || []).forEach(shift => {
              const allDuties = shift.duties || [];
              const hasActiveDuties = allDuties.some(d => !isDutyCancelled(d));
              
              if (!hasActiveDuties && !showCancelledDuties) return;
              
              const left = timeToPercent(shift.start);
              const width = timeToPercent(shift.end) - left;
              const typeClass = shift.type === 'maintenance' ? 'maintenance' : 'driving';
              const shortLabel = width < 4 ? '' : (shift.type === 'maintenance' ? 'MAINT' : shift.name.substring(0, 8));
              const fullLabel = shift.type === 'maintenance' ? 'Maintenance' : shift.name;
              // Create a simple tooltip for shift-level blocks
              const tooltip = `<div class="timeline-duty-tooltip">
                <div class="tooltip-title">${fullLabel}</div>
                <div class="tooltip-row"><span class="tooltip-label">Time</span><span class="tooltip-value">${formatTime(shift.start)} - ${formatTime(shift.end)}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">Hours</span><span class="tooltip-value">${(shift.end - shift.start).toFixed(2)}h</span></div>
              </div>`;
              blocksHTML += `<div class="timeline-duty ${typeClass}" style="left: ${left}%; width: ${width}%;">
                <span class="duty-text">${shortLabel}</span>
                ${tooltip}
              </div>`;
            });
          }
        } else {
          // Styles B, C, D, E: Unified bars with driver strip
          (vehicle.shifts || []).forEach(shift => {
            const allDuties = shift.duties || [];
            
            // Helper to check if a synced duty's source is cancelled
            const isDutyCancelled = (duty) => {
              if (duty.cancelled) return true;
              // Check if the source duty on a driver is cancelled
              if (duty.syncedDutyId) {
                for (const driver of drivers) {
                  for (const dShift of driver.shifts || []) {
                    const sourceDuty = (dShift.duties || []).find(d => d.id === duty.syncedDutyId);
                    if (sourceDuty) {
                      return sourceDuty.cancelled === true;
                    }
                  }
                }
              }
              return false;
            };
            
            const activeDuties = allDuties.filter(d => !isDutyCancelled(d));
            const typeClass = shift.type === 'maintenance' ? 'maintenance' : (shift.type === 'charter' ? 'charter' : 'regular');
            const label = shift.type === 'maintenance' ? 'MAINT' : shift.name;
            
            if (activeDuties.length === 0 && !showCancelledDuties) return;
            if (allDuties.length === 0) return;
            
            if (showCancelledDuties) {
              // Show all duties in one bar
              const dutiesToRender = [...allDuties].sort((a, b) => a.start - b.start);
              const shiftStart = Math.min(...dutiesToRender.map(d => d.start));
              const shiftEnd = Math.max(...dutiesToRender.map(d => d.end));
              const left = timeToPercent(shiftStart);
              const width = timeToPercent(shiftEnd) - left;
              const shiftDuration = shiftEnd - shiftStart;
              
              let segmentsHTML = '';
              let driverStripHTML = '';
              
              dutiesToRender.forEach(duty => {
                const dutyWidth = ((duty.end - duty.start) / shiftDuration) * 100;
                const dutyLeft = ((duty.start - shiftStart) / shiftDuration) * 100;
                const isCancelled = isDutyCancelled(duty);
                
                if (isCancelled) {
                  segmentsHTML += `<div class="segment cancelled-ghost" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="CANCELLED: ${duty.description || ''}"></div>`;
                  driverStripHTML += `<div class="vehicle-segment none" style="left: ${dutyLeft}%; width: ${dutyWidth}%; opacity: 0.3;"></div>`;
                } else {
                  segmentsHTML += `<div class="segment ${duty.type}" style="left: ${dutyLeft}%; width: ${dutyWidth}%;"></div>`;
                  const hasDriver = duty.driver || duty.driverId;
                  if (hasDriver) {
                    let driverName = duty.driver;
                    if (!driverName && duty.driverId) {
                      const driverObj = drivers.find(d => d.id === duty.driverId);
                      driverName = driverObj ? driverObj.name : duty.driverId;
                    }
                    driverStripHTML += `<div class="vehicle-segment assigned" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="${driverName}">${driverName}</div>`;
                  } else if (DRIVER_REQUIRED_TYPES.includes(duty.type)) {
                    driverStripHTML += `<div class="vehicle-segment missing" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="No driver"></div>`;
                  } else {
                    driverStripHTML += `<div class="vehicle-segment none" style="left: ${dutyLeft}%; width: ${dutyWidth}%;"></div>`;
                  }
                }
              });
              
              blocksHTML += `
                <div class="shift-bar ${typeClass}" style="left: ${left}%; width: ${width}%;">
                  ${segmentsHTML}
                  <div class="shift-label">${label}</div>
                  <div class="vehicle-strip">${driverStripHTML}</div>
                  ${renderShiftTooltip(shift)}
                </div>
              `;
            } else {
              // Group contiguous active duties into separate bars
              const sortedActive = [...activeDuties].sort((a, b) => a.start - b.start);
              const groups = [];
              let currentGroup = [];
              
              sortedActive.forEach(duty => {
                if (currentGroup.length === 0) {
                  currentGroup.push(duty);
                } else {
                  const lastDuty = currentGroup[currentGroup.length - 1];
                  if (Math.abs(duty.start - lastDuty.end) < 0.01) {
                    currentGroup.push(duty);
                  } else {
                    groups.push(currentGroup);
                    currentGroup = [duty];
                  }
                }
              });
              if (currentGroup.length > 0) {
                groups.push(currentGroup);
              }
              
              groups.forEach((group, groupIdx) => {
                const groupStart = Math.min(...group.map(d => d.start));
                const groupEnd = Math.max(...group.map(d => d.end));
                const groupLeft = timeToPercent(groupStart);
                const groupWidth = timeToPercent(groupEnd) - groupLeft;
                const groupDuration = groupEnd - groupStart;
                
                let segmentsHTML = '';
                let driverStripHTML = '';
                
                group.forEach(duty => {
                  const dutyWidth = ((duty.end - duty.start) / groupDuration) * 100;
                  const dutyLeft = ((duty.start - groupStart) / groupDuration) * 100;
                  
                  segmentsHTML += `<div class="segment ${duty.type}" style="left: ${dutyLeft}%; width: ${dutyWidth}%;"></div>`;
                  
                  const hasDriver = duty.driver || duty.driverId;
                  if (hasDriver) {
                    let driverName = duty.driver;
                    if (!driverName && duty.driverId) {
                      const driverObj = drivers.find(d => d.id === duty.driverId);
                      driverName = driverObj ? driverObj.name : duty.driverId;
                    }
                    driverStripHTML += `<div class="vehicle-segment assigned" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="${driverName}">${driverName}</div>`;
                  } else if (DRIVER_REQUIRED_TYPES.includes(duty.type)) {
                    driverStripHTML += `<div class="vehicle-segment missing" style="left: ${dutyLeft}%; width: ${dutyWidth}%;" title="No driver"></div>`;
                  } else {
                    driverStripHTML += `<div class="vehicle-segment none" style="left: ${dutyLeft}%; width: ${dutyWidth}%;"></div>`;
                  }
                });
                
                const groupLabel = groupIdx === 0 ? label : '';
                
                blocksHTML += `
                  <div class="shift-bar ${typeClass}" style="left: ${groupLeft}%; width: ${groupWidth}%;">
                    ${segmentsHTML}
                    ${groupLabel ? `<div class="shift-label">${groupLabel}</div>` : ''}
                    <div class="vehicle-strip">${driverStripHTML}</div>
                    ${groupIdx === 0 ? renderShiftTooltip(shift) : ''}
                  </div>
                `;
              });
            }
          });
        }
        
        return `
          <div class="heatmap-row ${selectedItem?.type === 'vehicle' && selectedItem?.index === idx ? 'selected' : ''}"
               onclick="selectItem('vehicle', ${idx})">
            <div class="row-label">
              <div class="row-status ${statusClass}"></div>
              <span class="row-name">${vehicle.id}</span>
            </div>
            <div class="row-timeline">${blocksHTML}</div>
          </div>
        `;
      }).join('');
    }

    function renderUnassignedRows() {
      const container = document.getElementById('unassignedRows');
      const filtered = getFilteredJobs();
      
      container.innerHTML = filtered.map(job => {
        // Filter out cancelled duties for display
        const activeDuties = (job.duties || []).filter(d => !d.cancelled);
        if (activeDuties.length === 0) return ''; // Skip job entirely if all duties cancelled
        
        const idx = unassignedJobs.indexOf(job);
        
        // Recalculate bounds based on active duties only
        const activeStart = Math.min(...activeDuties.map(d => d.start));
        const activeEnd = Math.max(...activeDuties.map(d => d.end));
        
        const left = timeToPercent(activeStart);
        const width = timeToPercent(activeEnd) - left;
        
        return `
          <div class="heatmap-row ${selectedItem?.type === 'job' && selectedItem?.index === idx ? 'selected' : ''}"
               onclick="selectItem('job', ${idx})">
            <div class="row-label"><span class="row-name">${job.name}</span></div>
            <div class="row-timeline">
              <div class="time-block unassigned-job" style="left: ${left}%; width: ${width}%;">${job.name}</div>
            </div>
          </div>
        `;
      }).join('');
    }

    function renderAll() {
      renderDriverRows();
      renderVehicleRows();
      renderUnassignedRows();
      
      // Render vertical views if in vertical mode
      if (viewMode === 'vertical') {
        renderDriverVertical();
        renderVehicleVertical();
        renderUnassignedVertical();
      }
      
      updateStats();
      renderDetailPanel();
    }

    function updateStats() {
      const fd = getFilteredDrivers(), fv = getFilteredVehicles(), fj = getFilteredJobs();
      document.getElementById('statDriversAvail').textContent = fd.filter(d => d.status === 'available').length;
      document.getElementById('statDriversWork').textContent = fd.filter(d => d.status === 'working').length;
      document.getElementById('statDriversLeave').textContent = fd.filter(d => d.status === 'leave').length;
      document.getElementById('statVehiclesAvail').textContent = fv.filter(v => v.status === 'available').length;
      document.getElementById('statVehiclesMaint').textContent = fv.filter(v => v.status === 'maintenance').length;
      document.getElementById('statUnassigned').textContent = fj.length;
      document.getElementById('driverCount').textContent = fd.length;
      document.getElementById('driverAvail').textContent = fd.filter(d => d.status === 'available').length;
      document.getElementById('driverLeave').textContent = fd.filter(d => d.status === 'leave').length;
      document.getElementById('vehicleCount').textContent = fv.length;
      document.getElementById('vehicleAvail').textContent = fv.filter(v => v.status === 'available').length;
      document.getElementById('vehicleMaint').textContent = fv.filter(v => v.status === 'maintenance').length;
      document.getElementById('unassignedCount').textContent = fj.length;
    }

    function selectItem(type, index) {
      document.querySelectorAll('.heatmap-row.selected').forEach(el => el.classList.remove('selected'));
      document.querySelectorAll('.nav-highlight').forEach(el => el.classList.remove('nav-highlight'));
      selectedItem = { type, index };
      editingDuty = null;
      formErrors = {};
      renderAll();
    }
    
    function navigateToResource(type, index) {
      // Just scroll to and highlight the resource - don't change selection
      // This lets users peek at a driver/vehicle while keeping their current panel context
      
      // Remove any existing nav highlights
      document.querySelectorAll('.nav-highlight').forEach(el => el.classList.remove('nav-highlight'));
      
      setTimeout(() => {
        let rowSelector;
        if (viewMode === 'vertical') {
          rowSelector = `.vertical-column[onclick*="selectItem('${type}', ${index})"]`;
        } else {
          rowSelector = `.heatmap-row[onclick*="selectItem('${type}', ${index})"]`;
        }
        
        const row = document.querySelector(rowSelector);
        if (row) {
          row.scrollIntoView({ behavior: 'smooth', block: 'center' });
          row.classList.add('nav-highlight');
        }
      }, 50);
    }

    function renderDetailPanel() {
      const panel = document.getElementById('detailPanel');
      
      if (!selectedItem) {
        panel.innerHTML = `<div class="empty-panel"><div class="empty-icon"></div><div class="empty-text">Select a ${allocationMode === 'vehicle' ? 'vehicle' : 'driver'}, ${allocationMode === 'vehicle' ? 'driver' : 'vehicle'}, or job</div></div>`;
        return;
      }
      
      if (selectedItem.type === 'driver') {
        const driver = drivers[selectedItem.index];
        if (!driver) {
          selectedItem = null;
          panel.innerHTML = `<div class="empty-panel"><div class="empty-icon"></div><div class="empty-text">Driver not found</div></div>`;
          return;
        }
        panel.innerHTML = renderDriverDetail(driver);
        // Populate transfer list if in transfer mode
        if (transferringShift && transferringShift.type === 'driver') {
          setTimeout(() => updateTransferDriverList(), 0);
        }
        // Populate bulk assign list if in bulk assign mode
        if (bulkAssigning && bulkAssigning.type === 'vehicle') {
          setTimeout(() => updateBulkVehicleList(), 0);
        }
      } else if (selectedItem.type === 'vehicle') {
        const vehicle = vehicles[selectedItem.index];
        if (!vehicle) {
          selectedItem = null;
          panel.innerHTML = `<div class="empty-panel"><div class="empty-icon"></div><div class="empty-text">Vehicle not found</div></div>`;
          return;
        }
        panel.innerHTML = renderVehicleDetail(vehicle);
        // Populate transfer list if in transfer mode
        if (transferringShift && transferringShift.type === 'vehicle') {
          setTimeout(() => updateTransferVehicleList(), 0);
        }
        // Populate bulk assign list if in bulk assign mode
        if (bulkAssigning && bulkAssigning.type === 'driver') {
          setTimeout(() => updateBulkDriverList(), 0);
        }
      } else if (selectedItem.type === 'job') {
        const job = unassignedJobs[selectedItem.index];
        if (!job) {
          selectedItem = null;
          panel.innerHTML = `<div class="empty-panel"><div class="empty-icon"></div><div class="empty-text">Job not found</div></div>`;
          return;
        }
        panel.innerHTML = renderJobDetail(job);
        // Populate assignment list after render
        setTimeout(() => {
          if (allocationMode === 'vehicle') {
            updateVehicleAssignmentList(selectedItem.index);
          } else {
            updateDriverAssignmentList(selectedItem.index);
          }
        }, 0);
      }
    }

    function renderDriverDetail(driver) {
      if (allocationMode === 'vehicle') {
        return renderDriverDetailVehicleCentric(driver);
      }
      return renderDriverDetailDriverCentric(driver);
    }
    
    function renderDriverDetailDriverCentric(driver) {
      let scheduleHTML = '';
      
      // Check if we're in transfer mode for this driver
      let transferPanelHTML = '';
      if (transferringShift && transferringShift.type === 'driver') {
        const shift = transferringShift.shift;
        
        transferPanelHTML = `
          <div class="panel-section" style="background: rgba(59, 130, 246, 0.1); border: 1px solid var(--accent-blue); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
            <div class="panel-section-title" style="color: var(--accent-blue);">Transfer: ${shift.name}</div>
            <div class="info-row"><span class="info-label">Time</span><span class="info-value">${formatTime(shift.start)} - ${formatTime(shift.end)}</span></div>
            <div class="assignment-panel">
              <div class="assignment-search">
                <input type="text" class="assignment-search-input" id="transferDriverSearch" 
                       placeholder="Search drivers..." oninput="updateTransferDriverList()">
              </div>
              <div class="assignment-count" id="transferDriverCount"></div>
              <div class="assignment-list" id="transferDriverList"></div>
            </div>
            <button class="transfer-cancel-btn" onclick="cancelTransfer()">Cancel Transfer</button>
          </div>
        `;
      }
      
      // Check for smart suggestions
      const driverIndex = drivers.indexOf(driver);
      const endingInfo = getDriverEndingInfo(driver);
      const suggestionPanelHTML = renderSuggestionPanel(endingInfo, 'driver', driverIndex);
      
      if (driver.status === 'leave') {
        scheduleHTML = `<div class="info-row"><span class="info-value" style="color: var(--accent-red)">On Leave</span></div>`;
      } else if (!driver.shifts || driver.shifts.length === 0) {
        scheduleHTML = `<div class="info-row"><span class="info-value" style="color: var(--accent-green)">Available All Day</span></div>`;
      } else {
        scheduleHTML = driver.shifts.map((shift, shiftIdx) => {
          const vehicleStatus = getShiftVehicleStatus(shift);
          return `
            <div class="shift-block">
              <div class="shift-block-header">
                <div class="shift-block-title">${shift.name}</div>
                <div class="shift-block-meta">
                  <span class="shift-vehicle-status ${vehicleStatus.status}">${vehicleStatus.label}</span>
                  <span class="shift-block-time">${formatTime(shift.start)}-${formatTime(shift.end)}</span>
                </div>
              </div>
              <div class="shift-block-actions">
                ${vehicleStatus.status !== 'complete' ? `<button class="shift-action-btn primary" onclick="showBulkAssignVehicle('${driver.id}', '${shift.id}')" title="Assign vehicle to all unassigned duties">Assign All</button>` : ''}
                <button class="shift-action-btn" onclick="showTransferDriverShift('${driver.id}', ${shiftIdx})" title="Transfer to another driver">Transfer</button>
                <button class="shift-action-btn danger" onclick="cancelAllDuties('${driver.id}', '${shift.id}')" title="Cancel all duties in this shift">Cancel All</button>
                <button class="shift-action-btn danger" onclick="unassignDriverShift('${driver.id}', ${shiftIdx})" title="Remove and move to unassigned">Unassign</button>
              </div>
              ${bulkAssigning && bulkAssigning.type === 'vehicle' && bulkAssigning.driverId === driver.id && bulkAssigning.shiftId === shift.id ? renderBulkAssignVehiclePanel() : ''}
              <div class="shift-block-content">
                <div class="duty-list-header">
                  <span class="duty-header-time">Start</span>
                  <span class="duty-header-sep"></span>
                  <span class="duty-header-time">End</span>
                  <span class="duty-header-type">Type</span>
                  <span class="duty-header-desc">Desc</span>
                  <span class="duty-header-location">Location</span>
                  <span class="duty-header-vehicle">Vehicle</span>
                  <span class="duty-header-pay">Pay</span>
                  <span class="duty-header-hours">Hours</span>
                  <span class="duty-header-actions"></span>
                </div>
                <div class="duty-list">
                  ${shift.duties.map((duty, idx) => renderDutyItem(duty, driver.id, shift.id, idx)).join('')}
                </div>
                ${renderShiftTotals(shift, driver.id)}
              </div>
            </div>
          `;
        }).join('');
      }
      
      return `
        <div class="panel-header">
          <div class="panel-header-info">
            <div class="panel-title">${driver.fullName}</div>
            <div class="panel-subtitle">${driver.id}</div>
          </div>
          <div class="panel-actions">
            <button class="panel-action-btn" onclick="showToast('Calling ${driver.phone}...')"></button>
            <button class="panel-action-btn" onclick="showToast('Opening message...')"></button>
          </div>
        </div>
        <div class="panel-content">
          <div class="panel-section">
            <div class="info-row"><span class="info-label">Phone</span><span class="info-value">${driver.phone}</span></div>
            <div class="info-row"><span class="info-label">Licence</span><span class="info-value">${driver.licence}</span></div>
          </div>
          ${transferPanelHTML}
          <div class="panel-section">
            <div class="panel-section-header">
              <span class="panel-section-title">Today's Schedule</span>
              ${driver.status !== 'leave' ? `<button class="panel-section-action" onclick="showAddDutyForm('${driver.id}')">+ Add Duty</button>` : ''}
            </div>
            ${editingDuty ? renderEditForm() : ''}
            ${scheduleHTML}
          </div>
          ${suggestionPanelHTML}
        </div>
      `;
    }
    
    function renderDriverDetailVehicleCentric(driver) {
      // Simplified view - shows driver info and which vehicles they're assigned to
      let assignmentsHTML = '';
      
      if (driver.status === 'leave') {
        assignmentsHTML = `<div class="info-row"><span class="info-value" style="color: var(--accent-red)">On Leave</span></div>`;
      } else if (driver.status === 'available') {
        assignmentsHTML = `<div class="info-row"><span class="info-value" style="color: var(--accent-green)">Available - Can be assigned to vehicle duties</span></div>`;
      } else {
        // Find which vehicles this driver is assigned to (group by vehicle)
        const vehicleAssignments = new Map();
        vehicles.forEach((v, vIdx) => {
          v.shifts.forEach(shift => {
            shift.duties.forEach(duty => {
              if (duty.driverId === driver.id || duty.driver === driver.name) {
                if (!vehicleAssignments.has(v.id)) {
                  vehicleAssignments.set(v.id, {
                    vehicle: v,
                    vehicleIdx: vIdx,
                    duties: []
                  });
                }
                vehicleAssignments.get(v.id).duties.push({
                  shiftName: shift.name,
                  start: duty.start,
                  end: duty.end,
                  description: duty.description,
                  type: duty.type
                });
              }
            });
          });
        });
        
        if (vehicleAssignments.size > 0) {
          assignmentsHTML = `<div class="duty-list">
            ${Array.from(vehicleAssignments.values()).map(va => {
              const totalHours = va.duties.reduce((sum, d) => sum + (d.end - d.start), 0);
              const minStart = Math.min(...va.duties.map(d => d.start));
              const maxEnd = Math.max(...va.duties.map(d => d.end));
              
              return `
                <div class="vehicle-schedule-item clickable" onclick="navigateToResource('vehicle', ${va.vehicleIdx})">
                  <div class="vehicle-schedule-header">
                    <span class="vehicle-schedule-time">${formatTime(minStart)}-${formatTime(maxEnd)}</span>
                    <span class="vehicle-schedule-badge">${va.vehicle.capacity} SEATS</span>
                  </div>
                  <div class="vehicle-schedule-driver">
                    
                    <span class="driver-name">${va.vehicle.id}</span>
                    <span class="nav-arrow"></span>
                  </div>
                  <div class="vehicle-schedule-details">
                    <span class="detail-item">${va.duties.length} ${va.duties.length === 1 ? 'duty' : 'duties'}</span>
                    <span class="detail-item">${formatDutyHours(totalHours)}</span>
                    <span class="detail-item">${va.vehicle.rego}</span>
                  </div>
                </div>
              `;
            }).join('')}
          </div>`;
        } else {
          assignmentsHTML = `<div class="info-row"><span class="info-value" style="color: var(--text-muted)">No vehicle assignments</span></div>`;
        }
      }
      
      // Calculate total hours
      const totalHours = driver.shifts.reduce((sum, s) => 
        sum + s.duties.reduce((dSum, d) => dSum + (d.end - d.start), 0), 0);
      
      return `
        <div class="panel-header">
          <div class="panel-header-info">
            <div class="panel-title">${driver.fullName}</div>
            <div class="panel-subtitle">${driver.id}</div>
          </div>
          <div class="panel-actions">
            <button class="panel-action-btn" onclick="showToast('Calling ${driver.phone}...')"></button>
            <button class="panel-action-btn" onclick="showToast('Opening message...')"></button>
          </div>
        </div>
        <div class="panel-content">
          <div class="panel-section">
            <div class="info-row"><span class="info-label">Phone</span><span class="info-value">${driver.phone}</span></div>
            <div class="info-row"><span class="info-label">Licence</span><span class="info-value">${driver.licence}</span></div>
            <div class="info-row">
              <span class="info-label">Status</span>
              <span class="info-value" style="color: ${driver.status === 'leave' ? 'var(--accent-red)' : driver.status === 'available' ? 'var(--accent-green)' : 'var(--accent-blue)'}">
                ${driver.status === 'leave' ? 'On Leave' : driver.status === 'available' ? 'Available' : 'Working'}
              </span>
            </div>
            ${totalHours > 0 ? `<div class="info-row"><span class="info-label">Today's Hours</span><span class="info-value">${formatDutyHours(totalHours)}</span></div>` : ''}
          </div>
          <div class="panel-section">
            <div class="panel-section-title">Vehicle Assignments</div>
            ${driver.status === 'working' ? '<div class="panel-section-hint">Click a vehicle to view schedule</div>' : ''}
            ${assignmentsHTML}
          </div>
        </div>
      `;
    }

    function renderDutyItem(duty, driverId, shiftId, dutyIdx) {
      const dt = DUTY_TYPES[duty.type] || DUTY_TYPES.driving;
      const needsVehicle = VEHICLE_REQUIRED_TYPES.includes(duty.type);
      const isCancelled = duty.cancelled === true;
      
      // Calculate hours for this duty
      const hours = duty.end - duty.start;
      const hoursStr = formatDutyHours(hours);
      
      // Get pay type (default to standard if not set)
      const payType = duty.payType || 'standard';
      
      // Get available vehicles for this duty's time slot
      const availableVehicles = vehicles.filter(v => 
        v.status !== 'maintenance' && 
        isVehicleAvailableForDuty(v.id, duty.start, duty.end, duty.id)
      );
      
      // Vehicle dropdown options
      const vehicleOptions = `
        <option value="">--</option>
        ${availableVehicles.map(v => `
          <option value="${v.id}" ${duty.vehicle === v.id ? 'selected' : ''}>${v.id}</option>
        `).join('')}
        ${duty.vehicle && !availableVehicles.find(v => v.id === duty.vehicle) ? 
          `<option value="${duty.vehicle}" selected>${duty.vehicle}</option>` : ''}
      `;
      
      // Duty type options (compact)
      const typeOptions = Object.entries(DUTY_TYPES).map(([key, val]) => 
        `<option value="${key}" ${duty.type === key ? 'selected' : ''}>${val.label}</option>`
      ).join('');
      
      // Pay type options
      const payTypeOptions = Object.entries(PAY_TYPES).map(([key, val]) => 
        `<option value="${key}" ${payType === key ? 'selected' : ''}>${val.code}</option>`
      ).join('');
      
      // For cancelled duties, show simplified row with reinstate button
      if (isCancelled) {
        return `
          <div class="duty-item-inline cancelled">
            <div class="duty-type-bar ${duty.type}" style="opacity: 0.4;"></div>
            <div class="duty-inline-content">
              <span class="duty-cancelled-badge">CANCELLED</span>
              <span style="color: var(--text-muted); margin-right: 8px;">${formatTimeCompact(duty.start)} - ${formatTimeCompact(duty.end)}</span>
              <span style="color: var(--text-muted); flex: 1;">${duty.description}${duty.cancelReason ? ` (${duty.cancelReason})` : ''}</span>
              <button class="duty-reinstate-btn" onclick="event.stopPropagation(); reinstateDutyLine('${duty.id}', '${driverId}', '${shiftId}')" title="Reinstate this duty">Reinstate</button>
            </div>
          </div>
        `;
      }
      
      // Active duty - full editing with cancel button
      return `
        <div class="duty-item-inline">
          <div class="duty-insert-arrows">
            <button class="duty-insert-btn" onclick="event.stopPropagation(); insertDuty('${driverId}', '${shiftId}', ${dutyIdx}, 'above')" title="Insert duty above">+</button>
            <button class="duty-insert-btn" onclick="event.stopPropagation(); insertDuty('${driverId}', '${shiftId}', ${dutyIdx}, 'below')" title="Insert duty below">+</button>
          </div>
          <div class="duty-type-bar ${duty.type}"></div>
          <div class="duty-inline-content">
            <input type="text" class="duty-inline-time" value="${formatTimeCompact(duty.start)}" 
                   onchange="updateDutyTime('${driverId}', '${shiftId}', ${dutyIdx}, 'start', this.value)"
                   title="Start time">
            <span class="duty-time-sep">-</span>
            <input type="text" class="duty-inline-time" value="${formatTimeCompact(duty.end)}" 
                   onchange="updateDutyTime('${driverId}', '${shiftId}', ${dutyIdx}, 'end', this.value)"
                   title="End time">
            <select class="duty-inline-select type" onchange="updateDutyType('${driverId}', '${shiftId}', ${dutyIdx}, this.value)" title="Duty type">
              ${typeOptions}
            </select>
            <input type="text" class="duty-inline-desc" value="${duty.description}" 
                   onchange="updateDutyDesc('${driverId}', '${shiftId}', ${dutyIdx}, this.value)"
                   placeholder="Description..." title="Description">
            <div class="duty-inline-location-wrapper">
              <input type="text" class="duty-inline-location" 
                     id="dutyLoc_${driverId}_${shiftId}_${dutyIdx}"
                     value="${duty.locationName || ''}" 
                     oninput="onLocationInput('dutyLoc_${driverId}_${shiftId}_${dutyIdx}')"
                     onblur="setTimeout(() => saveDutyLocation('${driverId}', '${shiftId}', ${dutyIdx}), 200)"
                     placeholder="Location..." title="Location (for smart assignment)">
              <input type="hidden" id="dutyLoc_${driverId}_${shiftId}_${dutyIdx}Lat" value="${duty.locationLat || ''}">
              <input type="hidden" id="dutyLoc_${driverId}_${shiftId}_${dutyIdx}Lng" value="${duty.locationLng || ''}">
            </div>
            <select class="duty-inline-select vehicle ${!duty.vehicle && needsVehicle ? 'missing' : ''}" 
                    onchange="updateDutyVehicle('${driverId}', '${shiftId}', ${dutyIdx}, this.value)" title="Vehicle">
              ${vehicleOptions}
            </select>
            <select class="duty-inline-select pay" onchange="updateDutyPayType('${driverId}', '${shiftId}', ${dutyIdx}, this.value)" title="Pay type">
              ${payTypeOptions}
            </select>
            <span class="duty-inline-hours">${hoursStr}</span>
            <button class="duty-cancel-btn" onclick="event.stopPropagation(); openCancelDutyModal('${duty.id}', '${driverId}', '${shiftId}', ${dutyIdx})" title="Cancel duty"></button>
          </div>
        </div>
      `;
    }
    
    function formatTimeCompact(time) {
      const h = Math.floor(time);
      const m = Math.round((time - h) * 60);
      return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
    }
    
    async function updateDutyTime(driverId, shiftId, dutyIdx, field, value) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === shiftId);
      if (!shift || !shift.duties[dutyIdx]) return;
      
      const duty = shift.duties[dutyIdx];
      const newTime = parseTime(value);
      
      if (isNaN(newTime)) {
        showToast('Invalid time format', 'error');
        renderDetailPanel();
        return;
      }
      
      const oldVehicle = duty.vehicle;
      const newStart = field === 'start' ? newTime : duty.start;
      const newEnd = field === 'end' ? newTime : duty.end;
      
      if (newStart >= newEnd) {
        showToast('End must be after start', 'error');
        renderDetailPanel();
        return;
      }
      
      // Check for overlaps with other duties in THIS shift
      const overlapInShift = shift.duties.find((d, i) => {
        if (i === dutyIdx) return false;
        return newStart < d.end && newEnd > d.start;
      });
      
      if (overlapInShift) {
        showToast(`Overlaps with ${formatTime(overlapInShift.start)}-${formatTime(overlapInShift.end)}`, 'error');
        renderDetailPanel();
        return;
      }
      
      // Check for overlaps with OTHER shifts for this driver
      const overlapOtherShift = driver.shifts.find(s => {
        if (s.id === shiftId) return false; // Skip current shift
        // Check if new time range overlaps with this shift's time range
        return newStart < s.end && newEnd > s.start;
      });
      
      if (overlapOtherShift) {
        showToast(`Overlaps with ${overlapOtherShift.name || 'another shift'} (${formatTime(overlapOtherShift.start)}-${formatTime(overlapOtherShift.end)})`, 'error');
        renderDetailPanel();
        return;
      }
      
      // Check vehicle availability if vehicle assigned
      if (duty.vehicle && !isVehicleAvailableForDuty(duty.vehicle, newStart, newEnd, duty.id)) {
        showToast(`${duty.vehicle} not available for new time`, 'error');
        renderDetailPanel();
        return;
      }
      
      // Call API in real mode
      if (dataSource === 'real' && duty.id && !duty.id.startsWith('placeholder-') && !duty.id.startsWith('d-')) {
        try {
          const body = { duty_line_id: duty.id };
          if (field === 'start') body.start_time = newTime;
          if (field === 'end') body.end_time = newTime;
          
          const result = await apiRequest('/dispatch/update-duty-line', {
            method: 'POST',
            body
          });
          
          if (result.error) {
            showToast(result.error, 'error');
            renderDetailPanel();
            return;
          }
        } catch (err) {
          showToast(err.message || 'Update failed', 'error');
          renderDetailPanel();
          return;
        }
      }
      
      // Update the duty
      if (oldVehicle) unsyncVehicleSchedule(oldVehicle, duty.id);
      duty[field] = newTime;
      if (duty.vehicle) syncVehicleSchedule(duty.vehicle, duty, driver, shift);
      
      // Update shift bounds if needed
      updateShiftBounds(shift);
      
      renderDetailPanel();
      renderAll();
    }
    
    async function updateDutyDesc(driverId, shiftId, dutyIdx, value) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === shiftId);
      if (!shift || !shift.duties[dutyIdx]) return;
      
      const duty = shift.duties[dutyIdx];
      
      // Call API in real mode
      if (dataSource === 'real' && duty.id && !duty.id.startsWith('placeholder-') && !duty.id.startsWith('d-')) {
        try {
          const result = await apiRequest('/dispatch/update-duty-line', {
            method: 'POST',
            body: {
              duty_line_id: duty.id,
              description: value
            }
          });
          
          if (result.error) {
            showToast(result.error, 'error');
            return;
          }
        } catch (err) {
          showToast(err.message || 'Update failed', 'error');
          return;
        }
      }
      
      duty.description = value;
      
      // Sync to vehicle if assigned
      if (duty.vehicle) {
        syncVehicleSchedule(duty.vehicle, duty, driver, shift);
      }
    }
    
    async function updateDutyLocation(driverId, shiftId, dutyIdx, locationName, locationLat, locationLng) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === shiftId);
      if (!shift || !shift.duties[dutyIdx]) return;
      
      const duty = shift.duties[dutyIdx];
      
      // Call API in real mode
      if (dataSource === 'real' && duty.id && !duty.id.startsWith('placeholder-') && !duty.id.startsWith('d-')) {
        try {
          const result = await apiRequest('/dispatch/update-duty-line', {
            method: 'POST',
            body: {
              duty_line_id: duty.id,
              location_name: locationName || null,
              location_lat: locationLat || null,
              location_lng: locationLng || null
            }
          });
          
          if (result.error) {
            showToast(result.error, 'error');
            return;
          }
        } catch (err) {
          showToast(err.message || 'Update failed', 'error');
          return;
        }
      }
      
      // Update local duty
      duty.locationName = locationName;
      duty.locationLat = locationLat;
      duty.locationLng = locationLng;
      
      showToast('Location updated');
    }
    
    // Wrapper for inline location input - reads from DOM and calls updateDutyLocation
    function saveDutyLocation(driverId, shiftId, dutyIdx) {
      const inputId = `dutyLoc_${driverId}_${shiftId}_${dutyIdx}`;
      const nameInput = document.getElementById(inputId);
      const latInput = document.getElementById(inputId + 'Lat');
      const lngInput = document.getElementById(inputId + 'Lng');
      
      if (!nameInput) return;
      
      const locationName = nameInput.value || null;
      const locationLat = parseFloat(latInput?.value) || null;
      const locationLng = parseFloat(lngInput?.value) || null;
      
      updateDutyLocation(driverId, shiftId, dutyIdx, locationName, locationLat, locationLng);
    }
    
    async function updateDutyType(driverId, shiftId, dutyIdx, value) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === shiftId);
      if (!shift || !shift.duties[dutyIdx]) return;
      
      const duty = shift.duties[dutyIdx];
      const oldVehicle = duty.vehicle;
      
      // Map frontend type to backend type
      const backendTypeMap = {
        'driving': 'DRIVE',
        'oov': 'OOV',
        'break': 'BREAK',
        'waiting': 'WAIT',
        'dead': 'DEAD',
        'charter': 'CHARTER'
      };
      
      // Call API in real mode
      if (dataSource === 'real' && duty.id && !duty.id.startsWith('placeholder-') && !duty.id.startsWith('d-')) {
        try {
          const result = await apiRequest('/dispatch/update-duty-line', {
            method: 'POST',
            body: {
              duty_line_id: duty.id,
              duty_type: backendTypeMap[value] || value
            }
          });
          
          if (result.error) {
            showToast(result.error, 'error');
            return;
          }
        } catch (err) {
          showToast(err.message || 'Update failed', 'error');
          return;
        }
      }
      
      duty.type = value;
      
      // Re-sync if vehicle assigned
      if (oldVehicle) {
        syncVehicleSchedule(oldVehicle, duty, driver, shift);
      }
      
      renderDetailPanel();
      renderAll();
      showToast(`Type changed to ${DUTY_TYPES[value]?.label || value}`);
    }
    
    async function updateDutyVehicle(driverId, shiftId, dutyIdx, value) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === shiftId);
      if (!shift || !shift.duties[dutyIdx]) return;
      
      const duty = shift.duties[dutyIdx];
      const oldVehicle = duty.vehicle;
      const newVehicle = value || null;
      
      // Check availability
      if (newVehicle && !isVehicleAvailableForDuty(newVehicle, duty.start, duty.end, duty.id)) {
        showToast(`${newVehicle} not available`, 'error');
        renderDetailPanel();
        return;
      }
      
      // Call API in real mode - pass fleet number, backend will resolve to ID
      if (dataSource === 'real' && duty.id && !duty.id.startsWith('placeholder-') && !duty.id.startsWith('d-')) {
        try {
          const result = await apiRequest('/dispatch/update-duty-line', {
            method: 'POST',
            body: {
              duty_line_id: duty.id,
              vehicle_number: newVehicle  // Pass fleet number, backend resolves ID
            }
          });
          
          if (result.error) {
            showToast(result.error, 'error');
            return;
          }
        } catch (err) {
          showToast(err.message || 'Update failed', 'error');
          return;
        }
      }
      
      // Unsync old vehicle
      if (oldVehicle) {
        unsyncVehicleSchedule(oldVehicle, duty.id);
      }
      
      duty.vehicle = newVehicle;
      
      // Sync new vehicle
      if (newVehicle) {
        syncVehicleSchedule(newVehicle, duty, driver, shift);
      }
      
      renderDetailPanel();
      renderAll();
      showToast(newVehicle ? `Vehicle set to ${newVehicle}` : 'Vehicle removed');
    }
    
    function formatDutyHours(hours) {
      const h = Math.floor(hours);
      const m = Math.round((hours - h) * 60);
      if (h === 0) return `${m}m`;
      if (m === 0) return `${h}h`;
      return `${h}h ${m}m`;
    }
    
    async function updateDutyPayType(driverId, shiftId, dutyIdx, payType) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === shiftId);
      if (!shift || !shift.duties[dutyIdx]) return;
      
      const duty = shift.duties[dutyIdx];
      
      // Call API in real mode
      if (dataSource === 'real' && duty.id && !duty.id.startsWith('placeholder-') && !duty.id.startsWith('d-')) {
        try {
          const result = await apiRequest('/dispatch/update-duty-line', {
            method: 'POST',
            body: {
              duty_line_id: duty.id,
              pay_type: payType
            }
          });
          
          if (result.error) {
            showToast(result.error, 'error');
            return;
          }
        } catch (err) {
          showToast(err.message || 'Update failed', 'error');
          return;
        }
      }
      
      duty.payType = payType;
      showToast(`Pay type updated to ${PAY_TYPES[payType]?.label || payType}`);
    }
    
    async function bulkUpdatePayType(driverId, shiftId, payType) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === shiftId);
      if (!shift) return;
      
      // Call API for each duty in real mode
      if (dataSource === 'real') {
        try {
          const promises = shift.duties
            .filter(duty => duty.id && !duty.id.startsWith('placeholder-') && !duty.id.startsWith('d-'))
            .map(duty => apiRequest('/dispatch/update-duty-line', {
              method: 'POST',
              body: {
                duty_line_id: duty.id,
                pay_type: payType
              }
            }));
          
          await Promise.all(promises);
        } catch (err) {
          showToast(err.message || 'Bulk update failed', 'error');
          return;
        }
      }
      
      shift.duties.forEach(duty => {
        duty.payType = payType;
      });
      
      renderDetailPanel();
      showToast(`All duties updated to ${PAY_TYPES[payType]?.label || payType}`);
    }
    
    async function insertDuty(driverId, shiftId, dutyIdx, position) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === shiftId);
      if (!shift) return;
      
      // Helper to check if a time range overlaps with other shifts
      const wouldOverlapOtherShift = (start, end) => {
        return driver.shifts.some(s => {
          if (s.id === shiftId) return false;
          return start < s.end && end > s.start;
        });
      };
      
      const refDuty = shift.duties[dutyIdx];
      let newStart, newEnd;
      let extendedShift = false;
      
      if (position === 'above') {
        // Insert before this duty
        if (dutyIdx === 0) {
          // First duty - check if there's a gap before it
          const gapBefore = refDuty.start - shift.start;
          if (gapBefore >= 0.25) {
            // There's a gap - use it
            newStart = shift.start;
            newEnd = refDuty.start;
          } else {
            // No gap - try to extend shift backwards by 30 min
            const extension = 0.5;
            const newShiftStart = Math.max(5, shift.start - extension);
            
            // Check if extension would overlap with another shift
            if (wouldOverlapOtherShift(newShiftStart, shift.end)) {
              showToast('Cannot extend - would overlap with another shift', 'error');
              return;
            }
            
            if (newShiftStart < shift.start) {
              shift.start = newShiftStart;
              newStart = shift.start;
              newEnd = refDuty.start;
              extendedShift = true;
            } else {
              // Can't extend further (already at 05:00)
              showToast('Cannot extend shift before 05:00', 'error');
              return;
            }
          }
        } else {
          // Between previous duty and this one
          const prevDuty = shift.duties[dutyIdx - 1];
          newStart = prevDuty.end;
          newEnd = refDuty.start;
          
          if (newEnd <= newStart) {
            showToast('No gap between duties', 'error');
            return;
          }
        }
      } else {
        // Insert after this duty
        if (dutyIdx === shift.duties.length - 1) {
          // Last duty - check if there's a gap after it
          const gapAfter = shift.end - refDuty.end;
          if (gapAfter >= 0.25) {
            // There's a gap - use it
            newStart = refDuty.end;
            newEnd = shift.end;
          } else {
            // No gap - try to extend shift forward by 30 min
            const extension = 0.5;
            const newShiftEnd = Math.min(24, shift.end + extension);
            
            // Check if extension would overlap with another shift
            if (wouldOverlapOtherShift(shift.start, newShiftEnd)) {
              showToast('Cannot extend - would overlap with another shift', 'error');
              return;
            }
            
            if (newShiftEnd > shift.end) {
              shift.end = newShiftEnd;
              newStart = refDuty.end;
              newEnd = shift.end;
              extendedShift = true;
            } else {
              // Can't extend further (already at 24:00)
              showToast('Cannot extend shift past 24:00', 'error');
              return;
            }
          }
        } else {
          // Between this duty and next one
          const nextDuty = shift.duties[dutyIdx + 1];
          newStart = refDuty.end;
          newEnd = nextDuty.start;
          
          if (newEnd <= newStart) {
            showToast('No gap between duties', 'error');
            return;
          }
        }
      }
      
      // Create new duty object
      let newDutyId = `d-${Date.now()}`;
      const newDuty = {
        id: newDutyId,
        type: 'oov', // Default to OOV since it doesn't require vehicle
        start: newStart,
        end: newEnd,
        description: 'New duty',
        vehicle: null,
        vehicleId: null,
        payType: 'STD',
        locationName: null,
        locationLat: null,
        locationLng: null
      };
      
      // Call API in real mode if we have an entry ID
      if (dataSource === 'real' && shift.entryId) {
        try {
          const result = await apiRequest('/dispatch/create-duty-line', {
            method: 'POST',
            body: {
              roster_entry_id: shift.entryId,
              start_time: newStart,
              end_time: newEnd,
              duty_type: 'oov',
              description: 'New duty',
              pay_type: 'STD'
            }
          });
          
          if (result.error) {
            showToast(result.error, 'error');
            return;
          }
          
          // Use the real ID from the API
          newDuty.id = result.duty_line_id;
          newDutyId = result.duty_line_id;
        } catch (err) {
          showToast(err.message || 'Failed to create duty', 'error');
          return;
        }
      }
      
      // Insert at correct position
      const insertIdx = position === 'above' ? dutyIdx : dutyIdx + 1;
      shift.duties.splice(insertIdx, 0, newDuty);
      
      // Update driver status if they were available
      if (driver.status === 'available') {
        driver.status = 'working';
      }
      
      if (extendedShift) {
        showToast('Shift extended - duty added');
      } else {
        showToast('Duty added');
      }
      
      renderDetailPanel();
      renderAll();
    }
    
    function calculateShiftTotals(shift) {
      const totals = {
        total: 0,
        byType: {}
      };
      
      // Only count active (non-cancelled) duties
      shift.duties.filter(d => !d.cancelled).forEach(duty => {
        const hours = duty.end - duty.start;
        totals.total += hours;
        
        if (!totals.byType[duty.type]) {
          totals.byType[duty.type] = 0;
        }
        totals.byType[duty.type] += hours;
      });
      
      return totals;
    }
    
    function renderShiftTotals(shift, driverId) {
      const totals = calculateShiftTotals(shift);
      
      // Build breakdown by type
      const breakdownHTML = Object.entries(totals.byType).map(([type, hours]) => {
        const dt = DUTY_TYPES[type] || { label: type };
        return `
          <div class="shift-total-item">
            <div class="shift-total-dot ${type}"></div>
            <span>${dt.label}: ${formatDutyHours(hours)}</span>
          </div>
        `;
      }).join('');
      
      // Pay type bulk assign options
      const payTypeOptions = Object.entries(PAY_TYPES).map(([key, val]) => 
        `<option value="${key}">${val.label}</option>`
      ).join('');
      
      return `
        <div class="shift-totals">
          <div>
            <span class="shift-totals-label">Total Hours:</span>
            <span class="shift-totals-value">${formatDutyHours(totals.total)}</span>
          </div>
          <div class="shift-totals-breakdown">${breakdownHTML}</div>
          <div>
            <select class="duty-pay-select" onchange="if(this.value) bulkUpdatePayType('${driverId}', '${shift.id}', this.value); this.value='';" title="Set all duties to this pay type">
              <option value="">Bulk Pay...</option>
              ${payTypeOptions}
            </select>
          </div>
        </div>
      `;
    }

    function renderEditForm() {
      if (!editingDuty) return '';
      
      // If this is a vehicle-centric edit, use the vehicle edit form
      if (editingDuty.isVehicleCentric) {
        return renderVehicleEditForm();
      }
      
      const duty = editingDuty.duty;
      const shift = editingDuty.shift;
      const isNew = editingDuty.isNew;
      const isAdhoc = editingDuty.isAdhoc;
      const needsVehicle = VEHICLE_REQUIRED_TYPES.includes(duty.type);
      
      // Use allSlots for adhoc, or find slots within shift for existing shifts
      const availableSlots = isNew ? (editingDuty.allSlots || (shift ? findAvailableSlots(shift.duties, shift.start, shift.end) : [])) : [];
      
      const availableVehicles = getAvailableVehiclesForPeriod(duty.start, duty.end);
      
      const currentVehicle = duty.vehicle;
      const vehicleOptions = [...availableVehicles];
      if (currentVehicle && !vehicleOptions.find(v => v.id === currentVehicle)) {
        const existingVehicle = vehicles.find(v => v.id === currentVehicle);
        if (existingVehicle) vehicleOptions.unshift(existingVehicle);
      }
      
      const hasErrors = Object.keys(formErrors).length > 0;
      
      // Check if duty will extend shift bounds
      let shiftExtensionHint = '';
      if (shift && !isAdhoc) {
        const willExtendStart = duty.start < shift.start;
        const willExtendEnd = duty.end > shift.end;
        if (willExtendStart && willExtendEnd) {
          shiftExtensionHint = ` Shift will extend from ${formatTime(shift.start)}-${formatTime(shift.end)} to ${formatTime(duty.start)}-${formatTime(duty.end)}`;
        } else if (willExtendStart) {
          shiftExtensionHint = ` Shift start will extend from ${formatTime(shift.start)} to ${formatTime(duty.start)}`;
        } else if (willExtendEnd) {
          shiftExtensionHint = ` Shift end will extend from ${formatTime(shift.end)} to ${formatTime(duty.end)}`;
        }
      }
      
      return `
        <div class="edit-form">
          <div class="edit-form-title">
            ${isNew ? (isAdhoc ? ' Add Adhoc Duty' : ' Add New Duty') : ' Edit Duty'}
            ${isAdhoc ? '<span style="font-size: 10px; color: var(--accent-amber); margin-left: 8px;">(Creates new shift)</span>' : ''}
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Start Time</label>
              <input type="text" class="form-input ${formErrors.time || formErrors.overlap ? 'error' : ''}" 
                     id="editStart" value="${formatTime(duty.start)}" 
                     placeholder="HH:MM" maxlength="5"
                     oninput="formatTimeInput(this)" onchange="onFormChange()">
            </div>
            <div class="form-group">
              <label class="form-label">End Time</label>
              <input type="text" class="form-input ${formErrors.time || formErrors.overlap ? 'error' : ''}" 
                     id="editEnd" value="${formatTime(duty.end)}" 
                     placeholder="HH:MM" maxlength="5"
                     oninput="formatTimeInput(this)" onchange="onFormChange()">
            </div>
          </div>
          
          ${formErrors.time ? `<div class="form-error"> ${formErrors.time}</div>` : ''}
          ${formErrors.overlap ? `<div class="form-error"> ${formErrors.overlap}</div>` : ''}
          ${shiftExtensionHint ? `<div class="form-hint" style="color: var(--accent-blue);">${shiftExtensionHint}</div>` : ''}
          
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Duty Type</label>
              <select class="form-select" id="editType" onchange="onFormChange()">
                ${Object.entries(DUTY_TYPES).map(([k, v]) => `
                  <option value="${k}" ${duty.type === k ? 'selected' : ''}>${v.label} - ${v.name}</option>
                `).join('')}
              </select>
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Description</label>
              <input type="text" class="form-input" id="editDesc" value="${duty.description}" placeholder="Enter description...">
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Location <span style="font-size: 10px; color: var(--text-muted);">(optional - for smart assignment)</span></label>
              <div class="location-input-wrapper">
                <input type="text" class="form-input" id="editLocation" 
                       value="${duty.locationName || ''}" 
                       placeholder="Start typing to search or enter free text..."
                       oninput="onLocationInput('editLocation')"
                       onfocus="onLocationInput('editLocation')">
                <input type="hidden" id="editLocationLat" value="${duty.locationLat || ''}">
                <input type="hidden" id="editLocationLng" value="${duty.locationLng || ''}">
              </div>
              ${duty.locationLat && duty.locationLng ? 
                `<div class="location-coords"> ${Number(duty.locationLat).toFixed(4)}, ${Number(duty.locationLng).toFixed(4)}</div>` : 
                ''}
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">
                Vehicle ${needsVehicle ? '<span class="required">*</span>' : ''}
              </label>
              <select class="form-select ${formErrors.vehicle ? 'error' : ''}" id="editVehicle" onchange="onFormChange()">
                <option value="">-- No Vehicle --</option>
                ${vehicleOptions.map(v => `
                  <option value="${v.id}" ${duty.vehicle === v.id ? 'selected' : ''}>${v.id} (${v.capacity} seats)</option>
                `).join('')}
              </select>
              ${vehicleOptions.length === 0 && needsVehicle ? 
                `<div class="form-hint">No vehicles available for this time period</div>` : 
                `<div class="form-hint">${vehicleOptions.length} vehicle(s) available for ${formatTime(duty.start)}-${formatTime(duty.end)}</div>`
              }
            </div>
          </div>
          
          ${formErrors.vehicle ? `<div class="form-error"> ${formErrors.vehicle}</div>` : ''}
          
          ${isNew && availableSlots.length > 0 ? `
            <div class="available-slots">
              <div class="available-slots-label"> Available time slots:</div>
              <div class="slot-chips">
                ${availableSlots.map(s => `
                  <span class="slot-chip" onclick="fillSlot(${s.start}, ${s.end})">${formatTime(s.start)} - ${formatTime(s.end)}</span>
                `).join('')}
              </div>
            </div>
          ` : ''}
          
          <div class="form-actions">
            <button class="form-btn cancel" onclick="cancelEdit()">Cancel</button>
            <button class="form-btn save" id="saveBtn" onclick="saveEdit()" ${hasErrors ? 'disabled' : ''}>
              ${isNew ? (isAdhoc ? 'Create Adhoc' : 'Add Duty') : 'Save Changes'}
            </button>
          </div>
        </div>
      `;
    }

    function renderVehicleDetail(vehicle) {
      if (allocationMode === 'vehicle') {
        return renderVehicleDetailVehicleCentric(vehicle);
      }
      return renderVehicleDetailDriverCentric(vehicle);
    }
    
    function renderVehicleDetailDriverCentric(vehicle) {
      let blocksHTML = '';
      if (vehicle.status === 'maintenance') {
        blocksHTML = `<div class="info-row"><span class="info-value" style="color: var(--accent-amber)">In Maintenance</span></div>`;
      } else if (!vehicle.shifts || vehicle.shifts.length === 0 || vehicle.shifts.every(s => s.type === 'maintenance')) {
        blocksHTML = `<div class="info-row"><span class="info-value" style="color: var(--accent-green)">Available All Day</span></div>`;
      } else {
        // Display synced shifts from driver assignments
        const workShifts = vehicle.shifts.filter(s => s.type !== 'maintenance');
        
        blocksHTML = `<div class="duty-list">
          ${workShifts.map(shift => {
            // Find the driver index for navigation
            const driverIdx = shift.syncedDriverId 
              ? drivers.findIndex(d => d.id === shift.syncedDriverId)
              : -1;
            const driver = driverIdx >= 0 ? drivers[driverIdx] : null;
            const driverName = driver?.name || shift.duties[0]?.driver || 'Unknown';
            const shiftName = shift.name || 'Assignment';
            const isClickable = driverIdx >= 0;
            const shiftTypeIcon = shift.shiftType === 'charter' ? '' : '';
            
            // Calculate total hours for this shift
            const totalHours = shift.duties.reduce((sum, d) => sum + (d.end - d.start), 0);
            
            return `
              <div class="vehicle-schedule-item ${isClickable ? 'clickable' : ''}" ${isClickable ? `onclick="navigateToResource('driver', ${driverIdx})"` : ''}>
                <div class="vehicle-schedule-header">
                  <span class="vehicle-schedule-time">${formatTime(shift.start)}-${formatTime(shift.end)}</span>
                  <span class="vehicle-schedule-badge ${shift.shiftType || 'shift'}">${shiftTypeIcon} ${shiftName}</span>
                </div>
                <div class="vehicle-schedule-driver">
                  
                  <span class="driver-name">${driverName}</span>
                  ${isClickable ? '<span class="nav-arrow"></span>' : ''}
                </div>
                <div class="vehicle-schedule-details">
                  <span class="detail-item">${shift.duties.length} ${shift.duties.length === 1 ? 'duty' : 'duties'}</span>
                  <span class="detail-item">${formatDutyHours(totalHours)}</span>
                </div>
              </div>
            `;
          }).join('')}
        </div>`;
      }
      
      // Calculate utilization
      const workShifts = vehicle.shifts?.filter(s => s.type !== 'maintenance') || [];
      const totalHours = workShifts.reduce((sum, s) => 
        sum + s.duties.reduce((dSum, d) => dSum + (d.end - d.start), 0), 0);
      const hasClickableShifts = workShifts.some(s => s.syncedDriverId && drivers.findIndex(d => d.id === s.syncedDriverId) >= 0);
      
      return `
        <div class="panel-header">
          <div class="panel-header-info">
            <div class="panel-title">${vehicle.id}</div>
            <div class="panel-subtitle">${vehicle.capacity} seats  ${vehicle.rego}</div>
          </div>
        </div>
        <div class="panel-content">
          <div class="panel-section">
            <div class="info-row"><span class="info-label">Rego</span><span class="info-value">${vehicle.rego}</span></div>
            <div class="info-row"><span class="info-label">Capacity</span><span class="info-value">${vehicle.capacity} seats</span></div>
            <div class="info-row">
              <span class="info-label">Status</span>
              <span class="info-value" style="color: ${vehicle.status === 'maintenance' ? 'var(--accent-amber)' : vehicle.status === 'available' ? 'var(--accent-green)' : 'var(--accent-blue)'}">
                ${vehicle.status === 'maintenance' ? 'Maintenance' : vehicle.status === 'available' ? 'Available' : 'In Use'}
              </span>
            </div>
            ${totalHours > 0 ? `<div class="info-row"><span class="info-label">Today's Hours</span><span class="info-value">${formatDutyHours(totalHours)}</span></div>` : ''}
          </div>
          <div class="panel-section">
            <div class="panel-section-title">Today's Schedule</div>
            ${hasClickableShifts ? '<div class="panel-section-hint">Click a shift to view driver</div>' : ''}
            ${blocksHTML}
          </div>
        </div>
      `;
    }
    
    function renderVehicleDetailVehicleCentric(vehicle) {
      let scheduleHTML = '';
      
      // Check if we're in transfer mode for vehicles
      let transferPanelHTML = '';
      if (transferringShift && transferringShift.type === 'vehicle') {
        const shift = transferringShift.shift;
        
        transferPanelHTML = `
          <div class="panel-section" style="background: rgba(59, 130, 246, 0.1); border: 1px solid var(--accent-blue); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
            <div class="panel-section-title" style="color: var(--accent-blue);">Transfer: ${shift.name}</div>
            <div class="info-row"><span class="info-label">Time</span><span class="info-value">${formatTime(shift.start)} - ${formatTime(shift.end)}</span></div>
            <div class="assignment-panel">
              <div class="assignment-search">
                <input type="text" class="assignment-search-input" id="transferVehicleSearch" 
                       placeholder="Search vehicles..." oninput="updateTransferVehicleList()">
              </div>
              <div class="assignment-count" id="transferVehicleCount"></div>
              <div class="assignment-list" id="transferVehicleList"></div>
            </div>
            <button class="transfer-cancel-btn" onclick="cancelTransfer()">Cancel Transfer</button>
          </div>
        `;
      }
      
      // Check for smart suggestions
      const vehicleIndex = vehicles.indexOf(vehicle);
      const endingInfo = getVehicleEndingInfo(vehicle);
      const suggestionPanelHTML = renderSuggestionPanel(endingInfo, 'vehicle', vehicleIndex);
      
      if (vehicle.status === 'maintenance') {
        scheduleHTML = `<div class="info-row"><span class="info-value" style="color: var(--accent-amber)">In Maintenance</span></div>`;
      } else if (!vehicle.shifts || vehicle.shifts.length === 0) {
        scheduleHTML = `<div class="info-row"><span class="info-value" style="color: var(--accent-green)">Available All Day</span></div>`;
      } else {
        scheduleHTML = vehicle.shifts.filter(s => s.type !== 'maintenance').map((shift, shiftIdx) => {
          const driverStatus = getShiftDriverStatus(shift);
          const actualIdx = vehicle.shifts.indexOf(shift);
          return `
            <div class="shift-block">
              <div class="shift-block-header">
                <div class="shift-block-title">${shift.name}</div>
                <div class="shift-block-meta">
                  <span class="shift-vehicle-status ${driverStatus.status}">${driverStatus.label}</span>
                  <span class="shift-block-time">${formatTime(shift.start)}-${formatTime(shift.end)}</span>
                </div>
              </div>
              <div class="shift-block-actions">
                ${driverStatus.status !== 'complete' ? `<button class="shift-action-btn primary" onclick="showBulkAssignDriver('${vehicle.id}', '${shift.id}')" title="Assign driver to all unassigned duties">Assign All</button>` : ''}
                <button class="shift-action-btn" onclick="showTransferVehicleShift('${vehicle.id}', ${actualIdx})" title="Transfer to another vehicle">Transfer</button>
                <button class="shift-action-btn danger" onclick="unassignVehicleShift('${vehicle.id}', ${actualIdx})" title="Remove and move to unassigned">Unassign</button>
              </div>
              ${bulkAssigning && bulkAssigning.type === 'driver' && bulkAssigning.vehicleId === vehicle.id && bulkAssigning.shiftId === shift.id ? renderBulkAssignDriverPanel() : ''}
              <div class="shift-block-content">
                <div class="duty-list-header">
                  <span class="duty-header-time">Start</span>
                  <span class="duty-header-sep"></span>
                  <span class="duty-header-time">End</span>
                  <span class="duty-header-type">Type</span>
                  <span class="duty-header-desc">Desc</span>
                  <span class="duty-header-vehicle">Driver</span>
                  <span class="duty-header-pay">Pay</span>
                  <span class="duty-header-hours">Hours</span>
                  <span class="duty-header-actions"></span>
                </div>
                <div class="duty-list">
                  ${shift.duties.map((duty, idx) => renderVehicleDutyItem(duty, vehicle.id, shift.id, idx)).join('')}
                </div>
                ${renderVehicleShiftTotals(shift, vehicle.id)}
              </div>
            </div>
          `;
        }).join('');
      }
      
      return `
        <div class="panel-header">
          <div class="panel-header-info">
            <div class="panel-title">${vehicle.id}</div>
            <div class="panel-subtitle">${vehicle.capacity} seats</div>
          </div>
        </div>
        <div class="panel-content">
          <div class="panel-section">
            <div class="info-row"><span class="info-label">Rego</span><span class="info-value">${vehicle.rego}</span></div>
            <div class="info-row">
              <span class="info-label">Status</span>
              <span class="info-value" style="color: ${vehicle.status === 'maintenance' ? 'var(--accent-amber)' : vehicle.status === 'available' ? 'var(--accent-green)' : 'var(--accent-blue)'}">
                ${vehicle.status === 'maintenance' ? 'Maintenance' : vehicle.status === 'available' ? 'Available' : 'In Use'}
              </span>
            </div>
          </div>
          ${transferPanelHTML}
          <div class="panel-section">
            <div class="panel-section-header">
              <span class="panel-section-title">Today's Schedule</span>
              ${vehicle.status !== 'maintenance' ? `<button class="panel-section-action" onclick="showAddVehicleDutyForm('${vehicle.id}')">+ Add Duty</button>` : ''}
            </div>
            ${editingDuty ? renderVehicleEditForm() : ''}
            ${scheduleHTML}
          </div>
          ${suggestionPanelHTML}
        </div>
      `;
    }
    
    function getShiftDriverStatus(shift) {
      const drivingDuties = shift.duties.filter(d => DRIVER_REQUIRED_TYPES.includes(d.type));
      if (drivingDuties.length === 0) return { status: 'complete', label: 'N/A' };
      
      const withDriver = drivingDuties.filter(d => d.driver || d.driverId);
      if (withDriver.length === drivingDuties.length) return { status: 'complete', label: 'All assigned' };
      if (withDriver.length === 0) return { status: 'none', label: 'No drivers' };
      return { status: 'partial', label: `${withDriver.length}/${drivingDuties.length} assigned` };
    }
    
    function renderVehicleDutyItem(duty, vehicleId, shiftId, dutyIdx) {
      const dt = DUTY_TYPES[duty.type] || DUTY_TYPES.driving;
      const needsDriver = DRIVER_REQUIRED_TYPES.includes(duty.type);
      const hasDriver = duty.driver || duty.driverId;
      
      // Calculate hours for this duty
      const hours = duty.end - duty.start;
      const hoursStr = formatDutyHours(hours);
      
      // Get pay type (default to standard if not set)
      const payType = duty.payType || 'standard';
      
      // Get available drivers for this duty's time slot
      const availableDrivers = drivers.filter(d => 
        d.status !== 'leave' && 
        isDriverAvailableForDuty(d.id, duty.start, duty.end, duty.id)
      );
      
      // Find current driver ID (could be in driverId or we need to look up from driver name)
      let currentDriverId = duty.driverId;
      if (!currentDriverId && duty.driver) {
        const driverObj = drivers.find(d => d.name === duty.driver);
        currentDriverId = driverObj ? driverObj.id : null;
      }
      
      // Driver dropdown options
      const driverOptions = `
        <option value="">--</option>
        ${availableDrivers.map(d => `
          <option value="${d.id}" ${currentDriverId === d.id ? 'selected' : ''}>${d.name}</option>
        `).join('')}
        ${currentDriverId && !availableDrivers.find(d => d.id === currentDriverId) ? 
          `<option value="${currentDriverId}" selected>${duty.driver || currentDriverId}</option>` : ''}
      `;
      
      // Duty type options (compact)
      const typeOptions = Object.entries(DUTY_TYPES).map(([key, val]) => 
        `<option value="${key}" ${duty.type === key ? 'selected' : ''}>${val.label}</option>`
      ).join('');
      
      // Pay type options
      const payTypeOptions = Object.entries(PAY_TYPES).map(([key, val]) => 
        `<option value="${key}" ${payType === key ? 'selected' : ''}>${val.code}</option>`
      ).join('');
      
      return `
        <div class="duty-item-inline">
          <div class="duty-insert-arrows">
            <button class="duty-insert-btn" onclick="event.stopPropagation(); insertVehicleDuty('${vehicleId}', '${shiftId}', ${dutyIdx}, 'above')" title="Insert duty above">+</button>
            <button class="duty-insert-btn" onclick="event.stopPropagation(); insertVehicleDuty('${vehicleId}', '${shiftId}', ${dutyIdx}, 'below')" title="Insert duty below">+</button>
          </div>
          <div class="duty-type-bar ${duty.type}"></div>
          <div class="duty-inline-content">
            <input type="text" class="duty-inline-time" value="${formatTimeCompact(duty.start)}" 
                   onchange="updateVehicleDutyTime('${vehicleId}', '${shiftId}', ${dutyIdx}, 'start', this.value)"
                   title="Start time">
            <span class="duty-time-sep">-</span>
            <input type="text" class="duty-inline-time" value="${formatTimeCompact(duty.end)}" 
                   onchange="updateVehicleDutyTime('${vehicleId}', '${shiftId}', ${dutyIdx}, 'end', this.value)"
                   title="End time">
            <select class="duty-inline-select type" onchange="updateVehicleDutyType('${vehicleId}', '${shiftId}', ${dutyIdx}, this.value)" title="Duty type">
              ${typeOptions}
            </select>
            <input type="text" class="duty-inline-desc" value="${duty.description}" 
                   onchange="updateVehicleDutyDesc('${vehicleId}', '${shiftId}', ${dutyIdx}, this.value)"
                   placeholder="Description..." title="Description">
            <select class="duty-inline-select vehicle ${!hasDriver && needsDriver ? 'missing' : ''}" 
                    onchange="updateVehicleDutyDriver('${vehicleId}', '${shiftId}', ${dutyIdx}, this.value)" title="Driver">
              ${driverOptions}
            </select>
            <select class="duty-inline-select pay" onchange="updateVehicleDutyPayType('${vehicleId}', '${shiftId}', ${dutyIdx}, this.value)" title="Pay type">
              ${payTypeOptions}
            </select>
            <span class="duty-inline-hours">${hoursStr}</span>
            <button class="duty-delete-btn" onclick="deleteVehicleDuty('${vehicleId}', '${shiftId}', ${dutyIdx})" title="Delete duty"></button>
          </div>
        </div>
      `;
    }
    
    // Check if a driver is available for a given time slot
    function isDriverAvailableForDuty(driverId, start, end, excludeDutyId = null) {
      if (!driverId) return true;
      
      const driver = drivers.find(d => d.id === driverId);
      if (!driver || driver.status === 'leave') return false;
      
      // Check all driver shifts for conflicts
      for (const shift of driver.shifts || []) {
        for (const duty of shift.duties || []) {
          if (excludeDutyId && duty.id === excludeDutyId) continue;
          if (duty.cancelled) continue; // Skip cancelled duties
          // Check for overlap
          if (start < duty.end && end > duty.start) {
            return false;
          }
        }
      }
      return true;
    }
    
    function updateVehicleDutyTime(vehicleId, shiftId, dutyIdx, field, value) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      if (!vehicle) return;
      
      const shift = vehicle.shifts.find(s => s.id === shiftId);
      if (!shift || !shift.duties[dutyIdx]) return;
      
      const duty = shift.duties[dutyIdx];
      const newTime = parseTime(value);
      
      if (isNaN(newTime)) {
        showToast('Invalid time format', 'error');
        renderDetailPanel();
        return;
      }
      
      const newStart = field === 'start' ? newTime : duty.start;
      const newEnd = field === 'end' ? newTime : duty.end;
      
      if (newStart >= newEnd) {
        showToast('End must be after start', 'error');
        renderDetailPanel();
        return;
      }
      
      // Check for overlaps with other duties
      const overlap = shift.duties.find((d, i) => {
        if (i === dutyIdx) return false;
        return newStart < d.end && newEnd > d.start;
      });
      
      if (overlap) {
        showToast(`Overlaps with ${formatTime(overlap.start)}-${formatTime(overlap.end)}`, 'error');
        renderDetailPanel();
        return;
      }
      
      duty[field] = newTime;
      
      // Update shift bounds if needed
      updateShiftBounds(shift);
      
      renderDetailPanel();
      renderAll();
    }
    
    function updateVehicleDutyDesc(vehicleId, shiftId, dutyIdx, value) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      if (!vehicle) return;
      
      const shift = vehicle.shifts.find(s => s.id === shiftId);
      if (!shift || !shift.duties[dutyIdx]) return;
      
      shift.duties[dutyIdx].description = value;
    }
    
    function updateVehicleDutyType(vehicleId, shiftId, dutyIdx, value) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      if (!vehicle) return;
      
      const shift = vehicle.shifts.find(s => s.id === shiftId);
      if (!shift || !shift.duties[dutyIdx]) return;
      
      shift.duties[dutyIdx].type = value;
      
      renderDetailPanel();
      renderAll();
      showToast(`Type changed to ${DUTY_TYPES[value]?.label || value}`);
    }
    
    function updateVehicleDutyDriver(vehicleId, shiftId, dutyIdx, driverId) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      if (!vehicle) return;
      
      const shift = vehicle.shifts.find(s => s.id === shiftId);
      if (!shift || !shift.duties[dutyIdx]) return;
      
      const duty = shift.duties[dutyIdx];
      
      // Check availability
      if (driverId && !isDriverAvailableForDuty(driverId, duty.start, duty.end, duty.id)) {
        showToast('Driver not available', 'error');
        renderDetailPanel();
        return;
      }
      
      if (driverId) {
        const driver = drivers.find(d => d.id === driverId);
        duty.driverId = driverId;
        duty.driver = driver?.name || driverId;
      } else {
        duty.driverId = null;
        duty.driver = null;
      }
      
      renderDetailPanel();
      renderAll();
      showToast(driverId ? `Driver set to ${duty.driver}` : 'Driver removed');
    }
    
    function updateVehicleDutyPayType(vehicleId, shiftId, dutyIdx, payType) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      if (!vehicle) return;
      
      const shift = vehicle.shifts.find(s => s.id === shiftId);
      if (!shift || !shift.duties[dutyIdx]) return;
      
      shift.duties[dutyIdx].payType = payType;
      showToast(`Pay type updated to ${PAY_TYPES[payType].label}`);
    }
    
    function bulkUpdateVehiclePayType(vehicleId, shiftId, payType) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      if (!vehicle) return;
      
      const shift = vehicle.shifts.find(s => s.id === shiftId);
      if (!shift) return;
      
      shift.duties.forEach(duty => {
        duty.payType = payType;
      });
      
      renderDetailPanel();
      showToast(`All duties updated to ${PAY_TYPES[payType].label}`);
    }
    
    function insertVehicleDuty(vehicleId, shiftId, dutyIdx, position) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      if (!vehicle) return;
      
      const shift = vehicle.shifts.find(s => s.id === shiftId);
      if (!shift) return;
      
      const refDuty = shift.duties[dutyIdx];
      let newStart, newEnd;
      let extendedShift = false;
      
      if (position === 'above') {
        // Insert before this duty
        if (dutyIdx === 0) {
          // First duty - check if there's a gap before it
          const gapBefore = refDuty.start - shift.start;
          if (gapBefore >= 0.25) {
            // There's a gap - use it
            newStart = shift.start;
            newEnd = refDuty.start;
          } else {
            // No gap - extend shift backwards by 30 min
            const extension = 0.5;
            const newShiftStart = Math.max(5, shift.start - extension);
            if (newShiftStart < shift.start) {
              shift.start = newShiftStart;
              newStart = shift.start;
              newEnd = refDuty.start;
              extendedShift = true;
            } else {
              // Can't extend further (already at 05:00)
              showToast('Cannot extend shift before 05:00', true);
              return;
            }
          }
        } else {
          // Between previous duty and this one
          const prevDuty = shift.duties[dutyIdx - 1];
          newStart = prevDuty.end;
          newEnd = refDuty.start;
          
          if (newEnd <= newStart) {
            showToast('No gap between duties', true);
            return;
          }
        }
      } else {
        // Insert after this duty
        if (dutyIdx === shift.duties.length - 1) {
          // Last duty - check if there's a gap after it
          const gapAfter = shift.end - refDuty.end;
          if (gapAfter >= 0.25) {
            // There's a gap - use it
            newStart = refDuty.end;
            newEnd = shift.end;
          } else {
            // No gap - extend shift forward by 30 min
            const extension = 0.5;
            const newShiftEnd = Math.min(24, shift.end + extension);
            if (newShiftEnd > shift.end) {
              shift.end = newShiftEnd;
              newStart = refDuty.end;
              newEnd = shift.end;
              extendedShift = true;
            } else {
              // Can't extend further (already at 24:00)
              showToast('Cannot extend shift past 24:00', true);
              return;
            }
          }
        } else {
          // Between this duty and next one
          const nextDuty = shift.duties[dutyIdx + 1];
          newStart = refDuty.end;
          newEnd = nextDuty.start;
          
          if (newEnd <= newStart) {
            showToast('No gap between duties', true);
            return;
          }
        }
      }
      
      // Create and insert new duty directly
      const newDuty = {
        id: `d-${Date.now()}`,
        type: 'oov', // Default to OOV since it doesn't require driver
        start: newStart,
        end: newEnd,
        description: 'New duty',
        driver: null,
        driverId: null,
        payType: 'standard'
      };
      
      // Insert at correct position
      const insertIdx = position === 'above' ? dutyIdx : dutyIdx + 1;
      shift.duties.splice(insertIdx, 0, newDuty);
      
      // Update vehicle status if needed
      if (vehicle.status === 'available') {
        vehicle.status = 'inuse';
      }
      
      if (extendedShift) {
        showToast('Shift extended - duty added');
      } else {
        showToast('Duty added');
      }
      
      renderDetailPanel();
      renderAll();
    }
    
    function renderVehicleShiftTotals(shift, vehicleId) {
      const totals = calculateShiftTotals(shift);
      
      const breakdownHTML = Object.entries(totals.byType).map(([type, hours]) => {
        const dt = DUTY_TYPES[type] || { label: type };
        return `
          <div class="shift-total-item">
            <div class="shift-total-dot ${type}"></div>
            <span>${dt.label}: ${formatDutyHours(hours)}</span>
          </div>
        `;
      }).join('');
      
      const payTypeOptions = Object.entries(PAY_TYPES).map(([key, val]) => 
        `<option value="${key}">${val.label}</option>`
      ).join('');
      
      return `
        <div class="shift-totals">
          <div>
            <span class="shift-totals-label">Total Hours:</span>
            <span class="shift-totals-value">${formatDutyHours(totals.total)}</span>
          </div>
          <div class="shift-totals-breakdown">${breakdownHTML}</div>
          <div>
            <select class="duty-pay-select" onchange="if(this.value) bulkUpdateVehiclePayType('${vehicleId}', '${shift.id}', this.value); this.value='';" title="Set all duties to this pay type">
              <option value="">Bulk Pay...</option>
              ${payTypeOptions}
            </select>
          </div>
        </div>
      `;
    }

    function renderJobDetail(job) {
      if (!job) return `<div class="empty-panel"><div class="empty-icon"></div><div class="empty-text">Select a job to view details</div></div>`;
      if (allocationMode === 'vehicle') {
        return renderJobDetailVehicleCentric(job);
      }
      return renderJobDetailDriverCentric(job);
    }
    
    function renderJobDetailDriverCentric(job) {
      if (!job) return `<div class="empty-panel"><div class="empty-icon"></div><div class="empty-text">Job not found</div></div>`;
      
      // Calculate total job hours
      let totalHours = 0;
      const duties = job.duties || [];
      if (duties.length > 0) {
        totalHours = duties.reduce((sum, duty) => sum + (duty.end - duty.start), 0);
      } else {
        totalHours = (job.end || 18) - (job.start || 6);
      }
      
      // Render job duties
      const dutiesHTML = duties.length > 0 ? `
        <div class="duty-list">
          ${duties.map(duty => {
            const dt = DUTY_TYPES[duty.type] || DUTY_TYPES.driving;
            const hours = duty.end - duty.start;
            return `
              <div class="duty-item">
                <div class="duty-type-bar ${duty.type}"></div>
                <div class="duty-content">
                  <div class="duty-row-main">
                    <span class="duty-time">${formatTime(duty.start)}-${formatTime(duty.end)}</span>
                    <span class="duty-desc">${duty.description}</span>
                    <span class="duty-badge ${duty.type}">${dt.label}</span>
                  </div>
                  <div class="duty-row-meta">
                    <span class="duty-hours">${formatDutyHours(hours)}</span>
                  </div>
                </div>
              </div>
            `;
          }).join('')}
        </div>
        <div class="shift-totals" style="margin-top: 8px;">
          <div>
            <span class="shift-totals-label">Total Hours:</span>
            <span class="shift-totals-value">${formatDutyHours(totalHours)}</span>
          </div>
        </div>
      ` : '<div class="info-row"><span class="info-value" style="color: var(--text-muted)">No duties defined</span></div>';
      
      // Location info for charters
      const locationHTML = job.type === 'charter' && job.pickupLocation ? `
        <div class="panel-section" style="background: rgba(59, 130, 246, 0.05); border-radius: 6px; padding: 10px;">
          <div class="info-row"><span class="info-label"> Pickup</span><span class="info-value">${job.pickupLocation.name}</span></div>
          <div class="info-row"><span class="info-label"> Dropoff</span><span class="info-value">${job.dropoffLocation?.name || 'TBC'}</span></div>
          ${job.pickupLocation && job.dropoffLocation ? `
            <div class="info-row">
              <span class="info-label"> Distance</span>
              <span class="info-value">${formatDistance(calculateDistance(job.pickupLocation, job.dropoffLocation))}</span>
            </div>
            <div class="info-row">
              <span class="info-label"> Est. Travel</span>
              <span class="info-value">${formatTravelTime(estimateTravelTime(job.pickupLocation, job.dropoffLocation))}</span>
            </div>
          ` : ''}
        </div>
      ` : '';
      
      return `
        <div class="panel-header">
          <div class="panel-header-info">
            <div class="panel-title">${job.name}</div>
            <div class="panel-subtitle">${job.id}</div>
          </div>
        </div>
        <div class="panel-content">
          <div class="panel-section">
            <div class="info-row"><span class="info-label">Time</span><span class="info-value">${formatTime(job.start)} - ${formatTime(job.end)}</span></div>
            <div class="info-row"><span class="info-label">Type</span><span class="info-value">${job.type === 'charter' ? 'Charter' : 'Shift'}</span></div>
            ${job.customer ? `<div class="info-row"><span class="info-label">Customer</span><span class="info-value">${job.customer}</span></div>` : ''}
          </div>
          ${locationHTML}
          <div class="panel-section">
            <div class="panel-section-title">Job Breakdown</div>
            ${dutiesHTML}
          </div>
          <div class="panel-section">
            <div class="panel-section-title">Assign Driver</div>
            <div class="assignment-panel">
              <div class="assignment-search">
                <input type="text" class="assignment-search-input" id="assignDriverSearch" 
                       placeholder="Search by name..." oninput="updateDriverAssignmentList(${unassignedJobs.indexOf(job)})">
              </div>
              <div class="assignment-filters">
                <select class="filter-select" id="assignDriverFilter" onchange="updateDriverAssignmentList(${unassignedJobs.indexOf(job)})">
                  <option value="no-duties">No duties</option>
                  <option value="has-duties">Has duties</option>
                  <option value="not-available">Not available</option>
                  <option value="all">All drivers</option>
                </select>
                <select class="filter-select" id="assignDriverSort" onchange="updateDriverAssignmentList(${unassignedJobs.indexOf(job)})">
                  <option value="surname">Surname</option>
                  <option value="firstname">First name</option>
                  <option value="hours-asc">Hours (lowhigh)</option>
                  <option value="hours-desc">Hours (highlow)</option>
                  <option value="shifts">Fewest shifts</option>
                </select>
              </div>
              <div class="assignment-count" id="driverAssignmentCount"></div>
              <div class="assignment-list" id="driverAssignmentList"></div>
            </div>
          </div>
        </div>
      `;
    }
    
    function updateDriverAssignmentList(jobIndex) {
      const job = unassignedJobs[jobIndex];
      if (!job) return;
      
      const search = document.getElementById('assignDriverSearch')?.value?.toLowerCase() || '';
      const filter = document.getElementById('assignDriverFilter')?.value || 'no-duties';
      const sort = document.getElementById('assignDriverSort')?.value || 'surname';
      
      // Get all non-leave drivers first
      let filteredDrivers = drivers.filter(d => d.status !== 'leave');
      
      // Helper to check if driver is available for the job time
      const isAvailableForJob = (driver) => {
        const jobStartMins = toMinutes(job.start);
        const jobEndMins = toMinutes(job.end);
        
        for (const shift of driver.shifts) {
          for (const duty of shift.duties) {
            if (duty.cancelled) continue; // Skip cancelled duties
            const dStartMins = toMinutes(duty.start);
            const dEndMins = toMinutes(duty.end);
            if (jobStartMins < dEndMins && jobEndMins > dStartMins) {
              return false; // Overlap found
            }
          }
        }
        return true;
      };
      
      // Helper to get total hours for a driver (excluding cancelled)
      const getTotalHours = (driver) => {
        return driver.shifts.reduce((total, shift) => {
          return total + shift.duties.filter(d => !d.cancelled).reduce((sum, duty) => sum + (duty.end - duty.start), 0);
        }, 0);
      };
      
      // Helper to check if driver has active duties
      const hasActiveDuties = (driver) => {
        return driver.shifts.some(s => s.duties.some(d => !d.cancelled));
      };
      
      // Apply availability filter
      if (filter === 'no-duties') {
        filteredDrivers = filteredDrivers.filter(d => !hasActiveDuties(d));
      } else if (filter === 'has-duties') {
        filteredDrivers = filteredDrivers.filter(d => {
          return hasActiveDuties(d) && isAvailableForJob(d);
        });
      } else if (filter === 'not-available') {
        filteredDrivers = filteredDrivers.filter(d => !isAvailableForJob(d));
      }
      // 'all' shows everyone except leave
      
      // Apply search
      if (search) {
        filteredDrivers = filteredDrivers.filter(d => 
          d.name.toLowerCase().includes(search) || 
          d.fullName.toLowerCase().includes(search) ||
          d.id.toLowerCase().includes(search)
        );
      }
      
      // Apply sorting
      filteredDrivers.sort((a, b) => {
        switch (sort) {
          case 'surname':
            const surnameA = a.fullName.split(' ').pop().toLowerCase();
            const surnameB = b.fullName.split(' ').pop().toLowerCase();
            return surnameA.localeCompare(surnameB);
          case 'firstname':
            const firstA = a.fullName.split(' ')[0].toLowerCase();
            const firstB = b.fullName.split(' ')[0].toLowerCase();
            return firstA.localeCompare(firstB);
          case 'hours-asc':
            return getTotalHours(a) - getTotalHours(b);
          case 'hours-desc':
            return getTotalHours(b) - getTotalHours(a);
          case 'shifts':
            return a.shifts.length - b.shifts.length;
          default:
            return 0;
        }
      });
      
      // Update count with filter context
      const countEl = document.getElementById('driverAssignmentCount');
      if (countEl) {
        const filterLabels = {
          'no-duties': 'with no duties',
          'has-duties': 'with duties (available)',
          'not-available': 'not available',
          'all': 'total'
        };
        countEl.textContent = `${filteredDrivers.length} driver(s) ${filterLabels[filter]}`;
      }
      
      // Render list
      const listEl = document.getElementById('driverAssignmentList');
      if (listEl) {
        if (filteredDrivers.length === 0) {
          listEl.innerHTML = '<div class="assignment-empty">No matching drivers</div>';
        } else {
          listEl.innerHTML = filteredDrivers.map(d => {
            const driverIdx = drivers.indexOf(d);
            const totalHours = getTotalHours(d);
            const available = isAvailableForJob(d);
            const shiftCount = d.shifts.filter(s => s.duties.some(duty => !duty.cancelled)).length;
            
            // Build detail text
            let detailText = '';
            if (shiftCount === 0) {
              detailText = 'No duties';
            } else {
              detailText = `${shiftCount} shift(s)  ${formatDutyHours(totalHours)}`;
            }
            
            return `
            <div class="assignment-item ${!available ? 'unavailable' : ''}">
              <div class="assignment-item-info">
                <span class="assignment-item-name clickable" onclick="navigateToResource('driver', ${driverIdx})">${d.fullName}</span>
                <span class="assignment-item-detail">${detailText}</span>
              </div>
              <span class="assignment-item-status ${available ? (shiftCount > 0 ? 'working' : 'available') : 'unavailable'}">${available ? (shiftCount > 0 ? 'Working' : 'Available') : 'Busy'}</span>
              ${available ? `<button class="assign-btn" onclick="assignDriverToJob(${jobIndex}, ${driverIdx})">Assign</button>` : ''}
            </div>
          `}).join('');
        }
      }
    }
    
    // Get the ending location and time of a driver's last charter/shift
    function getDriverEndingInfo(driver) {
      if (!driver.shifts || driver.shifts.length === 0) return null;
      
      // Get the last shift
      const sortedShifts = [...driver.shifts].sort((a, b) => b.end - a.end);
      const lastShift = sortedShifts[0];
      
      if (lastShift.type !== 'charter') return null;
      
      // Find the last location from duties
      const lastDuty = [...lastShift.duties].reverse().find(d => d.toLocationId || d.locationId);
      if (!lastDuty) return null;
      
      const locationId = lastDuty.toLocationId || lastDuty.locationId;
      const location = LOCATIONS.find(l => l.id === locationId);
      
      return {
        location,
        endTime: lastShift.end,
        shift: lastShift
      };
    }
    
    // Get the ending location and time of a vehicle's last charter/shift
    function getVehicleEndingInfo(vehicle) {
      if (!vehicle.shifts || vehicle.shifts.length === 0) return null;
      
      // Get non-maintenance shifts
      const workShifts = vehicle.shifts.filter(s => s.type !== 'maintenance');
      if (workShifts.length === 0) return null;
      
      // Get the last shift
      const sortedShifts = [...workShifts].sort((a, b) => b.end - a.end);
      const lastShift = sortedShifts[0];
      
      if (lastShift.type !== 'charter') return null;
      
      // Find the last location from duties
      const lastDuty = [...lastShift.duties].reverse().find(d => d.toLocationId || d.locationId);
      if (!lastDuty) return null;
      
      const locationId = lastDuty.toLocationId || lastDuty.locationId;
      const location = LOCATIONS.find(l => l.id === locationId);
      
      return {
        location,
        endTime: lastShift.end,
        shift: lastShift
      };
    }
    
    // Render smart suggestions panel
    function renderSuggestionPanel(endingInfo, entityType, entityIndex) {
      if (!endingInfo || !endingInfo.location) return '';
      
      // Get unassigned charter jobs
      const charterJobs = unassignedJobs.filter(j => j.type === 'charter' && j.start > endingInfo.endTime);
      
      if (charterJobs.length === 0) return '';
      
      // Find best suggestions
      const suggestions = findBestNextJobs(endingInfo.location, endingInfo.endTime, charterJobs, 5);
      
      if (suggestions.length === 0) return '';
      
      return `
        <div class="suggestion-panel">
          <div class="suggestion-header">
            <span class="suggestion-icon"></span>
            <div>
              <div class="suggestion-title">Smart Suggestions</div>
              <div class="suggestion-subtitle">Based on ${endingInfo.shift.name} ending at ${endingInfo.location.name} @ ${formatTime(endingInfo.endTime)}</div>
            </div>
          </div>
          <div class="suggestion-list">
            ${suggestions.map((s, idx) => `
              <div class="suggestion-item ${s.canMakeIt ? '' : 'not-possible'}">
                <div class="suggestion-rank">#${idx + 1}</div>
                <div class="suggestion-details">
                  <div class="suggestion-job-name">${s.job.name} (${s.job.customer || 'Charter'})</div>
                  <div class="suggestion-location"> ${s.pickupLocation?.name || 'Unknown'} @ ${formatTime(s.job.start)}</div>
                  <div class="suggestion-metrics">
                    <span class="suggestion-metric distance"> ${formatDistance(s.distance)}</span>
                    <span class="suggestion-metric time"> ${formatTravelTime(s.travelTime)}</span>
                    ${s.canMakeIt 
                      ? `<span class="suggestion-metric wait"> ${s.waitTime > 0.08 ? formatTravelTime(s.waitTime) + ' wait' : 'Just in time'}</span>`
                      : `<span class="suggestion-metric late"> Would arrive ${formatTravelTime(s.arrivalTime - s.job.start)} late</span>`
                    }
                  </div>
                </div>
                <div class="suggestion-actions">
                  ${s.canMakeIt 
                    ? `<button class="suggestion-assign-btn" onclick="assignSuggestedJob(${unassignedJobs.indexOf(s.job)}, '${entityType}', ${entityIndex})">Assign</button>`
                    : `<button class="suggestion-assign-btn" disabled>Can't make it</button>`
                  }
                </div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    }
    
    // Assign a suggested job
    function assignSuggestedJob(jobIndex, entityType, entityIndex) {
      if (entityType === 'driver') {
        assignDriverToJob(jobIndex, entityIndex);
      } else if (entityType === 'vehicle') {
        assignVehicleToJob(jobIndex, entityIndex);
      }
    }
    
    function renderJobDetailVehicleCentric(job) {
      if (!job) return `<div class="empty-panel"><div class="empty-icon"></div><div class="empty-text">Job not found</div></div>`;
      
      // Calculate total job hours
      let totalHours = 0;
      const duties = job.duties || [];
      if (duties.length > 0) {
        totalHours = duties.reduce((sum, duty) => sum + (duty.end - duty.start), 0);
      } else {
        totalHours = (job.end || 18) - (job.start || 6);
      }
      
      // Render job duties
      const dutiesHTML = duties.length > 0 ? `
        <div class="duty-list">
          ${duties.map(duty => {
            const dt = DUTY_TYPES[duty.type] || DUTY_TYPES.driving;
            const hours = duty.end - duty.start;
            return `
              <div class="duty-item">
                <div class="duty-type-bar ${duty.type}"></div>
                <div class="duty-content">
                  <div class="duty-row-main">
                    <span class="duty-time">${formatTime(duty.start)}-${formatTime(duty.end)}</span>
                    <span class="duty-desc">${duty.description}</span>
                    <span class="duty-badge ${duty.type}">${dt.label}</span>
                  </div>
                  <div class="duty-row-meta">
                    <span class="duty-hours">${formatDutyHours(hours)}</span>
                  </div>
                </div>
              </div>
            `;
          }).join('')}
        </div>
        <div class="shift-totals" style="margin-top: 8px;">
          <div>
            <span class="shift-totals-label">Total Hours:</span>
            <span class="shift-totals-value">${formatDutyHours(totalHours)}</span>
          </div>
        </div>
      ` : '<div class="info-row"><span class="info-value" style="color: var(--text-muted)">No duties defined</span></div>';
      
      // Location info for charters
      const locationHTML = job.type === 'charter' && job.pickupLocation ? `
        <div class="panel-section" style="background: rgba(59, 130, 246, 0.05); border-radius: 6px; padding: 10px;">
          <div class="info-row"><span class="info-label"> Pickup</span><span class="info-value">${job.pickupLocation.name}</span></div>
          <div class="info-row"><span class="info-label"> Dropoff</span><span class="info-value">${job.dropoffLocation?.name || 'TBC'}</span></div>
          ${job.pickupLocation && job.dropoffLocation ? `
            <div class="info-row">
              <span class="info-label"> Distance</span>
              <span class="info-value">${formatDistance(calculateDistance(job.pickupLocation, job.dropoffLocation))}</span>
            </div>
            <div class="info-row">
              <span class="info-label"> Est. Travel</span>
              <span class="info-value">${formatTravelTime(estimateTravelTime(job.pickupLocation, job.dropoffLocation))}</span>
            </div>
          ` : ''}
        </div>
      ` : '';
      
      return `
        <div class="panel-header">
          <div class="panel-header-info">
            <div class="panel-title">${job.name}</div>
            <div class="panel-subtitle">${job.id}</div>
          </div>
        </div>
        <div class="panel-content">
          <div class="panel-section">
            <div class="info-row"><span class="info-label">Time</span><span class="info-value">${formatTime(job.start)} - ${formatTime(job.end)}</span></div>
            <div class="info-row"><span class="info-label">Type</span><span class="info-value">${job.type === 'charter' ? 'Charter' : 'Shift'}</span></div>
            ${job.customer ? `<div class="info-row"><span class="info-label">Customer</span><span class="info-value">${job.customer}</span></div>` : ''}
          </div>
          ${locationHTML}
          <div class="panel-section">
            <div class="panel-section-title">Job Breakdown</div>
            ${dutiesHTML}
          </div>
          <div class="panel-section">
            <div class="panel-section-title">Assign Vehicle</div>
            <div class="assignment-panel">
              <div class="assignment-search">
                <input type="text" class="assignment-search-input" id="assignVehicleSearch" 
                       placeholder="Search by ID or rego..." oninput="updateVehicleAssignmentList(${unassignedJobs.indexOf(job)})">
              </div>
              <div class="assignment-filters">
                <select class="filter-select" id="assignVehicleFilter" onchange="updateVehicleAssignmentList(${unassignedJobs.indexOf(job)})">
                  <option value="no-duties">No duties</option>
                  <option value="has-duties">Has duties</option>
                  <option value="not-available">Not available</option>
                  <option value="all">All vehicles</option>
                </select>
                <select class="filter-select" id="assignVehicleCapacity" onchange="updateVehicleAssignmentList(${unassignedJobs.indexOf(job)})">
                  <option value="all">Any Capacity</option>
                  <option value="45">45+ seats</option>
                  <option value="50">50+ seats</option>
                  <option value="60">60+ seats</option>
                </select>
                <select class="filter-select" id="assignVehicleSort" onchange="updateVehicleAssignmentList(${unassignedJobs.indexOf(job)})">
                  <option value="id">Vehicle ID</option>
                  <option value="capacity-desc">Capacity (highlow)</option>
                  <option value="capacity-asc">Capacity (lowhigh)</option>
                  <option value="hours-asc">Hours (lowhigh)</option>
                  <option value="hours-desc">Hours (highlow)</option>
                </select>
              </div>
              <div class="assignment-count" id="vehicleAssignmentCount"></div>
              <div class="assignment-list" id="vehicleAssignmentList"></div>
            </div>
          </div>
        </div>
      `;
    }
    
    function updateVehicleAssignmentList(jobIndex) {
      const job = unassignedJobs[jobIndex];
      if (!job) return;
      
      const search = document.getElementById('assignVehicleSearch')?.value?.toLowerCase() || '';
      const filter = document.getElementById('assignVehicleFilter')?.value || 'no-duties';
      const capacityFilter = document.getElementById('assignVehicleCapacity')?.value || 'all';
      const sort = document.getElementById('assignVehicleSort')?.value || 'id';
      
      // Get all non-maintenance vehicles first
      let filteredVehicles = vehicles.filter(v => v.status !== 'maintenance');
      
      // Helper to check if vehicle is available for the job time
      const isAvailableForJob = (vehicle) => {
        const jobStartMins = toMinutes(job.start);
        const jobEndMins = toMinutes(job.end);
        
        for (const shift of vehicle.shifts) {
          if (shift.type === 'maintenance') continue;
          for (const duty of shift.duties) {
            const dStartMins = toMinutes(duty.start);
            const dEndMins = toMinutes(duty.end);
            if (jobStartMins < dEndMins && jobEndMins > dStartMins) {
              return false; // Overlap found
            }
          }
        }
        return true;
      };
      
      // Helper to get total hours for a vehicle
      const getTotalHours = (vehicle) => {
        return vehicle.shifts.reduce((total, shift) => {
          if (shift.type === 'maintenance') return total;
          return total + shift.duties.reduce((sum, duty) => sum + (duty.end - duty.start), 0);
        }, 0);
      };
      
      // Apply availability filter
      if (filter === 'no-duties') {
        filteredVehicles = filteredVehicles.filter(v => {
          const nonMaintShifts = v.shifts.filter(s => s.type !== 'maintenance');
          return nonMaintShifts.length === 0 || nonMaintShifts.every(s => s.duties.length === 0);
        });
      } else if (filter === 'has-duties') {
        filteredVehicles = filteredVehicles.filter(v => {
          const hasDuties = v.shifts.some(s => s.type !== 'maintenance' && s.duties.length > 0);
          return hasDuties && isAvailableForJob(v);
        });
      } else if (filter === 'not-available') {
        filteredVehicles = filteredVehicles.filter(v => !isAvailableForJob(v));
      }
      // 'all' shows everyone except maintenance
      
      // Apply search
      if (search) {
        filteredVehicles = filteredVehicles.filter(v => 
          v.id.toLowerCase().includes(search) || 
          v.rego.toLowerCase().includes(search)
        );
      }
      
      // Apply capacity filter
      if (capacityFilter !== 'all') {
        const minCapacity = parseInt(capacityFilter);
        filteredVehicles = filteredVehicles.filter(v => v.capacity >= minCapacity);
      }
      
      // Apply sorting
      filteredVehicles.sort((a, b) => {
        switch (sort) {
          case 'id':
            return a.id.localeCompare(b.id);
          case 'capacity-desc':
            return b.capacity - a.capacity;
          case 'capacity-asc':
            return a.capacity - b.capacity;
          case 'hours-asc':
            return getTotalHours(a) - getTotalHours(b);
          case 'hours-desc':
            return getTotalHours(b) - getTotalHours(a);
          default:
            return 0;
        }
      });
      
      // Update count with filter context
      const countEl = document.getElementById('vehicleAssignmentCount');
      if (countEl) {
        const filterLabels = {
          'no-duties': 'with no duties',
          'has-duties': 'with duties (available)',
          'not-available': 'not available',
          'all': 'total'
        };
        countEl.textContent = `${filteredVehicles.length} vehicle(s) ${filterLabels[filter]}`;
      }
      
      // Render list
      const listEl = document.getElementById('vehicleAssignmentList');
      if (listEl) {
        if (filteredVehicles.length === 0) {
          listEl.innerHTML = '<div class="assignment-empty">No matching vehicles</div>';
        } else {
          listEl.innerHTML = filteredVehicles.map(v => {
            const vehicleIdx = vehicles.indexOf(v);
            const totalHours = getTotalHours(v);
            const available = isAvailableForJob(v);
            const shiftCount = v.shifts.filter(s => s.type !== 'maintenance' && s.duties.length > 0).length;
            
            // Build detail text
            let detailText = `${v.capacity} seats`;
            if (shiftCount > 0) {
              detailText += `  ${shiftCount} shift(s)  ${formatDutyHours(totalHours)}`;
            }
            
            return `
              <div class="assignment-item ${!available ? 'unavailable' : ''}">
                <div class="assignment-item-info">
                  <span class="assignment-item-name clickable" onclick="navigateToResource('vehicle', ${vehicleIdx})">${v.id}</span>
                  <span class="assignment-item-detail">${detailText}</span>
                </div>
                <span class="assignment-item-status ${available ? (shiftCount > 0 ? 'inuse' : 'available') : 'unavailable'}">${available ? (shiftCount > 0 ? 'In Use' : 'Available') : 'Busy'}</span>
                ${available ? `<button class="assign-btn" onclick="assignVehicleToJob(${jobIndex}, ${vehicleIdx})">Assign</button>` : ''}
              </div>
            `;
          }).join('');
        }
      }
    }
    
    // Transfer list update functions
    function updateTransferDriverList() {
      if (!transferringShift || transferringShift.type !== 'driver') return;
      
      const shift = transferringShift.shift;
      const search = document.getElementById('transferDriverSearch')?.value?.toLowerCase() || '';
      
      let availableDrivers = getDriversAvailableForShift(shift, transferringShift.sourceId);
      
      // Apply search
      if (search) {
        availableDrivers = availableDrivers.filter(d => 
          d.name.toLowerCase().includes(search) || 
          d.fullName.toLowerCase().includes(search) ||
          d.id.toLowerCase().includes(search)
        );
      }
      
      // Update count
      const countEl = document.getElementById('transferDriverCount');
      if (countEl) {
        countEl.textContent = `${availableDrivers.length} driver(s) available for ${formatTime(shift.start)}-${formatTime(shift.end)}`;
      }
      
      // Render list
      const listEl = document.getElementById('transferDriverList');
      if (listEl) {
        if (availableDrivers.length === 0) {
          listEl.innerHTML = '<div class="assignment-empty">No matching drivers available</div>';
        } else {
          listEl.innerHTML = availableDrivers.map(d => {
            const driverIdx = drivers.indexOf(d);
            return `
            <div class="assignment-item">
              <div class="assignment-item-info">
                <span class="assignment-item-name clickable" onclick="navigateToResource('driver', ${driverIdx})">${d.fullName}</span>
                <span class="assignment-item-detail">${d.shifts.length > 0 ? `${d.shifts.length} shift(s)` : 'No shifts'}</span>
              </div>
              <span class="assignment-item-status ${d.status}">${d.status === 'available' ? 'Available' : 'Working'}</span>
              <button class="assign-btn" onclick="executeTransferDriverShift('${d.id}')">Transfer</button>
            </div>
          `}).join('');
        }
      }
    }
    
    function updateTransferVehicleList() {
      if (!transferringShift || transferringShift.type !== 'vehicle') return;
      
      const shift = transferringShift.shift;
      const search = document.getElementById('transferVehicleSearch')?.value?.toLowerCase() || '';
      
      let availableVehicles = getVehiclesAvailableForShift(shift, transferringShift.sourceId);
      
      // Apply search
      if (search) {
        availableVehicles = availableVehicles.filter(v => 
          v.id.toLowerCase().includes(search) || 
          v.rego.toLowerCase().includes(search)
        );
      }
      
      // Update count
      const countEl = document.getElementById('transferVehicleCount');
      if (countEl) {
        countEl.textContent = `${availableVehicles.length} vehicle(s) available for ${formatTime(shift.start)}-${formatTime(shift.end)}`;
      }
      
      // Render list
      const listEl = document.getElementById('transferVehicleList');
      if (listEl) {
        if (availableVehicles.length === 0) {
          listEl.innerHTML = '<div class="assignment-empty">No matching vehicles available</div>';
        } else {
          listEl.innerHTML = availableVehicles.map(v => {
            const vehicleIdx = vehicles.indexOf(v);
            const shiftCount = v.shifts.filter(s => s.type !== 'maintenance').length;
            return `
              <div class="assignment-item">
                <div class="assignment-item-info">
                  <span class="assignment-item-name clickable" onclick="navigateToResource('vehicle', ${vehicleIdx})">${v.id}</span>
                  <span class="assignment-item-detail">${v.capacity} seats${shiftCount > 0 ? `  ${shiftCount} shift(s)` : ''}</span>
                </div>
                <span class="assignment-item-status ${v.status}">${v.status === 'available' ? 'Available' : 'In Use'}</span>
                <button class="assign-btn" onclick="executeTransferVehicleShift('${v.id}')">Transfer</button>
              </div>
            `;
          }).join('');
        }
      }
    }

    function editDuty(driverId, shiftId, dutyIdx) {
      const driver = drivers.find(d => d.id === driverId);
      const shift = driver.shifts.find(s => s.id === shiftId);
      const duty = shift.duties[dutyIdx];
      
      editingDuty = { 
        driverId, 
        shiftId, 
        dutyIdx, 
        duty: { ...duty }, 
        shift, 
        isNew: false 
      };
      formErrors = {};
      renderDetailPanel();
    }

    function showAddDutyForm(driverId) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      // Find all available slots across the ENTIRE day, including gaps between shifts
      const dayStart = 5;  // 5am
      const dayEnd = 23;   // 11pm
      const allSlots = findAllAvailableSlots(driver, dayStart, dayEnd);
      
      if (allSlots.length === 0) {
        showToast('No available time slots today', true);
        return;
      }
      
      // PRIORITY: Find slots WITHIN existing shifts first (these can be saved to DB)
      let selectedSlot = null;
      let containingShift = null;
      
      for (const slot of allSlots) {
        const duration = Math.min(0.5, slot.end - slot.start);
        const shift = driver.shifts.find(s => s.start <= slot.start && s.end >= slot.start + duration);
        if (shift && shift.entryId) {
          selectedSlot = slot;
          containingShift = shift;
          break;
        }
      }
      
      // If no slot within shifts, use first slot (will be adhoc/local only)
      if (!selectedSlot) {
        selectedSlot = allSlots[0];
        const duration = Math.min(0.5, selectedSlot.end - selectedSlot.start);
        containingShift = driver.shifts.find(s => s.start <= selectedSlot.start && s.end >= selectedSlot.start + duration);
      }
      
      const duration = Math.min(0.5, selectedSlot.end - selectedSlot.start);
      
      editingDuty = {
        driverId, 
        shiftId: containingShift ? containingShift.id : null,
        dutyIdx: containingShift ? containingShift.duties.length : 0,
        duty: { 
          id: `d-new-${Date.now()}`, 
          type: 'driving', 
          start: selectedSlot.start, 
          end: selectedSlot.start + duration, 
          description: 'New duty', 
          vehicle: null 
        },
        shift: containingShift || null,
        isNew: true,
        isAdhoc: !containingShift,
        allSlots: allSlots
      };
      formErrors = {};
      renderDetailPanel();
    }
    
    // Find ALL available time slots for a driver across the entire day
    function findAllAvailableSlots(driver, dayStart, dayEnd, minDuration = 0.25) {
      const slots = [];
      const minDurationMins = toMinutes(minDuration);
      
      // Collect all occupied periods (from all shifts' duties)
      const occupiedPeriods = [];
      driver.shifts.forEach(shift => {
        shift.duties.forEach(duty => {
          occupiedPeriods.push({ start: duty.start, end: duty.end });
        });
      });
      
      // Sort by start time
      occupiedPeriods.sort((a, b) => a.start - b.start);
      
      // Find gaps
      let currentTime = dayStart;
      
      for (const period of occupiedPeriods) {
        const gapMins = toMinutes(period.start) - toMinutes(currentTime);
        if (gapMins >= minDurationMins) {
          slots.push({ start: currentTime, end: period.start });
        }
        currentTime = Math.max(currentTime, period.end);
      }
      
      // Check for gap at end of day
      const endGapMins = toMinutes(dayEnd) - toMinutes(currentTime);
      if (endGapMins >= minDurationMins) {
        slots.push({ start: currentTime, end: dayEnd });
      }
      
      return slots;
    }

    function fillSlot(start, end) {
      if (!editingDuty) return;
      
      const duration = Math.min(0.5, end - start);
      editingDuty.duty.start = start;
      editingDuty.duty.end = start + duration;
      
      // Check if this slot falls within an existing shift
      const driver = drivers.find(d => d.id === editingDuty.driverId);
      const containingShift = driver.shifts.find(s => s.start <= start && s.end >= start + duration);
      
      editingDuty.shift = containingShift || null;
      editingDuty.shiftId = containingShift ? containingShift.id : null;
      editingDuty.isAdhoc = !containingShift;
      
      formErrors = {};
      renderDetailPanel();
    }

    function onFormChange() {
      if (!editingDuty) return;
      
      const startStr = document.getElementById('editStart')?.value;
      const endStr = document.getElementById('editEnd')?.value;
      const type = document.getElementById('editType')?.value;
      const vehicle = document.getElementById('editVehicle')?.value || null;
      
      const start = parseTime(startStr);
      const end = parseTime(endStr);
      
      editingDuty.duty.start = start;
      editingDuty.duty.end = end;
      editingDuty.duty.type = type;
      editingDuty.duty.vehicle = vehicle;
      
      // For vehicle-centric editing, skip driver-based validation
      if (editingDuty.isVehicleCentric) {
        // Validate within the shift bounds
        if (editingDuty.shift) {
          const excludeId = editingDuty.duty.id;
          formErrors = validateDutyForm(
            { start, end, type, driver: editingDuty.duty.driver }, 
            editingDuty.shift.duties, 
            editingDuty.shift.start, 
            editingDuty.shift.end, 
            excludeId
          );
        } else {
          formErrors = {};
        }
        renderDetailPanel();
        return;
      }
      
      const driver = drivers.find(d => d.id === editingDuty.driverId);
      if (!driver) return;
      
      // Only re-check shift assignment for truly adhoc duties (ones created via "Add Duty" button)
      // For duties inserted via arrows, we already have the correct shift reference
      if (editingDuty.isNew && editingDuty.isAdhoc) {
        // This is a truly adhoc duty - find which shift it belongs to based on times
        const containingShift = driver.shifts.find(s => s.start <= start && s.end >= end);
        editingDuty.shift = containingShift || null;
        editingDuty.shiftId = containingShift ? containingShift.id : null;
        editingDuty.isAdhoc = !containingShift;
      }
      
      // Validate
      if (editingDuty.isAdhoc || !editingDuty.shift) {
        // Validate against all duties across all shifts (for adhoc)
        const allDuties = driver.shifts.flatMap(s => s.duties);
        formErrors = validateAdhocDutyForm({ start, end, type, vehicle }, allDuties, editingDuty.duty.id);
      } else {
        // Validate within the shift - use the shift reference we already have
        const excludeId = editingDuty.duty.id;
        formErrors = validateDutyForm(
          { start, end, type, vehicle }, 
          editingDuty.shift.duties, 
          editingDuty.shift.start, 
          editingDuty.shift.end, 
          excludeId,
          driver,
          editingDuty.shiftId
        );
      }
      
      renderDetailPanel();
    }
    
    // Validate adhoc duty against all existing duties (not bound to a shift)
    function validateAdhocDutyForm(data, allDuties, excludeId = null) {
      const errors = {};
      
      if (isNaN(data.start) || isNaN(data.end)) {
        errors.time = 'Invalid time format (use HH:MM or HHMM, e.g., 07:30 or 0730)';
        return errors;
      }
      
      if (data.start < 0 || data.start > 24 || data.end < 0 || data.end > 24) {
        errors.time = 'Time must be between 00:00 and 24:00';
        return errors;
      }
      
      const startMins = toMinutes(data.start);
      const endMins = toMinutes(data.end);
      
      if (startMins >= endMins) {
        errors.time = 'End time must be after start time';
        return errors;
      }
      
      // Check for overlaps with any existing duty (excluding the one being edited)
      const overlap = allDuties.find(d => {
        if (excludeId && d.id === excludeId) return false; // Skip the duty being edited
        const dStartMins = toMinutes(d.start);
        const dEndMins = toMinutes(d.end);
        return (startMins < dEndMins && endMins > dStartMins);
      });
      
      if (overlap) {
        errors.overlap = `Overlaps with duty at ${formatTime(overlap.start)}-${formatTime(overlap.end)}`;
      }
      
      // Check vehicle availability (if a vehicle is selected)
      if (data.vehicle && !isVehicleAvailableForDuty(data.vehicle, data.start, data.end, excludeId)) {
        errors.vehicle = `${data.vehicle} is already assigned during this time`;
      }
      
      return errors;
    }

    function cancelEdit() {
      // If we extended a shift for a new duty and user cancels, revert the extension
      if (editingDuty && editingDuty.isNew && editingDuty.shift) {
        if (editingDuty.originalShiftStart !== undefined) {
          editingDuty.shift.start = editingDuty.originalShiftStart;
        }
        if (editingDuty.originalShiftEnd !== undefined) {
          editingDuty.shift.end = editingDuty.originalShiftEnd;
        }
      }
      
      editingDuty = null;
      formErrors = {};
      renderAll();
    }

    async function saveEdit() {
      if (!editingDuty) return;
      
      const startStr = document.getElementById('editStart')?.value;
      const endStr = document.getElementById('editEnd')?.value;
      const type = document.getElementById('editType')?.value;
      const vehicle = document.getElementById('editVehicle')?.value || null;
      const description = document.getElementById('editDesc')?.value || '';
      const locationName = document.getElementById('editLocation')?.value || null;
      const locationLat = parseFloat(document.getElementById('editLocationLat')?.value) || null;
      const locationLng = parseFloat(document.getElementById('editLocationLng')?.value) || null;
      
      const start = parseTime(startStr);
      const end = parseTime(endStr);
      
      const driver = drivers.find(d => d.id === editingDuty.driverId);
      
      // Final validation
      if (editingDuty.isAdhoc || !editingDuty.shift) {
        const allDuties = driver.shifts.flatMap(s => s.duties);
        // Exclude current duty from overlap check
        formErrors = validateAdhocDutyForm({ start, end, type, vehicle }, allDuties, editingDuty.duty.id);
      } else {
        // Always exclude the duty being edited
        const excludeId = editingDuty.duty.id;
        formErrors = validateDutyForm(
          { start, end, type, vehicle }, 
          editingDuty.shift.duties, 
          editingDuty.shift.start, 
          editingDuty.shift.end, 
          excludeId,
          driver,
          editingDuty.shiftId
        );
      }
      
      if (Object.keys(formErrors).length > 0) {
        renderDetailPanel();
        return;
      }
      
      const updatedDuty = { 
        id: editingDuty.duty.id, 
        type, 
        start, 
        end, 
        description, 
        vehicle,
        locationName,
        locationLat,
        locationLng
      };
      
      if (editingDuty.isNew) {
        if (editingDuty.isAdhoc || !editingDuty.shift) {
          // Create new adhoc shift via API
          if (dataSource === 'real') {
            try {
              const result = await apiRequest('/dispatch/create-adhoc-shift', {
                method: 'POST',
                body: {
                  date: formatDateISO(currentDate),
                  employee_id: driver.id,
                  duty: {
                    start_time: start,
                    end_time: end,
                    duty_type: type,
                    description: description || 'Adhoc duty',
                    vehicle_number: vehicle || null,
                    pay_type: 'STD',
                    location_name: locationName,
                    location_lat: locationLat,
                    location_lng: locationLng
                  }
                }
              });
              
              if (result.error) {
                showToast(result.error, 'error');
                return;
              }
              
              // Create local shift object with real IDs
              const newShift = {
                id: `shift-${result.entry_id}`,
                entryId: result.entry_id,
                name: result.adhoc_code,
                type: 'adhoc',
                start: start,
                end: end,
                duties: [{
                  ...updatedDuty,
                  id: result.duty_line_id
                }]
              };
              driver.shifts.push(newShift);
              driver.shifts.sort((a, b) => a.start - b.start);
              
              showToast('Adhoc duty created');
            } catch (err) {
              showToast(err.message || 'Failed to create adhoc duty', 'error');
              return;
            }
          } else {
            // Demo mode - local only
            const newShift = {
              id: `shift-adhoc-${Date.now()}`,
              name: `ADHOC ${String(Math.floor(Math.random() * 900) + 100)}`,
              type: 'adhoc',
              start: start,
              end: end,
              duties: [updatedDuty]
            };
            driver.shifts.push(newShift);
            driver.shifts.sort((a, b) => a.start - b.start);
            showToast('Adhoc duty created (demo mode)');
          }
          
          // Update driver status if they were available
          if (driver.status === 'available') {
            driver.status = 'working';
          }
        } else {
          // Add to existing shift - call API if in real mode
          if (dataSource === 'real' && editingDuty.shift.entryId) {
            try {
              const result = await apiRequest('/dispatch/create-duty-line', {
                method: 'POST',
                body: {
                  roster_entry_id: editingDuty.shift.entryId,
                  start_time: start,
                  end_time: end,
                  duty_type: type,
                  description: description,
                  vehicle_number: vehicle || null,
                  pay_type: 'STD',
                  location_name: locationName,
                  location_lat: locationLat,
                  location_lng: locationLng
                }
              });
              
              if (result.error) {
                showToast(result.error, 'error');
                return;
              }
              
              // Use the real ID from API
              updatedDuty.id = result.duty_line_id;
            } catch (err) {
              showToast(err.message || 'Failed to create duty', 'error');
              return;
            }
          }
          
          editingDuty.shift.duties.push(updatedDuty);
          editingDuty.shift.duties.sort((a, b) => a.start - b.start);
          
          // Auto-extend shift boundaries to fit the new duty
          updateShiftBounds(editingDuty.shift);
          
          showToast('Duty added successfully');
        }
      } else {
        // Update existing duty - track old vehicle for sync
        const shift = driver.shifts.find(s => s.id === editingDuty.shiftId);
        const oldVehicle = shift.duties[editingDuty.dutyIdx].vehicle;
        
        // If vehicle changed, unsync from old vehicle
        if (oldVehicle && oldVehicle !== vehicle) {
          unsyncVehicleSchedule(oldVehicle, editingDuty.duty.id);
        }
        
        shift.duties[editingDuty.dutyIdx] = updatedDuty;
        shift.duties.sort((a, b) => a.start - b.start);
        
        // Auto-extend shift boundaries to fit the updated duty
        updateShiftBounds(shift);
        
        showToast('Duty updated successfully');
      }
      
      editingDuty = null;
      formErrors = {};
      
      // Sync vehicle assignment to vehicle's schedule
      if (vehicle) {
        syncVehicleSchedule(vehicle, updatedDuty, driver);
      }
      
      renderAll();
    }
    
    // Sync a duty's vehicle assignment to the vehicle's own schedule
    function syncVehicleSchedule(vehicleId, duty, driver, shiftInfo = null) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      if (!vehicle) return;
      
      // Find the shift this duty belongs to
      let sourceShift = shiftInfo;
      if (!sourceShift) {
        for (const shift of driver.shifts) {
          if (shift.duties.some(d => d.id === duty.id)) {
            sourceShift = shift;
            break;
          }
        }
      }
      
      // Check if vehicle already has a shift that covers this time
      // Look for an existing synced shift for this driver AND shift
      let syncedShift = vehicle.shifts.find(s => 
        s.syncedDriverId === driver.id && 
        s.syncedShiftId === (sourceShift?.id || null) &&
        s.type !== 'maintenance'
      );
      
      if (!syncedShift) {
        // Create a new synced shift on the vehicle
        syncedShift = {
          id: `vshift-sync-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
          name: sourceShift?.name || driver.name,
          type: 'synced',
          syncedDriverId: driver.id,
          syncedShiftId: sourceShift?.id || null,
          shiftType: sourceShift?.type || 'shift',
          start: duty.start,
          end: duty.end,
          duties: []
        };
        vehicle.shifts.push(syncedShift);
      }
      
      // Check if this duty already exists in the synced shift
      const existingDutyIdx = syncedShift.duties.findIndex(d => d.syncedDutyId === duty.id);
      
      const syncedDuty = {
        id: `vduty-sync-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
        syncedDutyId: duty.id,
        type: duty.type,
        start: duty.start,
        end: duty.end,
        description: duty.description || `${driver.name}`,
        driver: driver.name
      };
      
      if (existingDutyIdx >= 0) {
        // Update existing
        syncedDuty.id = syncedShift.duties[existingDutyIdx].id;
        syncedShift.duties[existingDutyIdx] = syncedDuty;
      } else {
        // Add new
        syncedShift.duties.push(syncedDuty);
      }
      
      // Sort duties and update shift bounds
      syncedShift.duties.sort((a, b) => a.start - b.start);
      if (syncedShift.duties.length > 0) {
        syncedShift.start = Math.min(...syncedShift.duties.map(d => d.start));
        syncedShift.end = Math.max(...syncedShift.duties.map(d => d.end));
      }
      
      // Update vehicle status
      if (vehicle.status === 'available') {
        vehicle.status = 'inuse';
      }
    }
    
    // Remove a duty from vehicle's synced schedule
    function unsyncVehicleSchedule(vehicleId, dutyId) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      if (!vehicle) return;
      
      for (const shift of vehicle.shifts) {
        const dutyIdx = shift.duties.findIndex(d => d.syncedDutyId === dutyId);
        if (dutyIdx >= 0) {
          shift.duties.splice(dutyIdx, 1);
          
          // If shift is now empty, remove it
          if (shift.duties.length === 0 && shift.type === 'synced') {
            const shiftIdx = vehicle.shifts.indexOf(shift);
            vehicle.shifts.splice(shiftIdx, 1);
          } else {
            // Update shift bounds
            shift.start = Math.min(...shift.duties.map(d => d.start));
            shift.end = Math.max(...shift.duties.map(d => d.end));
          }
          break;
        }
      }
      
      // Update vehicle status if no more duties
      const hasActiveDuties = vehicle.shifts.some(s => s.type !== 'maintenance' && s.duties.length > 0);
      if (!hasActiveDuties) {
        vehicle.status = 'available';
      }
    }
    
    // Recalculate shift start/end to encompass all duties
    function updateShiftBounds(shift) {
      if (!shift.duties || shift.duties.length === 0) return;
      
      // Only consider active (non-cancelled) duties for bounds
      const activeDuties = shift.duties.filter(d => !d.cancelled);
      if (activeDuties.length === 0) return;
      
      const minStart = Math.min(...activeDuties.map(d => d.start));
      const maxEnd = Math.max(...activeDuties.map(d => d.end));
      
      // Always update to actual bounds of active duties
      shift.start = minStart;
      shift.end = maxEnd;
    }

    function deleteDuty(driverId, shiftId, dutyIdx) {
      const driver = drivers.find(d => d.id === driverId);
      const shift = driver.shifts.find(s => s.id === shiftId);
      const duty = shift.duties[dutyIdx];
      
      // Unsync vehicle if assigned
      if (duty.vehicle) {
        unsyncVehicleSchedule(duty.vehicle, duty.id);
      }
      
      shift.duties.splice(dutyIdx, 1);
      showToast('Duty deleted');
      renderAll();
    }

    // ============================================
    // DUTY CANCELLATION
    // ============================================
    
    let pendingCancelDuty = null;
    
    function openCancelDutyModal(dutyId, driverId, shiftId, dutyIdx) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === shiftId);
      if (!shift) return;
      
      const duty = shift.duties[dutyIdx];
      if (!duty) return;
      
      // Store pending cancel info
      pendingCancelDuty = { dutyId, driverId, shiftId, dutyIdx, duty };
      
      // Populate modal with duty info
      document.getElementById('cancelDutyInfo').innerHTML = `
        <div style="display: flex; gap: 16px; align-items: center;">
          <div class="duty-type-bar ${duty.type}" style="width: 4px; height: 40px; border-radius: 2px;"></div>
          <div>
            <div style="font-weight: 500; color: var(--text-primary);">${formatTimeCompact(duty.start)} - ${formatTimeCompact(duty.end)}</div>
            <div style="color: var(--text-secondary); font-size: 13px;">${duty.description}</div>
          </div>
        </div>
      `;
      
      document.getElementById('cancelDutyReason').value = '';
      document.getElementById('cancelDutyModalOverlay').classList.add('show');
    }
    
    function closeCancelDutyModal() {
      document.getElementById('cancelDutyModalOverlay').classList.remove('show');
      pendingCancelDuty = null;
    }
    
    async function cancelAllDuties(driverId, shiftId) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === shiftId);
      if (!shift) return;
      
      // Get active (non-cancelled) duties
      const activeDuties = shift.duties.filter(d => !d.cancelled);
      if (activeDuties.length === 0) {
        showToast('All duties already cancelled', 'info');
        return;
      }
      
      if (!confirm(`Cancel all ${activeDuties.length} active duties in ${shift.name}?`)) {
        return;
      }
      
      let cancelled = 0;
      let failed = 0;
      
      for (const duty of activeDuties) {
        if (dataSource === 'real' && duty.id && !duty.id.startsWith('placeholder-') && !duty.id.startsWith('d-')) {
          try {
            const result = await apiRequest('/dispatch/cancel-duty-line', {
              method: 'POST',
              body: {
                duty_line_id: duty.id,
                reason: 'Bulk cancel'
              }
            });
            
            if (!result.error) {
              duty.cancelled = true;
              duty.cancelReason = 'Bulk cancel';
              duty.cancelledAt = new Date().toISOString();
              cancelled++;
            } else {
              failed++;
            }
          } catch (err) {
            failed++;
          }
        } else {
          // Demo mode
          duty.cancelled = true;
          duty.cancelReason = 'Bulk cancel';
          duty.cancelledAt = new Date().toISOString();
          cancelled++;
        }
      }
      
      updateShiftBounds(shift);
      
      if (failed > 0) {
        showToast(`Cancelled ${cancelled} duties, ${failed} failed`, 'warning');
      } else {
        showToast(`All ${cancelled} duties cancelled`);
      }
      
      renderAll();
    }
    
    async function confirmCancelDuty() {
      if (!pendingCancelDuty) return;
      
      const { dutyId, driverId, shiftId, dutyIdx, duty } = pendingCancelDuty;
      const reason = document.getElementById('cancelDutyReason').value.trim() || null;
      
      // Call API to cancel
      if (dataSource === 'real' && dutyId && !dutyId.startsWith('placeholder-') && !dutyId.startsWith('d-')) {
        try {
          const result = await apiRequest('/dispatch/cancel-duty-line', {
            method: 'POST',
            body: {
              duty_line_id: dutyId,
              reason: reason
            }
          });
          
          if (result.error) {
            showToast(result.error, 'error');
            return;
          }
          
          // Update local state
          duty.cancelled = true;
          duty.cancelReason = reason;
          duty.cancelledAt = new Date().toISOString();
          
          // Recalculate shift bounds based on remaining active duties
          const driver = drivers.find(d => d.id === driverId);
          const shift = driver?.shifts.find(s => s.id === shiftId);
          if (shift) {
            updateShiftBounds(shift);
          }
          
          closeCancelDutyModal();
          showToast('Duty cancelled');
          renderAll();
        } catch (err) {
          showToast(err.message || 'Cancel failed', 'error');
        }
      } else {
        // Demo mode - just update local state
        duty.cancelled = true;
        duty.cancelReason = reason;
        duty.cancelledAt = new Date().toISOString();
        
        const driver = drivers.find(d => d.id === driverId);
        const shift = driver?.shifts.find(s => s.id === shiftId);
        if (shift) {
          updateShiftBounds(shift);
        }
        
        closeCancelDutyModal();
        showToast('Duty cancelled (demo mode)');
        renderAll();
      }
    }
    
    async function reinstateDutyLine(dutyId, driverId, shiftId) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === shiftId);
      if (!shift) return;
      
      const duty = shift.duties.find(d => d.id === dutyId);
      if (!duty) return;
      
      // Check for overlap with ALL active duties across ALL shifts for this driver
      for (const s of driver.shifts) {
        for (const d of s.duties) {
          if (d.id === duty.id) continue; // Skip self
          if (d.cancelled) continue; // Skip cancelled duties
          
          // Check for time overlap
          if (duty.start < d.end && duty.end > d.start) {
            showToast(`Cannot reinstate: overlaps with ${d.description || 'duty'} (${formatTimeCompact(d.start)}-${formatTimeCompact(d.end)})`, 'error');
            return;
          }
        }
      }
      
      // Call API to reinstate
      if (dataSource === 'real' && dutyId && !dutyId.startsWith('placeholder-') && !dutyId.startsWith('d-')) {
        try {
          const result = await apiRequest('/dispatch/reinstate-duty-line', {
            method: 'POST',
            body: {
              duty_line_id: dutyId
            }
          });
          
          if (result.error) {
            showToast(result.error, 'error');
            return;
          }
          
          // Update local state
          duty.cancelled = false;
          duty.cancelReason = null;
          duty.cancelledAt = null;
          
          // Recalculate shift bounds
          updateShiftBounds(shift);
          
          showToast('Duty reinstated');
          renderAll();
        } catch (err) {
          showToast(err.message || 'Reinstate failed', 'error');
        }
      } else {
        // Demo mode - just update local state
        duty.cancelled = false;
        duty.cancelReason = null;
        duty.cancelledAt = null;
        
        updateShiftBounds(shift);
        
        showToast('Duty reinstated (demo mode)');
        renderAll();
      }
    }

    async function assignDriverToJob(jobIndex, driverIndex) {
      const job = unassignedJobs[jobIndex];
      const driver = drivers[driverIndex];
      
      // If real data mode, call API to persist
      if (dataSource === 'real' && job.entryId) {
        try {
          const result = await apiRequest('/dispatch/assign', {
            method: 'POST',
            body: {
              roster_entry_id: job.entryId,
              driver_id: driver.id
            }
          });
          
          if (result.error) {
            showToast(result.error, 'error');
            return;
          }
          
          showToast(`${driver.name} assigned to ${job.name}`);
          selectedItem = null;  // Clear selection before reload
          await loadDispatchData();  // Reload from API
          return;
        } catch (err) {
          showToast(err.message || 'Assignment failed', 'error');
          return;
        }
      }
      
      // Fake data mode - just update local arrays
      const duties = job.duties.map(d => ({ ...d, vehicle: null }));
      
      driver.shifts.push({
        id: `shift-assigned-${Date.now()}`,
        name: job.name,
        type: job.type,
        start: job.start,
        end: job.end,
        duties: duties
      });
      driver.status = 'working';
      
      unassignedJobs.splice(jobIndex, 1);
      
      showToast(`${driver.name} assigned to ${job.name}  assign vehicles to duties`);
      selectedItem = { type: 'driver', index: driverIndex };
      renderAll();
    }
    
    function assignVehicleToJob(jobIndex, vehicleIndex) {
      const job = unassignedJobs[jobIndex];
      const vehicle = vehicles[vehicleIndex];
      
      // Use the job's pre-defined duties instead of generating new ones
      const duties = job.duties.map(d => ({ ...d, driver: null, driverId: null }));
      
      vehicle.shifts.push({
        id: `vshift-assigned-${Date.now()}`,
        name: job.name,
        type: job.type,
        start: job.start,
        end: job.end,
        duties: duties
      });
      vehicle.status = 'inuse';
      
      unassignedJobs.splice(jobIndex, 1);
      
      showToast(`${vehicle.id} assigned to ${job.name}  assign drivers to duties`);
      selectedItem = { type: 'vehicle', index: vehicleIndex };
      renderAll();
    }
    
    // ============ TRANSFER & UNASSIGN FUNCTIONS ============
    
    let transferringShift = null; // { type: 'driver'|'vehicle', sourceId, shiftIdx, shift }
    let bulkAssigning = null; // { type: 'vehicle'|'driver', driverId?, vehicleId?, shiftId, shift, unassignedDuties }
    
    // Driver shift transfer
    function showTransferDriverShift(driverId, shiftIdx) {
      const driver = drivers.find(d => d.id === driverId);
      const shift = driver.shifts[shiftIdx];
      
      transferringShift = {
        type: 'driver',
        sourceId: driverId,
        shiftIdx: shiftIdx,
        shift: shift
      };
      
      renderDetailPanel();
    }
    
    async function executeTransferDriverShift(targetDriverId) {
      if (!transferringShift || transferringShift.type !== 'driver') return;
      
      const sourceDriver = drivers.find(d => d.id === transferringShift.sourceId);
      const targetDriver = drivers.find(d => d.id === targetDriverId);
      const shift = transferringShift.shift;
      
      // If real data mode, call API to persist
      if (dataSource === 'real' && shift.entryId) {
        try {
          const result = await apiRequest('/dispatch/transfer', {
            method: 'POST',
            body: {
              roster_entry_id: shift.entryId,
              to_driver_id: targetDriverId
            }
          });
          
          if (result.error) {
            showToast(result.error, 'error');
            return;
          }
          
          showToast(`${shift.name} transferred to ${targetDriver.name}`);
          transferringShift = null;
          selectedItem = null;  // Clear selection before reload
          await loadDispatchData();  // Reload from API
          return;
        } catch (err) {
          showToast(err.message || 'Transfer failed', 'error');
          return;
        }
      }
      
      // Fake data mode - just update local arrays
      // Unsync all vehicle assignments before clearing them
      shift.duties.forEach(duty => {
        if (duty.vehicle) {
          unsyncVehicleSchedule(duty.vehicle, duty.id);
        }
      });
      
      // Remove from source
      sourceDriver.shifts.splice(transferringShift.shiftIdx, 1);
      if (sourceDriver.shifts.length === 0) {
        sourceDriver.status = 'available';
      }
      
      // Add to target (keep same duties but clear vehicle assignments)
      const newShift = {
        ...shift,
        id: `shift-transferred-${Date.now()}`,
        duties: shift.duties.map(d => ({ ...d, vehicle: null }))
      };
      targetDriver.shifts.push(newShift);
      targetDriver.shifts.sort((a, b) => a.start - b.start);
      targetDriver.status = 'working';
      
      showToast(`${shift.name} transferred to ${targetDriver.name}`);
      
      transferringShift = null;
      selectedItem = { type: 'driver', index: drivers.indexOf(targetDriver) };
      renderAll();
    }
    
    async function unassignDriverShift(driverId, shiftIdx) {
      const driver = drivers.find(d => d.id === driverId);
      const shift = driver.shifts[shiftIdx];
      
      // If real data mode, call API to persist
      if (dataSource === 'real' && shift.entryId) {
        try {
          const result = await apiRequest('/dispatch/unassign', {
            method: 'POST',
            body: {
              roster_entry_id: shift.entryId,
              unassign: 'driver'
            }
          });
          
          if (result.error) {
            showToast(result.error, 'error');
            return;
          }
          
          showToast(`${shift.name} moved to unassigned`);
          selectedItem = null;  // Clear selection before reload
          await loadDispatchData();  // Reload from API
          return;
        } catch (err) {
          showToast(err.message || 'Unassign failed', 'error');
          return;
        }
      }
      
      // Fake data mode - just update local arrays
      // Unsync all vehicle assignments from this shift
      shift.duties.forEach(duty => {
        if (duty.vehicle) {
          unsyncVehicleSchedule(duty.vehicle, duty.id);
        }
      });
      
      // Create unassigned job from shift
      const job = {
        id: `JOB-${Date.now()}`,
        name: shift.name,
        type: shift.type,
        start: shift.start,
        end: shift.end,
        depot: driver.depot,
        customer: shift.type === 'charter' ? 'Unassigned' : null,
        duties: shift.duties.map(d => ({ ...d, vehicle: null }))
      };
      
      unassignedJobs.push(job);
      
      // Remove from driver
      driver.shifts.splice(shiftIdx, 1);
      if (driver.shifts.length === 0) {
        driver.status = 'available';
      }
      
      showToast(`${shift.name} moved to unassigned`);
      renderAll();
    }
    
    // Vehicle shift transfer
    function showTransferVehicleShift(vehicleId, shiftIdx) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      const shift = vehicle.shifts[shiftIdx];
      
      transferringShift = {
        type: 'vehicle',
        sourceId: vehicleId,
        shiftIdx: shiftIdx,
        shift: shift
      };
      
      renderDetailPanel();
    }
    
    function executeTransferVehicleShift(targetVehicleId) {
      if (!transferringShift || transferringShift.type !== 'vehicle') return;
      
      const sourceVehicle = vehicles.find(v => v.id === transferringShift.sourceId);
      const targetVehicle = vehicles.find(v => v.id === targetVehicleId);
      const shift = transferringShift.shift;
      
      // Remove from source
      sourceVehicle.shifts.splice(transferringShift.shiftIdx, 1);
      if (sourceVehicle.shifts.filter(s => s.type !== 'maintenance').length === 0) {
        sourceVehicle.status = 'available';
      }
      
      // Add to target (keep same duties but clear driver assignments)
      const newShift = {
        ...shift,
        id: `vshift-transferred-${Date.now()}`,
        duties: shift.duties.map(d => ({ ...d, driver: null, driverId: null }))
      };
      targetVehicle.shifts.push(newShift);
      targetVehicle.shifts.sort((a, b) => a.start - b.start);
      targetVehicle.status = 'inuse';
      
      showToast(`${shift.name} transferred to ${targetVehicle.id}`);
      
      transferringShift = null;
      selectedItem = { type: 'vehicle', index: vehicles.indexOf(targetVehicle) };
      renderAll();
    }
    
    function unassignVehicleShift(vehicleId, shiftIdx) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      const shift = vehicle.shifts[shiftIdx];
      
      // Create unassigned job from shift
      const job = {
        id: `JOB-${Date.now()}`,
        name: shift.name,
        type: shift.type,
        start: shift.start,
        end: shift.end,
        depot: vehicle.depot,
        customer: shift.type === 'charter' ? 'Unassigned' : null,
        duties: shift.duties.map(d => ({ ...d, driver: null, driverId: null }))
      };
      
      unassignedJobs.push(job);
      
      // Remove from vehicle
      vehicle.shifts.splice(shiftIdx, 1);
      if (vehicle.shifts.filter(s => s.type !== 'maintenance').length === 0) {
        vehicle.status = 'available';
      }
      
      showToast(`${shift.name} moved to unassigned`);
      renderAll();
    }
    
    function cancelTransfer() {
      transferringShift = null;
      renderDetailPanel();
    }
    
    // Bulk assign vehicle to all unassigned duties in a driver's shift
    function showBulkAssignVehicle(driverId, shiftId) {
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === shiftId);
      if (!shift) return;
      
      // Find duties that need a vehicle but don't have one
      const unassignedDuties = shift.duties.filter(d => 
        VEHICLE_REQUIRED_TYPES.includes(d.type) && !d.vehicle
      );
      
      if (unassignedDuties.length === 0) {
        showToast('All duties already have vehicles assigned');
        return;
      }
      
      bulkAssigning = {
        type: 'vehicle',
        driverId,
        shiftId,
        shift,
        unassignedDuties
      };
      
      renderDetailPanel();
    }
    
    function renderBulkAssignVehiclePanel() {
      if (!bulkAssigning || bulkAssigning.type !== 'vehicle') return '';
      
      // Find vehicles available for all the unassigned duty periods
      const availableVehicles = getVehiclesAvailableForDuties(bulkAssigning.unassignedDuties);
      
      return `
        <div class="bulk-assign-panel">
          <div class="bulk-assign-header">
            <span class="bulk-assign-title">Assign Vehicle to ${bulkAssigning.unassignedDuties.length} Duties</span>
            <button class="bulk-assign-close" onclick="cancelBulkAssign()"></button>
          </div>
          <div class="bulk-assign-info">
            Select a vehicle to assign to all unassigned duties in this shift.
            Only showing vehicles available for all time periods.
          </div>
          <div class="assignment-panel">
            <div class="assignment-search">
              <input type="text" class="assignment-search-input" id="bulkVehicleSearch" 
                     placeholder="Search vehicles..." oninput="updateBulkVehicleList()">
            </div>
            <div class="assignment-count" id="bulkVehicleCount">${availableVehicles.length} vehicle(s) available</div>
            <div class="assignment-list" id="bulkVehicleList"></div>
          </div>
        </div>
      `;
    }
    
    function updateBulkVehicleList() {
      if (!bulkAssigning || bulkAssigning.type !== 'vehicle') return;
      
      const search = document.getElementById('bulkVehicleSearch')?.value?.toLowerCase() || '';
      
      let availableVehicles = getVehiclesAvailableForDuties(bulkAssigning.unassignedDuties);
      
      if (search) {
        availableVehicles = availableVehicles.filter(v => 
          v.id.toLowerCase().includes(search) || 
          v.rego.toLowerCase().includes(search)
        );
      }
      
      const countEl = document.getElementById('bulkVehicleCount');
      if (countEl) {
        countEl.textContent = `${availableVehicles.length} vehicle(s) available for all ${bulkAssigning.unassignedDuties.length} duties`;
      }
      
      const listEl = document.getElementById('bulkVehicleList');
      if (listEl) {
        if (availableVehicles.length === 0) {
          listEl.innerHTML = '<div class="assignment-empty">No vehicles available for all time periods</div>';
        } else {
          listEl.innerHTML = availableVehicles.map(v => {
            const vehicleIdx = vehicles.indexOf(v);
            return `
            <div class="assignment-item">
              <div class="assignment-item-info">
                <span class="assignment-item-name clickable" onclick="navigateToResource('vehicle', ${vehicleIdx})">${v.id}</span>
                <span class="assignment-item-detail">${v.capacity} seats  ${v.rego}</span>
              </div>
              <button class="assign-btn" onclick="executeBulkAssignVehicle('${v.id}')">Assign All</button>
            </div>
          `}).join('');
        }
      }
    }
    
    async function executeBulkAssignVehicle(vehicleId) {
      if (!bulkAssigning || bulkAssigning.type !== 'vehicle') return;
      
      const driver = drivers.find(d => d.id === bulkAssigning.driverId);
      if (!driver) return;
      
      const shift = driver.shifts.find(s => s.id === bulkAssigning.shiftId);
      if (!shift) return;
      
      // Find duties that need vehicles
      const dutiesToAssign = shift.duties.filter(duty => 
        VEHICLE_REQUIRED_TYPES.includes(duty.type) && !duty.vehicle
      );
      
      if (dutiesToAssign.length === 0) {
        showToast('No duties to assign');
        bulkAssigning = null;
        return;
      }
      
      // Call API for each duty in real mode
      if (dataSource === 'real') {
        try {
          const promises = dutiesToAssign
            .filter(duty => duty.id && !duty.id.startsWith('placeholder-') && !duty.id.startsWith('d-'))
            .map(duty => apiRequest('/dispatch/update-duty-line', {
              method: 'POST',
              body: {
                duty_line_id: duty.id,
                vehicle_number: vehicleId
              }
            }));
          
          await Promise.all(promises);
        } catch (err) {
          showToast(err.message || 'Bulk assign failed', 'error');
          bulkAssigning = null;
          return;
        }
      }
      
      // Update local state
      dutiesToAssign.forEach(duty => {
        duty.vehicle = vehicleId;
        syncVehicleSchedule(vehicleId, duty, driver);
      });
      
      // Update vehicle status if needed
      const vehicle = vehicles.find(v => v.id === vehicleId);
      if (vehicle && vehicle.status === 'available') {
        vehicle.status = 'inuse';
      }
      
      bulkAssigning = null;
      showToast(`Assigned ${vehicleId} to ${dutiesToAssign.length} duties`);
      renderAll();
    }
    
    // Bulk assign driver to all unassigned duties in a vehicle's shift
    function showBulkAssignDriver(vehicleId, shiftId) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      if (!vehicle) return;
      
      const shift = vehicle.shifts.find(s => s.id === shiftId);
      if (!shift) return;
      
      // Find duties that need a driver but don't have one
      const unassignedDuties = shift.duties.filter(d => 
        DRIVER_REQUIRED_TYPES.includes(d.type) && !d.driver
      );
      
      if (unassignedDuties.length === 0) {
        showToast('All duties already have drivers assigned');
        return;
      }
      
      bulkAssigning = {
        type: 'driver',
        vehicleId,
        shiftId,
        shift,
        unassignedDuties
      };
      
      renderDetailPanel();
    }
    
    function renderBulkAssignDriverPanel() {
      if (!bulkAssigning || bulkAssigning.type !== 'driver') return '';
      
      // Find drivers available for all the unassigned duty periods
      const availableDrivers = getDriversAvailableForDuties(bulkAssigning.unassignedDuties);
      
      return `
        <div class="bulk-assign-panel">
          <div class="bulk-assign-header">
            <span class="bulk-assign-title">Assign Driver to ${bulkAssigning.unassignedDuties.length} Duties</span>
            <button class="bulk-assign-close" onclick="cancelBulkAssign()"></button>
          </div>
          <div class="bulk-assign-info">
            Select a driver to assign to all unassigned duties in this shift.
            Only showing drivers available for all time periods.
          </div>
          <div class="assignment-panel">
            <div class="assignment-search">
              <input type="text" class="assignment-search-input" id="bulkDriverSearch" 
                     placeholder="Search drivers..." oninput="updateBulkDriverList()">
            </div>
            <div class="assignment-count" id="bulkDriverCount">${availableDrivers.length} driver(s) available</div>
            <div class="assignment-list" id="bulkDriverList"></div>
          </div>
        </div>
      `;
    }
    
    function updateBulkDriverList() {
      if (!bulkAssigning || bulkAssigning.type !== 'driver') return;
      
      const search = document.getElementById('bulkDriverSearch')?.value?.toLowerCase() || '';
      
      let availableDrivers = getDriversAvailableForDuties(bulkAssigning.unassignedDuties);
      
      if (search) {
        availableDrivers = availableDrivers.filter(d => 
          d.name.toLowerCase().includes(search) || 
          d.fullName.toLowerCase().includes(search) ||
          d.id.toLowerCase().includes(search)
        );
      }
      
      const countEl = document.getElementById('bulkDriverCount');
      if (countEl) {
        countEl.textContent = `${availableDrivers.length} driver(s) available for all ${bulkAssigning.unassignedDuties.length} duties`;
      }
      
      const listEl = document.getElementById('bulkDriverList');
      if (listEl) {
        if (availableDrivers.length === 0) {
          listEl.innerHTML = '<div class="assignment-empty">No drivers available for all time periods</div>';
        } else {
          listEl.innerHTML = availableDrivers.map(d => {
            const driverIdx = drivers.indexOf(d);
            return `
            <div class="assignment-item">
              <div class="assignment-item-info">
                <span class="assignment-item-name clickable" onclick="navigateToResource('driver', ${driverIdx})">${d.fullName}</span>
                <span class="assignment-item-detail">${d.id}</span>
              </div>
              <button class="assign-btn" onclick="executeBulkAssignDriver('${d.id}')">Assign All</button>
            </div>
          `}).join('');
        }
      }
    }
    
    function executeBulkAssignDriver(driverId) {
      if (!bulkAssigning || bulkAssigning.type !== 'driver') return;
      
      const vehicle = vehicles.find(v => v.id === bulkAssigning.vehicleId);
      if (!vehicle) return;
      
      const shift = vehicle.shifts.find(s => s.id === bulkAssigning.shiftId);
      if (!shift) return;
      
      const driver = drivers.find(d => d.id === driverId);
      if (!driver) return;
      
      let assignedCount = 0;
      
      // Assign driver to all unassigned duties
      shift.duties.forEach(duty => {
        if (DRIVER_REQUIRED_TYPES.includes(duty.type) && !duty.driver) {
          duty.driver = driver.name;
          duty.driverId = driver.id;
          assignedCount++;
        }
      });
      
      // Update driver status if needed
      if (driver.status === 'available') {
        driver.status = 'working';
      }
      
      bulkAssigning = null;
      showToast(`Assigned ${driver.name} to ${assignedCount} duties`);
      renderAll();
    }
    
    function cancelBulkAssign() {
      bulkAssigning = null;
      renderDetailPanel();
    }
    
    // Get vehicles available for all specified duty periods
    function getVehiclesAvailableForDuties(duties) {
      return vehicles.filter(v => {
        if (v.status === 'maintenance') return false;
        
        // Check each duty period for conflicts with existing vehicle assignments
        for (const duty of duties) {
          if (!isVehicleAvailableForDuty(v.id, duty.start, duty.end)) {
            return false;
          }
        }
        
        return true;
      });
    }
    
    // Get drivers available for all specified duty periods
    function getDriversAvailableForDuties(duties) {
      return drivers.filter(d => {
        if (d.status === 'leave') return false;
        
        // Check each duty period for conflicts
        for (const duty of duties) {
          const dutyStartMins = toMinutes(duty.start);
          const dutyEndMins = toMinutes(duty.end);
          
          // Check against all driver shifts
          for (const shift of d.shifts || []) {
            const shiftStartMins = toMinutes(shift.start);
            const shiftEndMins = toMinutes(shift.end);
            
            if (dutyStartMins < shiftEndMins && dutyEndMins > shiftStartMins) {
              return false; // Overlap found
            }
          }
        }
        
        return true;
      });
    }
    
    // Get drivers available for a specific time period (for transfer or multiple job assignment)
    function getDriversAvailableForShift(shift, excludeDriverId = null) {
      return drivers.filter(d => {
        if (d.id === excludeDriverId) return false;
        if (d.status === 'leave') return false;
        
        // Check if driver has any overlapping shifts
        const shiftStartMins = toMinutes(shift.start);
        const shiftEndMins = toMinutes(shift.end);
        
        for (const existingShift of d.shifts) {
          const existingStartMins = toMinutes(existingShift.start);
          const existingEndMins = toMinutes(existingShift.end);
          
          if (shiftStartMins < existingEndMins && shiftEndMins > existingStartMins) {
            return false; // Overlap found
          }
        }
        
        return true;
      });
    }
    
    // Get vehicles available for a specific time period
    function getVehiclesAvailableForShift(shift, excludeVehicleId = null) {
      return vehicles.filter(v => {
        if (v.id === excludeVehicleId) return false;
        if (v.status === 'maintenance') return false;
        
        // Check if vehicle has any overlapping shifts
        const shiftStartMins = toMinutes(shift.start);
        const shiftEndMins = toMinutes(shift.end);
        
        for (const existingShift of v.shifts) {
          if (existingShift.type === 'maintenance') continue;
          const existingStartMins = toMinutes(existingShift.start);
          const existingEndMins = toMinutes(existingShift.end);
          
          if (shiftStartMins < existingEndMins && shiftEndMins > existingStartMins) {
            return false; // Overlap found
          }
        }
        
        return true;
      });
    }
    
    function generateVehicleDutiesWithoutDrivers(shiftStart, shiftEnd, isCharter = false) {
      const duties = [];
      let currentTime = shiftStart;
      
      if (isCharter) {
        const pickupLoc = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
        const destLoc = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
        
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'dead', start: currentTime, end: currentTime + 0.5, description: `Dead run to ${pickupLoc}`, driver: null, driverId: null });
        currentTime += 0.5;
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: `Charter pickup`, driver: null, driverId: null });
        currentTime += 0.25;
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: currentTime + 1, description: `${pickupLoc}  ${destLoc}`, driver: null, driverId: null });
        currentTime += 1;
        
        if (shiftEnd - currentTime > 2) {
          duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'waiting', start: currentTime, end: shiftEnd - 1.25, description: `Waiting at ${destLoc}`, driver: null, driverId: null });
          currentTime = shiftEnd - 1.25;
        }
        
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: currentTime + 0.75, description: `Return to ${pickupLoc}`, driver: null, driverId: null });
        currentTime += 0.75;
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'dead', start: currentTime, end: shiftEnd, description: `Dead run to depot`, driver: null, driverId: null });
      } else {
        const route = ROUTES[Math.floor(Math.random() * ROUTES.length)];
        const totalDuration = shiftEnd - shiftStart;
        
        // Sign on, pre-trip
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: 'Sign on, pre-trip', driver: null, driverId: null });
        currentTime += 0.25;
        
        // First drive
        const firstDriveEnd = currentTime + Math.min(2 + Math.random(), (shiftEnd - currentTime) / 2);
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: firstDriveEnd, description: `${route} - Outbound`, driver: null, driverId: null });
        currentTime = firstDriveEnd;
        
        // Turnaround
        duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: 'Turnaround', driver: null, driverId: null });
        currentTime += 0.25;
        
        // Second drive
        const secondDriveEnd = currentTime + Math.min(2, shiftEnd - currentTime - 1.5);
        if (secondDriveEnd > currentTime + 0.5) {
          duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: secondDriveEnd, description: `${route} - Inbound`, driver: null, driverId: null });
          currentTime = secondDriveEnd;
        }
        
        // Meal break if shift is long enough
        if (totalDuration > 4 && currentTime < shiftEnd - 1.5) {
          duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'break', start: currentTime, end: currentTime + 0.5, description: 'Meal break', driver: null, driverId: null });
          currentTime += 0.5;
          
          // Final drive after break
          if (currentTime < shiftEnd - 0.5) {
            duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'driving', start: currentTime, end: shiftEnd - 0.25, description: `${route} - Final`, driver: null, driverId: null });
            currentTime = shiftEnd - 0.25;
          }
        }
        
        // Sign off
        if (currentTime < shiftEnd) {
          duties.push({ id: `vd-${Date.now()}-${Math.random()}`, type: 'oov', start: currentTime, end: shiftEnd, description: 'Sign off', driver: null, driverId: null });
        }
      }
      
      return duties;
    }
    
    // Vehicle-centric edit functions
    function editVehicleDuty(vehicleId, shiftId, dutyIdx) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      const shift = vehicle.shifts.find(s => s.id === shiftId);
      const duty = shift.duties[dutyIdx];
      
      editingDuty = { 
        vehicleId, 
        shiftId, 
        dutyIdx, 
        duty: { ...duty }, 
        shift, 
        isNew: false,
        isVehicleCentric: true
      };
      formErrors = {};
      renderDetailPanel();
    }
    
    function deleteVehicleDuty(vehicleId, shiftId, dutyIdx) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      const shift = vehicle.shifts.find(s => s.id === shiftId);
      shift.duties.splice(dutyIdx, 1);
      showToast('Duty deleted');
      renderAll();
    }
    
    function showAddVehicleDutyForm(vehicleId) {
      const vehicle = vehicles.find(v => v.id === vehicleId);
      if (!vehicle) return;
      
      const dayStart = 5;
      const dayEnd = 23;
      const allSlots = findAllAvailableVehicleSlots(vehicle, dayStart, dayEnd);
      
      if (allSlots.length === 0) {
        showToast('No available time slots today', true);
        return;
      }
      
      const firstSlot = allSlots[0];
      const duration = Math.min(0.5, firstSlot.end - firstSlot.start);
      
      const containingShift = vehicle.shifts.find(s => s.start <= firstSlot.start && s.end >= firstSlot.start + duration);
      
      editingDuty = {
        vehicleId, 
        shiftId: containingShift ? containingShift.id : null,
        dutyIdx: containingShift ? containingShift.duties.length : 0,
        duty: { 
          id: `vd-new-${Date.now()}`, 
          type: 'driving', 
          start: firstSlot.start, 
          end: firstSlot.start + duration, 
          description: 'New duty', 
          driver: null,
          driverId: null
        },
        shift: containingShift || null,
        isNew: true,
        isAdhoc: !containingShift,
        isVehicleCentric: true,
        allSlots: allSlots
      };
      formErrors = {};
      renderDetailPanel();
    }
    
    function findAllAvailableVehicleSlots(vehicle, dayStart, dayEnd, minDuration = 0.25) {
      const slots = [];
      const minDurationMins = toMinutes(minDuration);
      
      const occupiedPeriods = [];
      vehicle.shifts.forEach(shift => {
        shift.duties.forEach(duty => {
          occupiedPeriods.push({ start: duty.start, end: duty.end });
        });
      });
      
      occupiedPeriods.sort((a, b) => a.start - b.start);
      
      let currentTime = dayStart;
      
      for (const period of occupiedPeriods) {
        const gapMins = toMinutes(period.start) - toMinutes(currentTime);
        if (gapMins >= minDurationMins) {
          slots.push({ start: currentTime, end: period.start });
        }
        currentTime = Math.max(currentTime, period.end);
      }
      
      const endGapMins = toMinutes(dayEnd) - toMinutes(currentTime);
      if (endGapMins >= minDurationMins) {
        slots.push({ start: currentTime, end: dayEnd });
      }
      
      return slots;
    }
    
    function isDriverAvailableForPeriod(driver, start, end) {
      if (driver.status === 'leave') return false;
      
      const startMins = toMinutes(start);
      const endMins = toMinutes(end);
      
      for (const shift of driver.shifts) {
        for (const duty of shift.duties) {
          if (duty.cancelled) continue; // Skip cancelled duties
          const dStartMins = toMinutes(duty.start);
          const dEndMins = toMinutes(duty.end);
          if (dStartMins < endMins && dEndMins > startMins) {
            return false;
          }
        }
      }
      
      return true;
    }
    
    function getAvailableDriversForPeriod(start, end) {
      return drivers.filter(d => isDriverAvailableForPeriod(d, start, end));
    }
    
    function renderVehicleEditForm() {
      if (!editingDuty || !editingDuty.isVehicleCentric) return '';
      
      const duty = editingDuty.duty;
      const shift = editingDuty.shift;
      const isNew = editingDuty.isNew;
      const isAdhoc = editingDuty.isAdhoc;
      const needsDriver = DRIVER_REQUIRED_TYPES.includes(duty.type);
      
      const availableSlots = isNew ? (editingDuty.allSlots || []) : [];
      const availableDrivers = getAvailableDriversForPeriod(duty.start, duty.end);
      
      // Include currently assigned driver if editing
      const driverOptions = [...availableDrivers];
      if (duty.driverId && !driverOptions.find(d => d.id === duty.driverId)) {
        const existingDriver = drivers.find(d => d.id === duty.driverId);
        if (existingDriver) driverOptions.unshift(existingDriver);
      }
      
      const hasErrors = Object.keys(formErrors).length > 0;
      
      // Check if duty will extend shift bounds
      let shiftExtensionHint = '';
      if (shift && !isAdhoc) {
        const willExtendStart = duty.start < shift.start;
        const willExtendEnd = duty.end > shift.end;
        if (willExtendStart && willExtendEnd) {
          shiftExtensionHint = ` Block will extend from ${formatTime(shift.start)}-${formatTime(shift.end)} to ${formatTime(duty.start)}-${formatTime(duty.end)}`;
        } else if (willExtendStart) {
          shiftExtensionHint = ` Block start will extend from ${formatTime(shift.start)} to ${formatTime(duty.start)}`;
        } else if (willExtendEnd) {
          shiftExtensionHint = ` Block end will extend from ${formatTime(shift.end)} to ${formatTime(duty.end)}`;
        }
      }
      
      return `
        <div class="edit-form">
          <div class="edit-form-title">
            ${isNew ? (isAdhoc ? ' Add Adhoc Duty' : ' Add New Duty') : ' Edit Duty'}
            ${isAdhoc ? '<span style="font-size: 10px; color: var(--accent-amber); margin-left: 8px;">(Creates new block)</span>' : ''}
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Start Time</label>
              <input type="text" class="form-input ${formErrors.time || formErrors.overlap ? 'error' : ''}" 
                     id="editStart" value="${formatTime(duty.start)}" 
                     placeholder="HH:MM" maxlength="5"
                     oninput="formatTimeInput(this)" onchange="onVehicleFormChange()">
            </div>
            <div class="form-group">
              <label class="form-label">End Time</label>
              <input type="text" class="form-input ${formErrors.time || formErrors.overlap ? 'error' : ''}" 
                     id="editEnd" value="${formatTime(duty.end)}" 
                     placeholder="HH:MM" maxlength="5"
                     oninput="formatTimeInput(this)" onchange="onVehicleFormChange()">
            </div>
          </div>
          
          ${formErrors.time ? `<div class="form-error"> ${formErrors.time}</div>` : ''}
          ${formErrors.overlap ? `<div class="form-error"> ${formErrors.overlap}</div>` : ''}
          ${shiftExtensionHint ? `<div class="form-hint" style="color: var(--accent-blue);">${shiftExtensionHint}</div>` : ''}
          
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Duty Type</label>
              <select class="form-select" id="editType" onchange="onVehicleFormChange()">
                ${Object.entries(DUTY_TYPES).map(([k, v]) => `
                  <option value="${k}" ${duty.type === k ? 'selected' : ''}>${v.label} - ${v.name}</option>
                `).join('')}
              </select>
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Description</label>
              <input type="text" class="form-input" id="editDesc" value="${duty.description}" placeholder="Enter description...">
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Location <span style="font-size: 10px; color: var(--text-muted);">(optional - for smart assignment)</span></label>
              <div class="location-input-wrapper">
                <input type="text" class="form-input" id="editLocation" 
                       value="${duty.locationName || ''}" 
                       placeholder="Start typing to search or enter free text..."
                       oninput="onLocationInput('editLocation')"
                       onfocus="onLocationInput('editLocation')">
                <input type="hidden" id="editLocationLat" value="${duty.locationLat || ''}">
                <input type="hidden" id="editLocationLng" value="${duty.locationLng || ''}">
              </div>
              ${duty.locationLat && duty.locationLng ? 
                `<div class="location-coords"> ${Number(duty.locationLat).toFixed(4)}, ${Number(duty.locationLng).toFixed(4)}</div>` : 
                ''}
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">
                Driver ${needsDriver ? '<span class="required">*</span>' : ''}
              </label>
              <select class="form-select ${formErrors.driver ? 'error' : ''}" id="editDriver" onchange="onVehicleFormChange()">
                <option value="">-- No Driver --</option>
                ${driverOptions.map(d => `
                  <option value="${d.id}" ${duty.driverId === d.id ? 'selected' : ''}>${d.name} (${d.fullName})</option>
                `).join('')}
              </select>
              ${driverOptions.length === 0 && needsDriver ? 
                `<div class="form-hint">No drivers available for this time period</div>` : 
                `<div class="form-hint">${driverOptions.length} driver(s) available for ${formatTime(duty.start)}-${formatTime(duty.end)}</div>`
              }
            </div>
          </div>
          
          ${formErrors.driver ? `<div class="form-error"> ${formErrors.driver}</div>` : ''}
          
          ${isNew && availableSlots.length > 0 ? `
            <div class="available-slots">
              <div class="available-slots-label"> Available time slots:</div>
              <div class="slot-chips">
                ${availableSlots.map(s => `
                  <span class="slot-chip" onclick="fillVehicleSlot(${s.start}, ${s.end})">${formatTime(s.start)} - ${formatTime(s.end)}</span>
                `).join('')}
              </div>
            </div>
          ` : ''}
          
          <div class="form-actions">
            <button class="form-btn cancel" onclick="cancelEdit()">Cancel</button>
            <button class="form-btn save" id="saveBtn" onclick="saveVehicleEdit()" ${hasErrors ? 'disabled' : ''}>
              ${isNew ? (isAdhoc ? 'Create Adhoc' : 'Add Duty') : 'Save Changes'}
            </button>
          </div>
        </div>
      `;
    }
    
    function fillVehicleSlot(start, end) {
      if (!editingDuty) return;
      
      const duration = Math.min(0.5, end - start);
      editingDuty.duty.start = start;
      editingDuty.duty.end = start + duration;
      
      const vehicle = vehicles.find(v => v.id === editingDuty.vehicleId);
      const containingShift = vehicle.shifts.find(s => s.start <= start && s.end >= start + duration);
      
      editingDuty.shift = containingShift || null;
      editingDuty.shiftId = containingShift ? containingShift.id : null;
      editingDuty.isAdhoc = !containingShift;
      
      formErrors = {};
      renderDetailPanel();
    }
    
    function onVehicleFormChange() {
      if (!editingDuty || !editingDuty.isVehicleCentric) return;
      
      const startStr = document.getElementById('editStart')?.value;
      const endStr = document.getElementById('editEnd')?.value;
      const type = document.getElementById('editType')?.value;
      const driverId = document.getElementById('editDriver')?.value || null;
      
      const start = parseTime(startStr);
      const end = parseTime(endStr);
      
      const selectedDriver = driverId ? drivers.find(d => d.id === driverId) : null;
      
      editingDuty.duty.start = start;
      editingDuty.duty.end = end;
      editingDuty.duty.type = type;
      editingDuty.duty.driverId = driverId;
      editingDuty.duty.driver = selectedDriver ? selectedDriver.name : null;
      
      if (editingDuty.isNew) {
        const vehicle = vehicles.find(v => v.id === editingDuty.vehicleId);
        const containingShift = vehicle.shifts.find(s => s.start <= start && s.end >= end);
        editingDuty.shift = containingShift || null;
        editingDuty.shiftId = containingShift ? containingShift.id : null;
        editingDuty.isAdhoc = !containingShift;
      }
      
      // Validate
      const vehicle = vehicles.find(v => v.id === editingDuty.vehicleId);
      
      if (editingDuty.isAdhoc || !editingDuty.shift) {
        const allDuties = vehicle.shifts.flatMap(s => s.duties);
        // Exclude current duty from overlap check
        formErrors = validateVehicleDutyForm({ start, end, type, driverId }, allDuties, editingDuty.duty.id);
      } else {
        // Always exclude the duty being edited
        const excludeId = editingDuty.duty.id;
        formErrors = validateVehicleDutyFormInShift(
          { start, end, type, driverId }, 
          editingDuty.shift.duties, 
          editingDuty.shift.start, 
          editingDuty.shift.end, 
          excludeId
        );
      }
      
      renderDetailPanel();
    }
    
    function validateVehicleDutyForm(data, allDuties, excludeId = null) {
      const errors = {};
      
      if (isNaN(data.start) || isNaN(data.end)) {
        errors.time = 'Invalid time format (use HH:MM or HHMM, e.g., 07:30 or 0730)';
        return errors;
      }
      
      if (data.start < 0 || data.start > 24 || data.end < 0 || data.end > 24) {
        errors.time = 'Time must be between 00:00 and 24:00';
        return errors;
      }
      
      const startMins = toMinutes(data.start);
      const endMins = toMinutes(data.end);
      
      if (startMins >= endMins) {
        errors.time = 'End time must be after start time';
        return errors;
      }
      
      const overlap = allDuties.find(d => {
        if (excludeId && d.id === excludeId) return false; // Skip the duty being edited
        const dStartMins = toMinutes(d.start);
        const dEndMins = toMinutes(d.end);
        return (startMins < dEndMins && endMins > dStartMins);
      });
      
      if (overlap) {
        errors.overlap = `Overlaps with duty at ${formatTime(overlap.start)}-${formatTime(overlap.end)}`;
      }
      
      // Driver is optional for all duty types
      
      return errors;
    }
    
    function validateVehicleDutyFormInShift(data, duties, shiftStart, shiftEnd, excludeId) {
      const errors = {};
      
      if (isNaN(data.start) || isNaN(data.end)) {
        errors.time = 'Invalid time format (use HH:MM or HHMM, e.g., 07:30 or 0730)';
        return errors;
      }
      
      if (data.start < 0 || data.start > 24 || data.end < 0 || data.end > 24) {
        errors.time = 'Time must be between 00:00 and 24:00';
        return errors;
      }
      
      const startMins = toMinutes(data.start);
      const endMins = toMinutes(data.end);
      
      if (startMins >= endMins) {
        errors.time = 'End time must be after start time';
        return errors;
      }
      
      // No longer enforce shift boundaries - shift will auto-extend to fit duties
      
      const overlap = duties.find(d => {
        if (d.id === excludeId) return false;
        const dStartMins = toMinutes(d.start);
        const dEndMins = toMinutes(d.end);
        return (startMins < dEndMins && endMins > dStartMins);
      });
      
      if (overlap) {
        errors.overlap = `Overlaps with duty at ${formatTime(overlap.start)}-${formatTime(overlap.end)}`;
      }
      
      // Driver is optional for all duty types
      
      return errors;
    }
    
    function saveVehicleEdit() {
      if (!editingDuty || !editingDuty.isVehicleCentric) return;
      
      const startStr = document.getElementById('editStart')?.value;
      const endStr = document.getElementById('editEnd')?.value;
      const type = document.getElementById('editType')?.value;
      const driverId = document.getElementById('editDriver')?.value || null;
      const description = document.getElementById('editDesc')?.value || '';
      const locationName = document.getElementById('editLocation')?.value || null;
      const locationLat = parseFloat(document.getElementById('editLocationLat')?.value) || null;
      const locationLng = parseFloat(document.getElementById('editLocationLng')?.value) || null;
      
      const start = parseTime(startStr);
      const end = parseTime(endStr);
      
      const selectedDriver = driverId ? drivers.find(d => d.id === driverId) : null;
      
      const vehicle = vehicles.find(v => v.id === editingDuty.vehicleId);
      
      // Final validation
      if (editingDuty.isAdhoc || !editingDuty.shift) {
        const allDuties = vehicle.shifts.flatMap(s => s.duties);
        // Exclude current duty from overlap check
        formErrors = validateVehicleDutyForm({ start, end, type, driverId }, allDuties, editingDuty.duty.id);
      } else {
        // Always exclude the duty being edited
        const excludeId = editingDuty.duty.id;
        formErrors = validateVehicleDutyFormInShift(
          { start, end, type, driverId }, 
          editingDuty.shift.duties, 
          editingDuty.shift.start, 
          editingDuty.shift.end, 
          excludeId
        );
      }
      
      if (Object.keys(formErrors).length > 0) {
        renderDetailPanel();
        return;
      }
      
      const updatedDuty = { 
        id: editingDuty.duty.id, 
        type, 
        start, 
        end, 
        description, 
        driver: selectedDriver ? selectedDriver.name : null,
        driverId: driverId,
        locationName,
        locationLat,
        locationLng
      };
      
      if (editingDuty.isNew) {
        if (editingDuty.isAdhoc || !editingDuty.shift) {
          const newShift = {
            id: `vshift-adhoc-${Date.now()}`,
            name: `ADHOC ${String(Math.floor(Math.random() * 900) + 100)}`,
            type: 'adhoc',
            start: start,
            end: end,
            duties: [updatedDuty]
          };
          vehicle.shifts.push(newShift);
          vehicle.shifts.sort((a, b) => a.start - b.start);
          
          if (vehicle.status === 'available') {
            vehicle.status = 'inuse';
          }
          
          showToast('Adhoc duty created');
        } else {
          editingDuty.shift.duties.push(updatedDuty);
          editingDuty.shift.duties.sort((a, b) => a.start - b.start);
          
          // Auto-extend shift boundaries to fit the new duty
          updateShiftBounds(editingDuty.shift);
          
          showToast('Duty added successfully');
        }
      } else {
        const shift = vehicle.shifts.find(s => s.id === editingDuty.shiftId);
        shift.duties[editingDuty.dutyIdx] = updatedDuty;
        shift.duties.sort((a, b) => a.start - b.start);
        
        // Auto-extend shift boundaries to fit the updated duty
        updateShiftBounds(shift);
        
        showToast('Duty updated successfully');
      }
      
      editingDuty = null;
      formErrors = {};
      
      renderAll();
    }
    
    function generateDutiesWithoutVehicles(shiftStart, shiftEnd, isCharter = false) {
      const duties = [];
      let currentTime = shiftStart;
      
      if (isCharter) {
        const pickupLoc = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
        const destLoc = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
        
        duties.push({ id: `d-${Date.now()}-1`, type: 'dead', start: currentTime, end: currentTime + 0.5, description: `Dead run to ${pickupLoc}`, vehicle: null });
        currentTime += 0.5;
        duties.push({ id: `d-${Date.now()}-2`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: `Charter pickup`, vehicle: null });
        currentTime += 0.25;
        duties.push({ id: `d-${Date.now()}-3`, type: 'driving', start: currentTime, end: currentTime + 1, description: `${pickupLoc}  ${destLoc}`, vehicle: null });
        currentTime += 1;
        
        if (shiftEnd - currentTime > 2) {
          duties.push({ id: `d-${Date.now()}-4`, type: 'waiting', start: currentTime, end: shiftEnd - 1.25, description: `Waiting at ${destLoc}`, vehicle: null });
          currentTime = shiftEnd - 1.25;
        }
        
        duties.push({ id: `d-${Date.now()}-5`, type: 'driving', start: currentTime, end: currentTime + 0.75, description: `Return to ${pickupLoc}`, vehicle: null });
        currentTime += 0.75;
        duties.push({ id: `d-${Date.now()}-6`, type: 'dead', start: currentTime, end: shiftEnd, description: `Dead run to depot`, vehicle: null });
      } else {
        const route = ROUTES[Math.floor(Math.random() * ROUTES.length)];
        const totalDuration = shiftEnd - shiftStart;
        
        duties.push({ id: `d-${Date.now()}-1`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: 'Sign on, pre-trip', vehicle: null });
        currentTime += 0.25;
        
        const firstDriveEnd = currentTime + Math.min(2 + Math.random(), (shiftEnd - currentTime) / 2);
        duties.push({ id: `d-${Date.now()}-2`, type: 'driving', start: currentTime, end: firstDriveEnd, description: `${route} - Outbound`, vehicle: null });
        currentTime = firstDriveEnd;
        
        duties.push({ id: `d-${Date.now()}-3`, type: 'oov', start: currentTime, end: currentTime + 0.25, description: 'Turnaround', vehicle: null });
        currentTime += 0.25;
        
        const secondDriveEnd = currentTime + Math.min(2, shiftEnd - currentTime - 1.5);
        if (secondDriveEnd > currentTime + 0.5) {
          duties.push({ id: `d-${Date.now()}-4`, type: 'driving', start: currentTime, end: secondDriveEnd, description: `${route} - Inbound`, vehicle: null });
          currentTime = secondDriveEnd;
        }
        
        if (totalDuration > 4 && currentTime < shiftEnd - 1.5) {
          duties.push({ id: `d-${Date.now()}-5`, type: 'break', start: currentTime, end: currentTime + 0.5, description: 'Meal break', vehicle: null });
          currentTime += 0.5;
          
          if (currentTime < shiftEnd - 0.5) {
            duties.push({ id: `d-${Date.now()}-6`, type: 'driving', start: currentTime, end: shiftEnd - 0.25, description: `${route} - Final`, vehicle: null });
            currentTime = shiftEnd - 0.25;
          }
        }
        
        if (currentTime < shiftEnd) {
          duties.push({ id: `d-${Date.now()}-7`, type: 'oov', start: currentTime, end: shiftEnd, description: 'Sign off', vehicle: null });
        }
      }
      
      return duties;
    }

    // ========================================
    // AI ASSISTANT
    // ========================================
    
    let aiConversation = [];
    
    function toggleAIAssistant() {
      const modal = document.getElementById('aiAssistant');
      const overlay = document.getElementById('aiModalOverlay');
      const isOpen = modal.classList.contains('show');
      
      modal.classList.toggle('show');
      overlay.classList.toggle('show');
      
      if (!isOpen) {
        document.getElementById('aiInput').focus();
      }
    }
    
    function getDispatchContext() {
      // Summarize current state for the AI
      const workingDrivers = drivers.filter(d => d.status === 'working');
      const availableDrivers = drivers.filter(d => d.status === 'available');
      const onLeaveDrivers = drivers.filter(d => d.status === 'leave');
      
      const inUseVehicles = vehicles.filter(v => v.status === 'inuse');
      const availableVehicles = vehicles.filter(v => v.status === 'available');
      const maintVehicles = vehicles.filter(v => v.status === 'maintenance');
      
      // Get some driver details
      const driverSummary = drivers.slice(0, 20).map(d => ({
        id: d.id,
        name: d.fullName || d.name,
        status: d.status,
        shifts: d.shifts.map(s => ({
          name: s.name,
          time: `${formatTime(s.start)}-${formatTime(s.end)}`,
          duties: s.duties.length
        }))
      }));
      
      // Get vehicle details
      const vehicleSummary = vehicles.slice(0, 20).map(v => ({
        id: v.id,
        rego: v.rego,
        capacity: v.capacity,
        status: v.status
      }));
      
      return {
        date: formatDate(currentDate),
        summary: {
          drivers: {
            total: drivers.length,
            working: workingDrivers.length,
            available: availableDrivers.length,
            onLeave: onLeaveDrivers.length
          },
          vehicles: {
            total: vehicles.length,
            inUse: inUseVehicles.length,
            available: availableVehicles.length,
            maintenance: maintVehicles.length
          },
          unassignedJobs: unassignedJobs.length
        },
        drivers: driverSummary,
        vehicles: vehicleSummary,
        unassignedJobs: unassignedJobs.map(j => ({
          id: j.id,
          name: j.name,
          time: `${formatTime(j.start)}-${formatTime(j.end)}`,
          type: j.type
        }))
      };
    }
    
    async function sendAIQuery() {
      const input = document.getElementById('aiInput');
      const query = input.value.trim();
      
      if (!query) return;
      
      input.value = '';
      input.disabled = true;
      document.querySelector('.ai-send').disabled = true;
      
      // Add user message
      addAIMessage(query, 'user');
      
      // Add loading indicator
      const loadingId = addAIMessage('', 'loading');
      
      try {
        const context = getDispatchContext();
        
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 1000,
            system: `You are Batman - the dispatch assistant. You watch over the fleet from the shadows. You help dispatchers with queries about drivers, vehicles, shifts, and scheduling.

Current dispatch data:
${JSON.stringify(context, null, 2)}

Guidelines:
- Be concise and practical - dispatchers are busy
- Occasionally use subtle Batman references (Gotham, "I'm Batman", the night, etc.) but don't overdo it
- Use Australian English (e.g., "G'day", "arvo", "rego")
- Reference specific driver names, vehicle IDs, and times when relevant
- If asked about availability, check the status fields and shift times
- Format times in 24-hour format
- If you can't find specific data, say so
- Don't make up information that isn't in the context`,
            messages: [
              ...aiConversation,
              { role: 'user', content: query }
            ]
          })
        });
        
        const data = await response.json();
        
        // Remove loading indicator
        removeAIMessage(loadingId);
        
        if (data.content && data.content[0]) {
          const reply = data.content[0].text;
          addAIMessage(reply, 'assistant');
          
          // Update conversation history (keep last 10 messages)
          aiConversation.push({ role: 'user', content: query });
          aiConversation.push({ role: 'assistant', content: reply });
          if (aiConversation.length > 20) {
            aiConversation = aiConversation.slice(-20);
          }
        } else if (data.error) {
          addAIMessage(`Error: ${data.error.message}`, 'assistant');
        }
      } catch (error) {
        removeAIMessage(loadingId);
        addAIMessage(`Sorry, I couldn't process that request. Error: ${error.message}`, 'assistant');
      }
      
      input.disabled = false;
      document.querySelector('.ai-send').disabled = false;
      input.focus();
    }
    
    function addAIMessage(content, type) {
      const container = document.getElementById('aiMessages');
      const id = `ai-msg-${Date.now()}`;
      
      const msgDiv = document.createElement('div');
      msgDiv.className = `ai-message ${type}`;
      msgDiv.id = id;
      
      if (type === 'loading') {
        msgDiv.innerHTML = `
          <div class="ai-message-content">
            <div class="ai-typing">
              <span></span><span></span><span></span>
            </div>
          </div>
        `;
      } else {
        // Convert markdown-style lists and formatting to HTML
        let formattedContent = content
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
          .replace(/\n- /g, '<br> ')
          .replace(/\n\n/g, '<br><br>')
          .replace(/\n/g, '<br>');
        
        msgDiv.innerHTML = `<div class="ai-message-content">${formattedContent}</div>`;
      }
      
      container.appendChild(msgDiv);
      container.scrollTop = container.scrollHeight;
      
      return id;
    }
    
    function removeAIMessage(id) {
      const msg = document.getElementById(id);
      if (msg) msg.remove();
    }

    // ============================================
    // NAVIGATION
    // ============================================
    let currentScreen = 'dispatch';
    
    function toggleNavSidebar() {
      const sidebar = document.getElementById('navSidebar');
      sidebar.classList.toggle('collapsed');
      document.body.classList.toggle('nav-collapsed', sidebar.classList.contains('collapsed'));
      
      // Save preference
      localStorage.setItem('navSidebarCollapsed', sidebar.classList.contains('collapsed'));
    }
    
    function navigateTo(screen) {
      // Hide all screens
      document.querySelectorAll('.screen').forEach(s => {
        s.style.display = 'none';
      });
      
      // Show target screen
      const targetScreen = document.getElementById(`screen-${screen}`);
      if (targetScreen) {
        targetScreen.style.display = screen === 'dispatch' ? 'contents' : 'flex';
        targetScreen.style.flexDirection = 'column';
        targetScreen.style.flex = '1';
      }
      
      // Update nav active state
      document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
        if (item.dataset.screen === screen) {
          item.classList.add('active');
        }
      });
      
      currentScreen = screen;
      
      // Update header title based on screen
      updateHeaderForScreen(screen);
      
      // Load screen data
      if (screen === 'calendar') {
        loadOpsCalendar();
      }
      if (screen === 'roster') {
        loadRosters();
      }
    }
    
    function updateHeaderForScreen(screen) {
      const headerControls = document.querySelector('.header-left');
      const styleToggles = headerControls.querySelectorAll('.style-toggle');
      const dateNav = headerControls.querySelector('.date-nav');
      
      // Show/hide dispatch-specific controls
      if (screen === 'dispatch') {
        styleToggles.forEach(t => t.style.display = '');
        if (dateNav) dateNav.style.display = '';
      } else {
        styleToggles.forEach(t => t.style.display = 'none');
        if (dateNav) dateNav.style.display = 'none';
      }
    }
    
    function initNavigation() {
      // Restore sidebar state
      const isCollapsed = localStorage.getItem('navSidebarCollapsed') === 'true';
      if (isCollapsed) {
        document.getElementById('navSidebar').classList.add('collapsed');
        document.body.classList.add('nav-collapsed');
      }
    }

    function init() {
      // Ensure body class matches current style (preserve other classes)
      document.body.classList.add(currentStyle);
      
      // Initialize navigation
      initNavigation();
      
      // Load initial fake data
      loadFakeData();
      
      // Set initial date display
      document.getElementById('currentDate').textContent = formatDate(currentDate);
      renderTimelineHeader('driverTimelineHeader');
      renderTimelineHeader('vehicleTimelineHeader');
      renderTimelineHeader('unassignedTimelineHeader');
      initResizeHandles();
      initPanelResize();
      
      // Sync all vehicle assignments from driver duties to vehicle schedules
      syncAllVehicleAssignments();
      
      renderAll();
      
      // Prefetch common routes in background (doesn't block UI)
      setTimeout(() => {
        prefetchCommonRoutes().catch(e => console.warn('Route prefetch failed:', e));
      }, 1000);
    }

    // ============================================
    // API CLIENT
    // ============================================
    const API_BASE = 'https://dispatch-api.oliveri-john001.workers.dev/api';
    
    async function apiRequest(endpoint, options = {}) {
      const url = `${API_BASE}${endpoint}`;
      const config = {
        headers: { 'Content-Type': 'application/json', ...options.headers },
        ...options,
      };
      if (config.body && typeof config.body === 'object') {
        config.body = JSON.stringify(config.body);
      }
      const response = await fetch(url, config);
      const data = await response.json();
      if (!response.ok) throw new Error(data.error || `HTTP ${response.status}`);
      return data;
    }
    
    // ============================================
    // EMPLOYEES CRUD
    // ============================================
    let employeesData = [];
    let employeeFiltersState = { search: '', role: '' };
    let editingEmployeeId = null;
    
    async function loadEmployees() {
      const tbody = document.getElementById('employeesTableBody');
      tbody.innerHTML = '<tr><td colspan="7" class="loading-cell">Loading employees...</td></tr>';
      
      try {
        const params = new URLSearchParams();
        if (employeeFiltersState.search) params.set('search', employeeFiltersState.search);
        if (employeeFiltersState.role) params.set('role', employeeFiltersState.role);
        
        const result = await apiRequest(`/employees?${params}`);
        employeesData = result.data || [];
        renderEmployeesTable();
      } catch (err) {
        tbody.innerHTML = `<tr><td colspan="7" class="loading-cell">Error: ${err.message}</td></tr>`;
      }
    }
    
    function renderEmployeesTable() {
      const tbody = document.getElementById('employeesTableBody');
      if (employeesData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" class="loading-cell">No employees found</td></tr>';
        return;
      }
      
      tbody.innerHTML = employeesData.map(e => `
        <tr>
          <td style="font-family: 'JetBrains Mono', monospace;">${e.employee_number}</td>
          <td>${e.first_name} ${e.last_name}</td>
          <td>${e.phone || ''}</td>
          <td style="font-family: 'JetBrains Mono', monospace;">${e.licence_number || ''}</td>
          <td><span class="badge badge-info">${e.role}</span></td>
          <td><span class="badge ${e.status === 'active' ? 'badge-success' : 'badge-warning'}">${e.status}</span></td>
          <td>
            <button class="action-btn" onclick="editEmployee('${e.id}')">Edit</button>
            <button class="action-btn danger" onclick="deleteEmployee('${e.id}', '${e.first_name} ${e.last_name}')">Delete</button>
          </td>
        </tr>
      `).join('');
    }
    
    let employeeSearchTimeout;
    function filterEmployees(search) {
      clearTimeout(employeeSearchTimeout);
      employeeSearchTimeout = setTimeout(() => {
        employeeFiltersState.search = search;
        loadEmployees();
      }, 300);
    }
    
    function filterEmployeeRole(role) {
      employeeFiltersState.role = role;
      loadEmployees();
    }
    
    function showAddEmployeeModal() {
      editingEmployeeId = null;
      document.getElementById('employeeModalTitle').textContent = 'Add Employee';
      document.getElementById('employeeForm').reset();
      document.getElementById('employeeModalOverlay').classList.add('show');
    }
    
    function editEmployee(id) {
      const emp = employeesData.find(e => e.id === id);
      if (!emp) return;
      
      editingEmployeeId = id;
      document.getElementById('employeeModalTitle').textContent = 'Edit Employee';
      document.getElementById('empNumber').value = emp.employee_number || '';
      document.getElementById('empFirstName').value = emp.first_name || '';
      document.getElementById('empLastName').value = emp.last_name || '';
      document.getElementById('empEmail').value = emp.email || '';
      document.getElementById('empPhone').value = emp.phone || '';
      document.getElementById('empLicence').value = emp.licence_number || '';
      document.getElementById('empRole').value = emp.role || 'driver';
      document.getElementById('empStatus').value = emp.status || 'active';
      document.getElementById('employeeModalOverlay').classList.add('show');
    }
    
    function closeEmployeeModal() {
      document.getElementById('employeeModalOverlay').classList.remove('show');
      editingEmployeeId = null;
    }
    
    async function saveEmployee() {
      const data = {
        employee_number: document.getElementById('empNumber').value,
        first_name: document.getElementById('empFirstName').value,
        last_name: document.getElementById('empLastName').value,
        email: document.getElementById('empEmail').value || null,
        phone: document.getElementById('empPhone').value || null,
        licence_number: document.getElementById('empLicence').value || null,
        role: document.getElementById('empRole').value,
        status: document.getElementById('empStatus').value,
      };
      
      try {
        if (editingEmployeeId) {
          await apiRequest(`/employees/${editingEmployeeId}`, { method: 'PUT', body: data });
          showToast('Employee updated');
        } else {
          await apiRequest('/employees', { method: 'POST', body: data });
          showToast('Employee added');
        }
        closeEmployeeModal();
        loadEmployees();
      } catch (err) {
        showToast(err.message || 'Failed to save', 'error');
      }
    }
    
    async function deleteEmployee(id, name) {
      if (!confirm(`Delete ${name}?`)) return;
      try {
        await apiRequest(`/employees/${id}`, { method: 'DELETE' });
        showToast('Employee deleted');
        loadEmployees();
      } catch (err) {
        showToast(err.message || 'Failed to delete', 'error');
      }
    }
    
    // ============================================
    // VEHICLES CRUD
    // ============================================
    let vehiclesData = [];
    let vehicleFiltersState = { search: '', status: '' };
    let editingVehicleId = null;
    
    async function loadVehiclesData() {
      const tbody = document.getElementById('vehiclesTableBody');
      tbody.innerHTML = '<tr><td colspan="7" class="loading-cell">Loading vehicles...</td></tr>';
      
      try {
        const params = new URLSearchParams();
        if (vehicleFiltersState.search) params.set('search', vehicleFiltersState.search);
        if (vehicleFiltersState.status) params.set('status', vehicleFiltersState.status);
        
        const result = await apiRequest(`/vehicles?${params}`);
        vehiclesData = result.data || [];
        renderVehiclesTable();
      } catch (err) {
        tbody.innerHTML = `<tr><td colspan="7" class="loading-cell">Error: ${err.message}</td></tr>`;
      }
    }
    
    function renderVehiclesTable() {
      const tbody = document.getElementById('vehiclesTableBody');
      if (vehiclesData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" class="loading-cell">No vehicles found</td></tr>';
        return;
      }
      
      tbody.innerHTML = vehiclesData.map(v => `
        <tr>
          <td style="font-family: 'JetBrains Mono', monospace;">${v.fleet_number}</td>
          <td style="font-family: 'JetBrains Mono', monospace;">${v.rego}</td>
          <td>${v.capacity} seats</td>
          <td>${v.make || ''} ${v.model || ''}</td>
          <td>${v.year || ''}</td>
          <td><span class="badge ${v.status === 'active' ? 'badge-success' : v.status === 'sold' ? 'badge-error' : 'badge-warning'}">${v.status}</span></td>
          <td>
            <button class="action-btn" onclick="editVehicleItem('${v.id}')">Edit</button>
            <button class="action-btn danger" onclick="deleteVehicle('${v.id}', '${v.fleet_number}')">Delete</button>
          </td>
        </tr>
      `).join('');
    }
    
    let vehicleSearchTimeout;
    function filterVehicles(search) {
      clearTimeout(vehicleSearchTimeout);
      vehicleSearchTimeout = setTimeout(() => {
        vehicleFiltersState.search = search;
        loadVehiclesData();
      }, 300);
    }
    
    function filterVehicleStatus(status) {
      vehicleFiltersState.status = status;
      loadVehiclesData();
    }
    
    function showAddVehicleModal() {
      editingVehicleId = null;
      document.getElementById('vehicleModalTitle').textContent = 'Add Vehicle';
      document.getElementById('vehicleForm').reset();
      document.getElementById('vehicleModalOverlay').classList.add('show');
    }
    
    function editVehicleItem(id) {
      const veh = vehiclesData.find(v => v.id === id);
      if (!veh) return;
      
      editingVehicleId = id;
      document.getElementById('vehicleModalTitle').textContent = 'Edit Vehicle';
      document.getElementById('vehFleet').value = veh.fleet_number || '';
      document.getElementById('vehRego').value = veh.rego || '';
      document.getElementById('vehCapacity').value = veh.capacity || '';
      document.getElementById('vehMake').value = veh.make || '';
      document.getElementById('vehModel').value = veh.model || '';
      document.getElementById('vehYear').value = veh.year || '';
      document.getElementById('vehStatus').value = veh.status || 'active';
      document.getElementById('vehicleModalOverlay').classList.add('show');
    }
    
    function closeVehicleModal() {
      document.getElementById('vehicleModalOverlay').classList.remove('show');
      editingVehicleId = null;
    }
    
    async function saveVehicle() {
      const data = {
        fleet_number: document.getElementById('vehFleet').value,
        rego: document.getElementById('vehRego').value,
        capacity: parseInt(document.getElementById('vehCapacity').value),
        make: document.getElementById('vehMake').value || null,
        model: document.getElementById('vehModel').value || null,
        year: document.getElementById('vehYear').value ? parseInt(document.getElementById('vehYear').value) : null,
        status: document.getElementById('vehStatus').value,
      };
      
      try {
        if (editingVehicleId) {
          await apiRequest(`/vehicles/${editingVehicleId}`, { method: 'PUT', body: data });
          showToast('Vehicle updated');
        } else {
          await apiRequest('/vehicles', { method: 'POST', body: data });
          showToast('Vehicle added');
        }
        closeVehicleModal();
        loadVehiclesData();
      } catch (err) {
        showToast(err.message || 'Failed to save', 'error');
      }
    }
    
    async function deleteVehicle(id, name) {
      if (!confirm(`Delete vehicle ${name}?`)) return;
      try {
        await apiRequest(`/vehicles/${id}`, { method: 'DELETE' });
        showToast('Vehicle deleted');
        loadVehiclesData();
      } catch (err) {
        showToast(err.message || 'Failed to delete', 'error');
      }
    }
    
    // ============================================
    // SHIFTS CRUD
    // ============================================
    let shiftsData = [];
    let shiftFiltersState = { search: '', type: '' };
    let editingShiftId = null;
    let shiftDutyBlocks = []; // Array of duty blocks, each with name, driver_id, and lines
    let shiftEmployees = []; // Employees for driver dropdown
    let shiftVehicles = []; // Vehicles for vehicle dropdown
    
    const SHIFT_DUTY_TYPES = [
      { code: 'driving', name: 'Driving' },
      { code: 'oov', name: 'Out of Vehicle' },
      { code: 'break', name: 'Meal Break' },
      { code: 'waiting', name: 'Waiting' },
      { code: 'charter', name: 'Charter' },
      { code: 'dead', name: 'Dead Running' }
    ];
    
    const SHIFT_PAY_TYPES = [
      { code: 'STD', name: 'Standard' },
      { code: 'OT', name: 'Overtime' },
      { code: 'DT', name: 'Double Time' },
      { code: 'PEN', name: 'Penalty' },
      { code: 'UNP', name: 'Unpaid' }
    ];
    
    async function loadShiftFormData() {
      // Load employees and vehicles for dropdowns
      try {
        const [empResult, vehResult] = await Promise.all([
          apiRequest('/employees?status=active&limit=500'),
          apiRequest('/vehicles?status=active&limit=500')
        ]);
        shiftEmployees = empResult.data || [];
        shiftVehicles = vehResult.data || [];
      } catch (err) {
        console.error('Failed to load form data:', err);
      }
    }
    
    async function loadShifts() {
      const tbody = document.getElementById('shiftsTableBody');
      tbody.innerHTML = '<tr><td colspan="8" class="loading-cell">Loading shift templates...</td></tr>';
      
      try {
        const params = new URLSearchParams();
        if (shiftFiltersState.search) params.set('search', shiftFiltersState.search);
        if (shiftFiltersState.type) params.set('type', shiftFiltersState.type);
        
        const result = await apiRequest(`/shifts?${params}`);
        shiftsData = result.data || [];
        renderShiftsTable();
      } catch (err) {
        tbody.innerHTML = `<tr><td colspan="8" class="loading-cell">Error: ${err.message}</td></tr>`;
      }
    }
    
    function formatDecimalTime(decimal) {
      if (decimal === null || decimal === undefined) return '';
      const h = Math.floor(decimal);
      const m = Math.round((decimal - h) * 60);
      return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
    }
    
    function parseTimeInput(val) {
      if (!val) return null;
      val = val.replace(/[^0-9:]/g, '');
      if (val.includes(':')) {
        const [h, m] = val.split(':').map(Number);
        return h + (m / 60);
      } else if (val.length >= 3) {
        const h = parseInt(val.slice(0, -2)) || 0;
        const m = parseInt(val.slice(-2)) || 0;
        return h + (m / 60);
      }
      return null;
    }
    
    function renderShiftsTable() {
      const tbody = document.getElementById('shiftsTableBody');
      if (shiftsData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" class="loading-cell">No shift templates found. Click "+ Add Template" to create one.</td></tr>';
        return;
      }
      
      tbody.innerHTML = shiftsData.map(s => {
        const duration = (s.default_end || 0) - (s.default_start || 0);
        const durationStr = duration > 0 ? `${Math.floor(duration)}h ${Math.round((duration % 1) * 60)}m` : '';
        return `
          <tr>
            <td style="font-family: 'JetBrains Mono', monospace;">${s.code}</td>
            <td>${s.name}</td>
            <td><span class="badge badge-info">${s.shift_type}</span></td>
            <td>${formatDecimalTime(s.default_start) || ''}</td>
            <td>${formatDecimalTime(s.default_end) || ''}</td>
            <td>${durationStr}</td>
            <td>${s.duty_count || 0}</td>
            <td>
              <button class="action-btn" onclick="editShift('${s.id}')">Edit</button>
              <button class="action-btn" onclick="duplicateShift('${s.id}')">Copy</button>
              <button class="action-btn danger" onclick="deleteShift('${s.id}', '${s.name}')">Delete</button>
            </td>
          </tr>
        `;
      }).join('');
    }
    
    let shiftSearchTimeout;
    function filterShifts(search) {
      clearTimeout(shiftSearchTimeout);
      shiftSearchTimeout = setTimeout(() => {
        shiftFiltersState.search = search;
        loadShifts();
      }, 300);
    }
    
    function filterShiftType(type) {
      shiftFiltersState.type = type;
      loadShifts();
    }
    
    async function showAddShiftModal() {
      editingShiftId = null;
      shiftDutyBlocks = [];
      document.getElementById('shiftModalTitle').textContent = 'Add Shift Template';
      document.getElementById('shiftForm').reset();
      await loadShiftFormData();
      renderShiftDutyBlocks();
      document.getElementById('shiftModalOverlay').classList.add('show');
    }
    
    async function editShift(id) {
      // Check if shift is locked by published rosters
      try {
        const lockStatus = await apiRequest(`/shifts/${id}/lock-status`);
        if (lockStatus.locked) {
          const rosterNames = lockStatus.published_rosters.map(r => r.code).join(', ');
          showToast(`This shift cannot be edited - it is used in published roster(s): ${rosterNames}. Unpublish the roster(s) first.`, 'error');
          return;
        }
      } catch (err) {
        console.error('Lock check failed:', err);
      }
      
      // Fetch full shift data with duty blocks
      try {
        await loadShiftFormData();
        const result = await apiRequest(`/shifts/${id}`);
        const shift = result.data;
        if (!shift) {
          showToast('Shift not found', 'error');
          return;
        }
        
        editingShiftId = id;
        shiftDutyBlocks = shift.duty_blocks ? shift.duty_blocks.map(b => ({
          ...b,
          lines: b.lines ? b.lines.map(l => ({...l})) : []
        })) : [];
        
        document.getElementById('shiftModalTitle').textContent = 'Edit Shift Template';
        document.getElementById('shiftCode').value = shift.code || '';
        document.getElementById('shiftName').value = shift.name || '';
        document.getElementById('shiftType').value = shift.shift_type || 'regular';
        document.getElementById('shiftNotes').value = shift.notes || '';
        
        renderShiftDutyBlocks();
        document.getElementById('shiftModalOverlay').classList.add('show');
      } catch (err) {
        showToast(err.message || 'Failed to load shift', 'error');
      }
    }
    
    function closeShiftModal() {
      document.getElementById('shiftModalOverlay').classList.remove('show');
      editingShiftId = null;
      shiftDutyBlocks = [];
    }
    
    // Add a new duty block
    function addShiftDutyBlock() {
      const dutyNum = shiftDutyBlocks.length + 1;
      let startTime = 6.0;
      
      // Continue from last duty's last line
      if (shiftDutyBlocks.length > 0) {
        const lastBlock = shiftDutyBlocks[shiftDutyBlocks.length - 1];
        if (lastBlock.lines.length > 0) {
          startTime = lastBlock.lines[lastBlock.lines.length - 1].end_time || 6.0;
        }
      }
      
      shiftDutyBlocks.push({
        id: 'new_' + Date.now(),
        name: `Duty ${dutyNum}`,
        driver_id: null,
        lines: [{
          id: 'line_' + Date.now(),
          start_time: startTime,
          end_time: startTime + 1,
          duty_type: 'driving',
          description: '',
          vehicle_id: null,
          pay_type: 'STD'
        }]
      });
      
      renderShiftDutyBlocks();
    }
    
    // Remove a duty block
    function removeShiftDutyBlock(blockIdx) {
      if (!confirm('Delete this entire duty and all its lines?')) return;
      shiftDutyBlocks.splice(blockIdx, 1);
      renderShiftDutyBlocks();
    }
    
    // Update duty block name
    function updateDutyBlockName(blockIdx, name) {
      shiftDutyBlocks[blockIdx].name = name;
    }
    
    // Update duty block driver
    function updateDutyBlockDriver(blockIdx, driverId) {
      shiftDutyBlocks[blockIdx].driver_id = driverId || null;
    }
    
    // Add a line to a duty block (above or below)
    function addDutyLine(blockIdx, lineIdx, direction) {
      const block = shiftDutyBlocks[blockIdx];
      const refLine = block.lines[lineIdx];
      
      let startTime, endTime;
      if (direction === 'above') {
        startTime = refLine.start_time - 0.5;
        endTime = refLine.start_time;
      } else {
        startTime = refLine.end_time;
        endTime = refLine.end_time + 0.5;
      }
      
      const newLine = {
        id: 'line_' + Date.now(),
        start_time: startTime,
        end_time: endTime,
        duty_type: 'driving',
        description: '',
        vehicle_id: null,
        pay_type: 'STD'
      };
      
      const insertIdx = direction === 'above' ? lineIdx : lineIdx + 1;
      block.lines.splice(insertIdx, 0, newLine);
      renderShiftDutyBlocks();
    }
    
    // Remove a line from a duty block
    function removeDutyLine(blockIdx, lineIdx) {
      const block = shiftDutyBlocks[blockIdx];
      if (block.lines.length === 1) {
        // If last line, remove the whole block
        removeShiftDutyBlock(blockIdx);
        return;
      }
      block.lines.splice(lineIdx, 1);
      renderShiftDutyBlocks();
    }
    
    // Update a line field
    function updateDutyLine(blockIdx, lineIdx, field, value) {
      if (field === 'start_time' || field === 'end_time') {
        value = parseTimeInput(value);
      }
      shiftDutyBlocks[blockIdx].lines[lineIdx][field] = value;
      // Only re-render totals, not the whole thing (to avoid losing focus)
      renderShiftDutyTotals();
    }
    
    // Update location fields for shift duty line
    function updateShiftDutyLocation(blockIdx, lineIdx) {
      const inputId = `shiftLoc_${blockIdx}_${lineIdx}`;
      const nameInput = document.getElementById(inputId);
      const latInput = document.getElementById(inputId + 'Lat');
      const lngInput = document.getElementById(inputId + 'Lng');
      
      if (!nameInput) return;
      
      const line = shiftDutyBlocks[blockIdx]?.lines[lineIdx];
      if (!line) return;
      
      line.location_name = nameInput.value || null;
      line.location_lat = parseFloat(latInput?.value) || null;
      line.location_lng = parseFloat(lngInput?.value) || null;
      
      renderShiftDutyTotals();
    }
    
    function calculateLineHours(line) {
      if (line.start_time === null || line.end_time === null) return 0;
      let hours = line.end_time - line.start_time;
      if (hours < 0) hours += 24;
      return hours;
    }
    
    function formatHours(hours) {
      const h = Math.floor(hours);
      const m = Math.round((hours - h) * 60);
      if (h === 0) return `${m}m`;
      if (m === 0) return `${h}h`;
      return `${h}h${m}m`;
    }
    
    function renderShiftDutyBlocks() {
      const container = document.getElementById('shiftDutyBlocks');
      
      if (shiftDutyBlocks.length === 0) {
        container.innerHTML = '<div class="duty-editor-empty">No duties added. Click "+ Add Duty" to start.</div>';
        renderShiftDutyTotals();
        return;
      }
      
      // Build driver options
      const driverOptions = '<option value=""> No Driver </option>' + 
        shiftEmployees.map(e => `<option value="${e.id}">${e.first_name} ${e.last_name}</option>`).join('');
      
      // Build vehicle options
      const vehicleOptions = '<option value=""></option>' +
        shiftVehicles.map(v => `<option value="${v.id}">${v.fleet_number}</option>`).join('');
      
      container.innerHTML = shiftDutyBlocks.map((block, blockIdx) => {
        const linesHtml = block.lines.map((line, lineIdx) => {
          const hours = calculateLineHours(line);
          return `
            <div class="duty-line">
              <div class="duty-col-arrows duty-line-arrows">
                <button type="button" class="duty-line-arrow" onclick="addDutyLine(${blockIdx}, ${lineIdx}, 'above')" title="Insert above"></button>
                <button type="button" class="duty-line-arrow" onclick="addDutyLine(${blockIdx}, ${lineIdx}, 'below')" title="Insert below"></button>
              </div>
              <div class="duty-col-time">
                <input type="text" 
                  value="${formatDecimalTime(line.start_time)}" 
                  onchange="updateDutyLine(${blockIdx}, ${lineIdx}, 'start_time', this.value)"
                  placeholder="00:00">
              </div>
              <div class="duty-col-time">
                <input type="text" 
                  value="${formatDecimalTime(line.end_time)}" 
                  onchange="updateDutyLine(${blockIdx}, ${lineIdx}, 'end_time', this.value)"
                  placeholder="00:00">
              </div>
              <div class="duty-col-type">
                <select onchange="updateDutyLine(${blockIdx}, ${lineIdx}, 'duty_type', this.value)">
                  ${SHIFT_DUTY_TYPES.map(t => `<option value="${t.code}" ${line.duty_type === t.code ? 'selected' : ''}>${t.name}</option>`).join('')}
                </select>
              </div>
              <div class="duty-col-desc">
                <input type="text" 
                  value="${line.description || ''}" 
                  onchange="updateDutyLine(${blockIdx}, ${lineIdx}, 'description', this.value)"
                  placeholder="Description...">
              </div>
              <div class="duty-col-location">
                <div class="location-input-wrapper">
                  <input type="text" 
                    id="shiftLoc_${blockIdx}_${lineIdx}"
                    value="${line.location_name || ''}" 
                    oninput="onLocationInput('shiftLoc_${blockIdx}_${lineIdx}')"
                    onfocus="onLocationInput('shiftLoc_${blockIdx}_${lineIdx}')"
                    onblur="setTimeout(() => updateShiftDutyLocation(${blockIdx}, ${lineIdx}), 200)"
                    placeholder="Search location...">
                  <input type="hidden" id="shiftLoc_${blockIdx}_${lineIdx}Lat" value="${line.location_lat || ''}">
                  <input type="hidden" id="shiftLoc_${blockIdx}_${lineIdx}Lng" value="${line.location_lng || ''}">
                </div>
              </div>
              <div class="duty-col-vehicle">
                <select onchange="updateDutyLine(${blockIdx}, ${lineIdx}, 'vehicle_id', this.value)">
                  ${vehicleOptions.replace(`value="${line.vehicle_id}"`, `value="${line.vehicle_id}" selected`)}
                </select>
              </div>
              <div class="duty-col-pay">
                <select onchange="updateDutyLine(${blockIdx}, ${lineIdx}, 'pay_type', this.value)">
                  ${SHIFT_PAY_TYPES.map(t => `<option value="${t.code}" ${line.pay_type === t.code ? 'selected' : ''}>${t.code}</option>`).join('')}
                </select>
              </div>
              <div class="duty-col-hours">${formatHours(hours)}</div>
              <div class="duty-col-actions">
                <button type="button" class="duty-line-delete" onclick="removeDutyLine(${blockIdx}, ${lineIdx})" title="Delete line"></button>
              </div>
            </div>
          `;
        }).join('');
        
        // Build driver select with correct selected value
        const driverSelectHtml = driverOptions.replace(
          `value="${block.driver_id}"`, 
          `value="${block.driver_id}" selected`
        );
        
        return `
          <div class="duty-block">
            <div class="duty-block-header">
              <input type="text" class="duty-block-name" value="${block.name}" 
                onchange="updateDutyBlockName(${blockIdx}, this.value)" 
                placeholder="Duty name...">
              <div class="duty-block-driver">
                <span class="duty-block-driver-label">Driver:</span>
                <select onchange="updateDutyBlockDriver(${blockIdx}, this.value)">
                  ${driverSelectHtml}
                </select>
              </div>
              <button type="button" class="duty-block-delete" onclick="removeShiftDutyBlock(${blockIdx})" title="Delete duty"></button>
            </div>
            <div class="duty-block-lines">
              <div class="duty-line-header">
                <span class="duty-col-arrows"></span>
                <span class="duty-col-time">Start</span>
                <span class="duty-col-time">End</span>
                <span class="duty-col-type">Type</span>
                <span class="duty-col-desc">Description</span>
                <span class="duty-col-location">Location</span>
                <span class="duty-col-vehicle">Vehicle</span>
                <span class="duty-col-pay">Pay</span>
                <span class="duty-col-hours">Hours</span>
                <span class="duty-col-actions"></span>
              </div>
              ${linesHtml}
            </div>
          </div>
        `;
      }).join('');
      
      renderShiftDutyTotals();
    }
    
    function renderShiftDutyTotals() {
      const totalsContainer = document.getElementById('shiftDutyTotals');
      
      if (shiftDutyBlocks.length === 0) {
        totalsContainer.innerHTML = '';
        return;
      }
      
      const totalsByPay = {};
      let totalHours = 0;
      
      shiftDutyBlocks.forEach(block => {
        block.lines.forEach(line => {
          const hours = calculateLineHours(line);
          totalHours += hours;
          const payType = line.pay_type || 'STD';
          totalsByPay[payType] = (totalsByPay[payType] || 0) + hours;
        });
      });
      
      let totalsHtml = Object.entries(totalsByPay).map(([pay, hours]) => 
        `<div class="duty-total-item"><span class="duty-total-label">${pay}:</span><span class="duty-total-value">${formatHours(hours)}</span></div>`
      ).join('');
      totalsHtml += `<div class="duty-total-item"><span class="duty-total-label">Total:</span><span class="duty-total-value">${formatHours(totalHours)}</span></div>`;
      
      totalsContainer.innerHTML = totalsHtml;
    }
    
    async function saveShift() {
      // Calculate shift start/end from all duty lines
      let shiftStart = null;
      let shiftEnd = null;
      
      shiftDutyBlocks.forEach(block => {
        block.lines.forEach(line => {
          if (line.start_time !== null) {
            if (shiftStart === null || line.start_time < shiftStart) shiftStart = line.start_time;
          }
          if (line.end_time !== null) {
            if (shiftEnd === null || line.end_time > shiftEnd) shiftEnd = line.end_time;
          }
        });
      });
      
      const data = {
        code: document.getElementById('shiftCode').value,
        name: document.getElementById('shiftName').value,
        shift_type: document.getElementById('shiftType').value,
        default_start: shiftStart,
        default_end: shiftEnd,
        notes: document.getElementById('shiftNotes').value || null,
        duty_blocks: shiftDutyBlocks.map((block, blockIdx) => ({
          id: block.id || null,  // Preserve existing ID for updates
          sequence: blockIdx + 1,
          name: block.name,
          driver_id: block.driver_id || null,
          lines: block.lines.map((line, lineIdx) => ({
            id: line.id || null,  // Preserve existing ID for updates
            sequence: lineIdx + 1,
            duty_type: line.duty_type,
            start_time: line.start_time,
            end_time: line.end_time,
            description: line.description || null,
            vehicle_id: line.vehicle_id || null,
            pay_type: line.pay_type || 'STD',
            location_name: line.location_name || null,
            location_lat: line.location_lat || null,
            location_lng: line.location_lng || null
          }))
        }))
      };
      
      try {
        if (editingShiftId) {
          await apiRequest(`/shifts/${editingShiftId}`, { method: 'PUT', body: data });
          showToast('Shift template updated');
        } else {
          await apiRequest('/shifts', { method: 'POST', body: data });
          showToast('Shift template added');
        }
        closeShiftModal();
        loadShifts();
      } catch (err) {
        showToast(err.message || 'Failed to save', 'error');
      }
    }
    
    async function duplicateShift(id) {
      try {
        await apiRequest(`/shifts/${id}/duplicate`, { method: 'POST' });
        showToast('Shift template duplicated');
        loadShifts();
      } catch (err) {
        showToast(err.message || 'Failed to duplicate', 'error');
      }
    }
    
    async function deleteShift(id, name) {
      if (!confirm(`Delete shift template "${name}"?`)) return;
      try {
        await apiRequest(`/shifts/${id}`, { method: 'DELETE' });
        showToast('Shift template deleted');
        loadShifts();
      } catch (err) {
        showToast(err.message || 'Failed to delete', 'error');
      }
    }
    
    // ============================================
    // DATE HELPERS
    // ============================================
    
    function formatDateShort(date) {
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
    }
    
    function formatDateISO(date) {
      return date.toISOString().split('T')[0];
    }
    
    // ============================================
    // OPS CALENDAR
    // ============================================
    
    let opsCalendarYear = new Date().getFullYear();
    let opsCalendarMonth = new Date().getMonth() + 1;
    let opsCalendarData = null;
    let allRostersData = []; // All rosters (for sidebar)
    let selectedRosterForSchedule = null; // For schedule modal
    
    async function loadOpsCalendar() {
      const grid = document.getElementById('opsCalendarGrid');
      const list = document.getElementById('opsRosterList');
      
      grid.innerHTML = '<div style="padding: 40px; text-align: center; color: var(--text-muted);">Loading calendar...</div>';
      list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-muted);">Loading...</div>';
      
      const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                          'July', 'August', 'September', 'October', 'November', 'December'];
      document.getElementById('calendarMonthLabel').textContent = `${monthNames[opsCalendarMonth - 1]} ${opsCalendarYear}`;
      
      try {
        // Load calendar view (only scheduled rosters appear here)
        const calResult = await apiRequest(`/ops-calendar/${opsCalendarYear}/${opsCalendarMonth}`);
        opsCalendarData = calResult.data;
        
        // Load ALL rosters for sidebar
        const rostersResult = await apiRequest('/ops-calendar/rosters');
        allRostersData = rostersResult.data || [];
        
        renderOpsCalendar();
        renderOpsRosterList();
      } catch (err) {
        grid.innerHTML = `<div style="padding: 40px; text-align: center; color: var(--accent-red);">Error: ${err.message}</div>`;
        list.innerHTML = '';
      }
    }
    
    function renderOpsCalendar() {
      if (!opsCalendarData) return;
      
      const grid = document.getElementById('opsCalendarGrid');
      const { days, rosters } = opsCalendarData;
      
      // Only scheduled rosters come from calendar endpoint
      const rosterMap = {};
      rosters.forEach(r => rosterMap[r.id] = r);
      
      const firstDayOfWeek = days[0].dayOfWeek;
      
      let html = `
        <div class="calendar-month">
          <div class="calendar-header-row">
            <div class="calendar-header-cell">Sun</div>
            <div class="calendar-header-cell">Mon</div>
            <div class="calendar-header-cell">Tue</div>
            <div class="calendar-header-cell">Wed</div>
            <div class="calendar-header-cell">Thu</div>
            <div class="calendar-header-cell">Fri</div>
            <div class="calendar-header-cell weekend">Sat</div>
          </div>
          <div class="calendar-body">
      `;
      
      for (let i = 0; i < firstDayOfWeek; i++) {
        html += `<div class="calendar-day other-month"></div>`;
      }
      
      for (const day of days) {
        const classes = ['calendar-day'];
        if (day.isWeekend) classes.push('weekend');
        if (day.isToday) classes.push('today');
        if (day.isHoliday) classes.push('holiday');
        if (day.isSchoolHoliday && !day.isHoliday) classes.push('school-holiday');
        
        // Build badges for holidays
        let badgesHtml = '';
        if (day.isHoliday || day.isSchoolHoliday) {
          badgesHtml = '<div class="calendar-badges">';
          if (day.isHoliday) {
            badgesHtml += `<div class="calendar-holiday-badge" title="${day.holidayName}">${day.holidayName}</div>`;
          }
          if (day.isSchoolHoliday) {
            badgesHtml += `<div class="calendar-school-badge" title="${day.schoolHolidayName}">School Hols</div>`;
          }
          badgesHtml += '</div>';
        }
        
        html += `
          <div class="${classes.join(' ')}">
            <div class="calendar-day-header">
              <div class="calendar-day-number">${parseInt(day.date.split('-')[2])}</div>
              ${badgesHtml}
            </div>
            <div class="calendar-roster-bars">
        `;
        
        for (const rosterId of day.rosters) {
          const roster = rosterMap[rosterId];
          if (roster) {
            html += `
              <div class="calendar-roster-bar ${roster.status}" 
                   onclick="openRosterFromCalendar('${roster.id}')" 
                   title="${roster.code} - ${roster.name}">
                ${roster.code}
              </div>
            `;
          }
        }
        
        html += `</div></div>`;
      }
      
      const lastDayOfWeek = days[days.length - 1].dayOfWeek;
      for (let i = lastDayOfWeek + 1; i < 7; i++) {
        html += `<div class="calendar-day other-month"></div>`;
      }
      
      html += `</div></div>`;
      grid.innerHTML = html;
    }
    
    function renderOpsRosterList() {
      const list = document.getElementById('opsRosterList');
      
      if (allRostersData.length === 0) {
        list.innerHTML = `
          <div class="calendar-no-rosters">
            <p>No rosters available.</p>
            <p style="margin-top: 8px;"><a href="#" onclick="navigateTo('roster'); return false;" style="color: var(--accent-blue);">Go to Roster</a> to create one.</p>
          </div>
        `;
        return;
      }
      
      // Separate scheduled and unscheduled
      const scheduled = allRostersData.filter(r => r.isScheduled);
      const unscheduled = allRostersData.filter(r => !r.isScheduled);
      
      let html = '';
      
      // Scheduled rosters section
      if (scheduled.length > 0) {
        html += `<div class="ops-section-title">On Calendar (${scheduled.length})</div>`;
        for (const roster of scheduled) {
          html += renderOpsRosterItem(roster, true);
        }
      }
      
      // Unscheduled rosters section
      if (unscheduled.length > 0) {
        html += `<div class="ops-section-title" style="margin-top: 16px;">Available Rosters (${unscheduled.length})</div>`;
        for (const roster of unscheduled) {
          html += renderOpsRosterItem(roster, false);
        }
      }
      
      list.innerHTML = html;
    }
    
    function renderOpsRosterItem(roster, isScheduled) {
      const validStart = new Date(roster.startDate).toLocaleDateString('en-AU', { day: 'numeric', month: 'short' });
      const validEnd = new Date(roster.endDate).toLocaleDateString('en-AU', { day: 'numeric', month: 'short', year: 'numeric' });
      
      let calendarDates = '';
      if (isScheduled && roster.calendarStartDate && roster.calendarEndDate) {
        const calStart = new Date(roster.calendarStartDate).toLocaleDateString('en-AU', { day: 'numeric', month: 'short' });
        const calEnd = new Date(roster.calendarEndDate).toLocaleDateString('en-AU', { day: 'numeric', month: 'short' });
        calendarDates = `<div class="ops-roster-cal-dates"> ${calStart}  ${calEnd}</div>`;
      }
      
      return `
        <div class="ops-roster-item ${isScheduled ? 'status-' + roster.status : 'unscheduled'}" onclick="${isScheduled ? `openRosterFromCalendar('${roster.id}')` : ''}">
          <div class="ops-roster-header">
            <span class="ops-roster-code">${roster.code}</span>
            ${isScheduled ? 
              `<span class="ops-roster-status ${roster.status}">${roster.status}</span>` :
              `<span class="ops-roster-status unscheduled">not scheduled</span>`
            }
          </div>
          <div class="ops-roster-name">${roster.name}</div>
          <div class="ops-roster-dates">Valid: ${validStart}  ${validEnd}</div>
          ${calendarDates}
          <div class="ops-roster-stats">
            <span> ${roster.entryCount} entries</span>
            <span> ${roster.assignedCount} assigned</span>
            ${roster.unassignedCount > 0 ? `<span style="color: var(--accent-amber);"> ${roster.unassignedCount} unassigned</span>` : ''}
          </div>
          <div class="ops-roster-actions" onclick="event.stopPropagation();">
            ${!isScheduled ? 
              `<button class="btn-schedule" onclick="showScheduleModal('${roster.id}')">+ Add to Calendar</button>` :
              roster.status === 'draft' ? 
                `<button class="btn-unschedule" onclick="unscheduleRoster('${roster.id}')">Remove</button>
                 <button class="btn-publish" onclick="publishRosterFromCalendar('${roster.id}')">Publish</button>` :
              roster.status === 'published' ?
                `<button class="btn-unpublish" onclick="unpublishRosterFromCalendar('${roster.id}')">Unpublish</button>` : ''
            }
            ${isScheduled ? `<button class="btn-open" onclick="openRosterFromCalendar('${roster.id}')">Open </button>` : ''}
          </div>
        </div>
      `;
    }
    
    function changeCalendarMonth(delta) {
      opsCalendarMonth += delta;
      if (opsCalendarMonth > 12) { opsCalendarMonth = 1; opsCalendarYear++; }
      else if (opsCalendarMonth < 1) { opsCalendarMonth = 12; opsCalendarYear--; }
      loadOpsCalendar();
    }
    
    function goToCalendarToday() {
      const today = new Date();
      opsCalendarYear = today.getFullYear();
      opsCalendarMonth = today.getMonth() + 1;
      loadOpsCalendar();
    }
    
    function openRosterFromCalendar(rosterId) {
      navigateTo('roster');
      setTimeout(() => openRoster(rosterId), 100);
    }
    
    // Schedule Modal
    function showScheduleModal(rosterId) {
      selectedRosterForSchedule = allRostersData.find(r => r.id === rosterId);
      if (!selectedRosterForSchedule) return;
      
      // Set default dates to roster's valid range
      document.getElementById('scheduleStartDate').value = selectedRosterForSchedule.startDate;
      document.getElementById('scheduleEndDate').value = selectedRosterForSchedule.endDate;
      document.getElementById('scheduleStartDate').min = selectedRosterForSchedule.startDate;
      document.getElementById('scheduleStartDate').max = selectedRosterForSchedule.endDate;
      document.getElementById('scheduleEndDate').min = selectedRosterForSchedule.startDate;
      document.getElementById('scheduleEndDate').max = selectedRosterForSchedule.endDate;
      
      document.getElementById('scheduleRosterName').textContent = `${selectedRosterForSchedule.code} - ${selectedRosterForSchedule.name}`;
      document.getElementById('scheduleValidRange').textContent = `Valid range: ${selectedRosterForSchedule.startDate} to ${selectedRosterForSchedule.endDate}`;
      
      document.getElementById('scheduleModalOverlay').classList.add('show');
    }
    
    function closeScheduleModal() {
      document.getElementById('scheduleModalOverlay').classList.remove('show');
      selectedRosterForSchedule = null;
    }
    
    async function confirmScheduleRoster() {
      if (!selectedRosterForSchedule) return;
      
      const startDate = document.getElementById('scheduleStartDate').value;
      const endDate = document.getElementById('scheduleEndDate').value;
      
      if (!startDate || !endDate) {
        showToast('Please select both start and end dates', 'error');
        return;
      }
      
      if (startDate > endDate) {
        showToast('Start date cannot be after end date', 'error');
        return;
      }
      
      try {
        await apiRequest(`/roster/containers/${selectedRosterForSchedule.id}/schedule`, {
          method: 'POST',
          body: {
            calendar_start_date: startDate,
            calendar_end_date: endDate
          }
        });
        showToast('Roster added to calendar!', 'success');
        closeScheduleModal();
        loadOpsCalendar();
      } catch (err) {
        showToast(err.message || 'Failed to schedule roster', 'error');
      }
    }
    
    async function unscheduleRoster(rosterId) {
      if (!confirm('Remove this roster from the calendar?')) return;
      
      try {
        await apiRequest(`/roster/containers/${rosterId}/unschedule`, { method: 'POST' });
        showToast('Roster removed from calendar', 'success');
        loadOpsCalendar();
      } catch (err) {
        showToast(err.message || 'Failed to remove roster', 'error');
      }
    }
    
    async function publishRosterFromCalendar(rosterId) {
      if (!confirm('Publish this roster? It will become visible in Dispatch.')) return;
      
      try {
        const result = await apiRequest(`/roster/containers/${rosterId}/publish`, { method: 'POST' });
        if (result.error) {
          if (result.conflict) {
            showToast(`Conflict: ${result.conflict.driverName} on ${result.conflict.date} (${result.conflict.conflictingRoster})`, 'error');
          } else {
            showToast(result.error, 'error');
          }
          return;
        }
        showToast('Roster published!', 'success');
        loadOpsCalendar();
      } catch (err) {
        showToast(err.message || 'Failed to publish', 'error');
      }
    }
    
    async function unpublishRosterFromCalendar(rosterId) {
      const confirmMsg = 'WARNING: Unpublishing this roster will remove ALL duties from this roster from Dispatch.\n\nDrivers will no longer see these assignments until the roster is published again.\n\nContinue?';
      if (!confirm(confirmMsg)) return;
      
      try {
        await apiRequest(`/roster/containers/${rosterId}/unpublish`, { method: 'POST' });
        showToast('Roster unpublished - duties removed from dispatch', 'success');
        loadOpsCalendar();
      } catch (err) {
        showToast(err.message || 'Failed to unpublish', 'error');
      }
    }
    
    // ============================================
    // ROSTER - NEW DESIGN
    // ============================================
    // All shift duty blocks appear in Unassigned by default
    // User drags blocks from Unassigned to Drivers
    // ============================================
    
    let rostersData = [];
    let currentRoster = null;
    let currentRosterId = null;
    let currentRosterDate = null;
    let dayViewData = null; // Holds the day's blocks and assignments
    let pendingAssignment = null; // For the "move connected" modal
    
    // Gantt config
    const GANTT_START_HOUR = 4;
    const GANTT_END_HOUR = 24;
    const GANTT_HOURS = GANTT_END_HOUR - GANTT_START_HOUR;
    
    // ============================================
    // ROSTER LIST
    // ============================================
    
    async function loadRosters() {
      const tbody = document.getElementById('rosterListTableBody');
      tbody.innerHTML = '<tr><td colspan="6" class="loading-cell">Loading rosters...</td></tr>';
      
      try {
        const result = await apiRequest('/roster/containers');
        rostersData = result.data || [];
        renderRosterList();
      } catch (err) {
        tbody.innerHTML = `<tr><td colspan="6" class="loading-cell">Error: ${err.message}</td></tr>`;
      }
    }
    
    function renderRosterList() {
      const tbody = document.getElementById('rosterListTableBody');
      const search = (document.getElementById('rosterSearchInput')?.value || '').toLowerCase();
      
      let filtered = rostersData;
      if (search) {
        filtered = rostersData.filter(r => 
          r.code?.toLowerCase().includes(search) || 
          r.name?.toLowerCase().includes(search)
        );
      }
      
      if (filtered.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" class="loading-cell">No rosters found. Click "+ New Roster" to create one.</td></tr>';
        return;
      }
      
      tbody.innerHTML = filtered.map(r => `
        <tr>
          <td><strong>${r.code}</strong></td>
          <td>${r.name}</td>
          <td>${formatDateShort(new Date(r.start_date))} - ${formatDateShort(new Date(r.end_date))}</td>
          <td><span class="roster-status ${r.status}">${r.status}</span></td>
          <td>${r.entry_count || 0}</td>
          <td>
            <button class="action-btn" onclick="openRoster('${r.id}')">Open</button>
            <button class="action-btn" onclick="editRosterDetails('${r.id}')">Edit</button>
            <button class="action-btn danger" onclick="deleteRoster('${r.id}')">Delete</button>
          </td>
        </tr>
      `).join('');
    }
    
    function filterRosters() {
      renderRosterList();
    }
    
    // ============================================
    // ROSTER DETAIL VIEW
    // ============================================
    
    async function openRoster(id) {
      // Check if roster is published - block editing
      const roster = rostersData.find(r => r.id === id);
      if (roster && roster.status === 'published') {
        showToast('This roster cannot be opened for editing as it is published. Unpublish it first to make changes.', 'error');
        return;
      }
      
      try {
        document.getElementById('rosterListView').style.display = 'none';
        document.getElementById('rosterDetailView').style.display = 'flex';
        document.getElementById('rosterGantt').innerHTML = '<div style="padding: 40px; text-align: center; color: var(--text-muted);">Loading...</div>';
        
        const result = await apiRequest(`/roster/containers/${id}`);
        currentRoster = result.data;
        
        // Double-check from server response
        if (currentRoster.status === 'published') {
          showToast('This roster cannot be opened for editing as it is published. Unpublish it first to make changes.', 'error');
          backToRosterList();
          return;
        }
        
        currentRosterId = id;
        currentRosterDate = new Date(currentRoster.start_date);
        
        document.getElementById('rosterDetailTitle').textContent = `${currentRoster.code} - ${currentRoster.name}`;
        document.getElementById('rosterDetailDates').textContent = 
          `${formatDateShort(new Date(currentRoster.start_date))} to ${formatDateShort(new Date(currentRoster.end_date))}`;
        
        await loadDayView();
      } catch (err) {
        showToast(err.message || 'Failed to load roster', 'error');
        backToRosterList();
      }
    }
    
    function backToRosterList() {
      document.getElementById('rosterDetailView').style.display = 'none';
      document.getElementById('rosterListView').style.display = 'block';
      currentRoster = null;
      currentRosterId = null;
      dayViewData = null;
      loadRosters();
    }
    
    function changeRosterDay(delta) {
      if (!currentRosterDate || !currentRoster) return;
      currentRosterDate.setDate(currentRosterDate.getDate() + delta);
      
      const start = new Date(currentRoster.start_date);
      const end = new Date(currentRoster.end_date);
      if (currentRosterDate < start) currentRosterDate = new Date(start);
      if (currentRosterDate > end) currentRosterDate = new Date(end);
      
      loadDayView();
    }
    
    function goToRosterDay(dateStr) {
      if (!dateStr) return;
      currentRosterDate = new Date(dateStr);
      loadDayView();
    }
    
    async function loadDayView() {
      if (!currentRosterId || !currentRosterDate) return;
      
      const dateStr = formatDateISO(currentRosterDate);
      document.getElementById('rosterDayPicker').value = dateStr;
      
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      document.getElementById('rosterDayLabel').textContent = 
        `${dayNames[currentRosterDate.getDay()]}, ${formatDateShort(currentRosterDate)}`;
      
      // Check for public holiday and school holiday
      const holidayBadge = document.getElementById('rosterDayHoliday');
      const holiday = getAustralianHoliday(dateStr);
      const schoolHol = getSchoolHoliday(dateStr);
      
      if (holiday) {
        holidayBadge.textContent = holiday;
        holidayBadge.style.display = 'inline';
        holidayBadge.style.background = 'rgba(239, 68, 68, 0.15)';
        holidayBadge.style.color = 'var(--accent-red)';
      } else if (schoolHol) {
        holidayBadge.textContent = schoolHol;
        holidayBadge.style.display = 'inline';
        holidayBadge.style.background = 'rgba(139, 92, 246, 0.15)';
        holidayBadge.style.color = '#8b5cf6';
      } else {
        holidayBadge.style.display = 'none';
      }
      
      try {
        const result = await apiRequest(`/roster/day/${currentRosterId}/${dateStr}`);
        dayViewData = result.data;
        renderGantt();
      } catch (err) {
        document.getElementById('rosterGantt').innerHTML = 
          `<div style="padding: 40px; text-align: center; color: var(--accent-red);">Error: ${err.message}</div>`;
      }
    }
    
    function getAustralianHoliday(dateStr) {
      // Australian public holidays (QLD focused)
      const holidays = {
        // 2025
        '2025-01-01': "New Year's Day",
        '2025-01-27': "Australia Day",
        '2025-04-18': "Good Friday",
        '2025-04-19': "Easter Saturday",
        '2025-04-21': "Easter Monday",
        '2025-04-25': "ANZAC Day",
        '2025-05-05': "Labour Day (QLD)",
        '2025-06-09': "King's Birthday (QLD)",
        '2025-08-13': "Royal Queensland Show (Brisbane)",
        '2025-12-25': "Christmas Day",
        '2025-12-26': "Boxing Day",
        // 2026
        '2026-01-01': "New Year's Day",
        '2026-01-26': "Australia Day",
        '2026-04-03': "Good Friday",
        '2026-04-04': "Easter Saturday",
        '2026-04-06': "Easter Monday",
        '2026-04-25': "ANZAC Day",
        '2026-05-04': "Labour Day (QLD)",
        '2026-06-08': "King's Birthday (QLD)",
        '2026-08-12': "Royal Queensland Show (Brisbane)",
        '2026-12-25': "Christmas Day",
        '2026-12-26': "Boxing Day",
        '2026-12-28': "Boxing Day (Observed)",
        // 2027
        '2027-01-01': "New Year's Day",
        '2027-01-26': "Australia Day",
        '2027-03-26': "Good Friday",
        '2027-03-27': "Easter Saturday",
        '2027-03-29': "Easter Monday",
        '2027-04-26': "ANZAC Day (Observed)",
        '2027-05-03': "Labour Day (QLD)",
        '2027-06-14': "King's Birthday (QLD)",
        '2027-12-25': "Christmas Day",
        '2027-12-27': "Christmas Day (Observed)",
        '2027-12-26': "Boxing Day",
        '2027-12-28': "Boxing Day (Observed)",
      };
      return holidays[dateStr] || null;
    }
    
    function getSchoolHoliday(dateStr) {
      // QLD School Holidays 2025-2028
      const schoolHolidays = [
        // 2025
        { start: '2025-01-01', end: '2025-01-27', name: 'Summer Holidays' },
        { start: '2025-04-05', end: '2025-04-21', name: 'Autumn Holidays' },
        { start: '2025-06-28', end: '2025-07-13', name: 'Winter Holidays' },
        { start: '2025-09-20', end: '2025-10-06', name: 'Spring Holidays' },
        { start: '2025-12-13', end: '2025-12-31', name: 'Summer Holidays' },
        // 2026
        { start: '2026-01-01', end: '2026-01-26', name: 'Summer Holidays' },
        { start: '2026-04-03', end: '2026-04-19', name: 'Autumn Holidays' },
        { start: '2026-06-27', end: '2026-07-12', name: 'Winter Holidays' },
        { start: '2026-09-19', end: '2026-10-05', name: 'Spring Holidays' },
        { start: '2026-12-12', end: '2026-12-31', name: 'Summer Holidays' },
        // 2027
        { start: '2027-01-01', end: '2027-01-26', name: 'Summer Holidays' },
        { start: '2027-03-26', end: '2027-04-11', name: 'Autumn Holidays' },
        { start: '2027-06-26', end: '2027-07-11', name: 'Winter Holidays' },
        { start: '2027-09-18', end: '2027-10-04', name: 'Spring Holidays' },
        { start: '2027-12-11', end: '2027-12-31', name: 'Summer Holidays' },
        // 2028 (partial - for summer continuation)
        { start: '2028-01-01', end: '2028-01-23', name: 'Summer Holidays' },
      ];
      
      for (const holiday of schoolHolidays) {
        if (dateStr >= holiday.start && dateStr <= holiday.end) {
          return holiday.name;
        }
      }
      return null;
    }
    
    // ============================================
    // GANTT RENDERING
    // ============================================
    
    function renderGantt() {
      const container = document.getElementById('rosterGantt');
      if (!dayViewData) {
        container.innerHTML = '<div style="padding: 40px; text-align: center;">No data</div>';
        return;
      }
      
      const { drivers, unassigned, by_driver } = dayViewData;
      
      // Stats
      const totalBlocks = unassigned.length + Object.values(by_driver).flat().length;
      const assignedBlocks = Object.values(by_driver).flat().length;
      document.getElementById('rosterDayStats').textContent = 
        `${assignedBlocks} of ${totalBlocks} blocks assigned | ${drivers.length} drivers`;
      
      // Header
      let html = '<div class="roster-gantt-header">';
      html += '<div class="roster-gantt-driver-col">Driver</div>';
      html += '<div class="roster-gantt-timeline">';
      for (let h = GANTT_START_HOUR; h < GANTT_END_HOUR; h++) {
        html += `<div class="roster-gantt-hour">${h.toString().padStart(2, '0')}:00</div>`;
      }
      html += '</div></div>';
      
      // Driver rows
      for (const driver of drivers) {
        const driverBlocks = by_driver[driver.id] || [];
        html += renderGanttRow(driver, driverBlocks);
      }
      
      // Unassigned section - group by shift
      const unassignedByShift = {};
      for (const block of unassigned) {
        const shiftId = block.shift_template_id;
        if (!unassignedByShift[shiftId]) {
          unassignedByShift[shiftId] = {
            shift_code: block.shift_code,
            shift_name: block.shift_name,
            blocks: []
          };
        }
        unassignedByShift[shiftId].blocks.push(block);
      }
      
      // Unassigned header with toggle buttons
      const includedCount = unassigned.filter(b => b.include_in_dispatch === 1).length;
      const omittedCount = unassigned.filter(b => b.include_in_dispatch !== 1).length;
      
      html += `<div class="unassigned-header">`;
      html += `<div class="unassigned-header-title">`;
      html += `UNASSIGNED`;
      html += `<span class="unassigned-header-stats">`;
      html += `<span class="included"> ${includedCount} in dispatch</span>`;
      html += ` / <span class="omitted">${omittedCount} omitted</span>`;
      html += `</span>`;
      html += `</div>`;
      html += `<div class="unassigned-header-actions">`;
      html += `<div class="toggle-group">`;
      html += `<span class="toggle-group-label">This Day:</span>`;
      html += `<button class="btn-toggle-include" onclick="toggleDayDispatch(true)" title="Include all unassigned for this day in dispatch"> Include All</button>`;
      html += `<button class="btn-toggle-omit" onclick="toggleDayDispatch(false)" title="Omit all unassigned for this day from dispatch"> Omit All</button>`;
      html += `</div>`;
      html += `<div class="toggle-group">`;
      html += `<span class="toggle-group-label">Entire Roster:</span>`;
      html += `<button class="btn-toggle-include" onclick="toggleRosterDispatch(true)" title="Include all unassigned for entire roster period"> Include All</button>`;
      html += `<button class="btn-toggle-omit" onclick="toggleRosterDispatch(false)" title="Omit all unassigned for entire roster"> Omit All</button>`;
      html += `</div>`;
      html += `</div>`;
      html += `</div>`;
      
      // Render each shift as its own unassigned row
      for (const shiftId of Object.keys(unassignedByShift)) {
        const shift = unassignedByShift[shiftId];
        html += renderUnassignedShiftRow(shift.shift_code, shift.blocks);
      }
      
      // If no unassigned, show empty drop zone
      if (Object.keys(unassignedByShift).length === 0) {
        html += renderEmptyUnassignedRow();
      }
      
      container.innerHTML = html;
      setupDragDrop();
    }
    
    function renderEmptyUnassignedRow() {
      let html = `<div class="roster-gantt-row unassigned-row" data-driver-id="">`;
      html += `<div class="roster-gantt-driver" style="background: var(--bg-tertiary);">`;
      html += `<div class="roster-gantt-driver-name" style="color: var(--text-muted);">Unassigned</div>`;
      html += `<div class="roster-gantt-driver-id">Drop here</div>`;
      html += `</div>`;
      html += `<div class="roster-gantt-blocks" data-driver-id="">`;
      for (let h = 0; h < GANTT_HOURS; h++) {
        html += `<div class="roster-gantt-grid-line" style="left: ${(h / GANTT_HOURS) * 100}%;"></div>`;
      }
      html += `</div></div>`;
      return html;
    }
    
    function renderUnassignedShiftRow(shiftCode, blocks) {
      let html = `<div class="roster-gantt-row unassigned-row" data-driver-id="">`;
      html += `<div class="roster-gantt-driver" style="background: var(--bg-tertiary);">`;
      html += `<div class="roster-gantt-driver-name" style="color: var(--text-muted);">${shiftCode}</div>`;
      html += `<div class="roster-gantt-driver-id" style="color: var(--text-muted);">${blocks.length} block${blocks.length !== 1 ? 's' : ''}</div>`;
      html += `</div>`;
      
      html += `<div class="roster-gantt-blocks" data-driver-id="">`;
      
      // Grid lines
      for (let h = 0; h < GANTT_HOURS; h++) {
        html += `<div class="roster-gantt-grid-line" style="left: ${(h / GANTT_HOURS) * 100}%;"></div>`;
      }
      
      // Blocks
      for (const block of blocks) {
        const startPct = ((block.start_time - GANTT_START_HOUR) / GANTT_HOURS) * 100;
        const widthPct = ((block.end_time - block.start_time) / GANTT_HOURS) * 100;
        if (startPct < 0 || startPct >= 100) continue;
        
        const color = getShiftColor(block.shift_type);
        const hasMultiple = block.blocks_in_shift > 1;
        const hasDefault = block.default_driver_id && !block.assigned_driver_id;
        const isIncluded = block.include_in_dispatch === 1;
        
        html += `<div class="roster-gantt-block" 
          style="left: ${Math.max(0, startPct)}%; width: ${Math.min(widthPct, 100 - startPct)}%; background: ${color};"
          draggable="true"
          data-block-id="${block.id}"
          data-shift-id="${block.shift_template_id}"
          data-entry-id="${block.entry_id || ''}"
          data-has-multiple="${hasMultiple}"
          ondragstart="onBlockDragStart(event)"
          onclick="showBlockInfo('${block.id}')"
        >`;
        
        // Dispatch toggle button
        const toggleClass = isIncluded ? 'included' : 'omitted';
        const toggleIcon = isIncluded ? '' : '';
        const toggleTitle = isIncluded ? 'Included in dispatch - click to omit' : 'Omitted from dispatch - click to include';
        html += `<button class="dispatch-toggle-btn ${toggleClass}" 
          onclick="event.stopPropagation(); toggleBlockDispatch('${block.id}', '${block.shift_template_id}', ${!isIncluded})" 
          title="${toggleTitle}">${toggleIcon}</button>`;
        
        html += `<div class="roster-gantt-block-name">${block.shift_code} / ${block.block_name}</div>`;
        html += `<div class="roster-gantt-block-time">${formatDecimalTime(block.start_time)} - ${formatDecimalTime(block.end_time)}</div>`;
        
        if (hasDefault) {
          html += `<button class="quick-assign-btn" onclick="event.stopPropagation(); quickAssign('${block.id}', '${block.shift_template_id}', '${block.default_driver_id}')" title="Assign to ${block.default_driver_name}"></button>`;
        }
        
        html += `</div>`;
      }
      
      html += `</div></div>`;
      return html;
    }
    
    function renderGanttRow(driver, blocks) {
      const driverId = driver.id;
      const driverName = `${driver.first_name} ${driver.last_name}`;
      const driverNumber = driver.employee_number;
      
      let html = `<div class="roster-gantt-row" data-driver-id="${driverId}">`;
      html += `<div class="roster-gantt-driver">`;
      html += `<div class="roster-gantt-driver-name">${driverName}</div>`;
      html += `<div class="roster-gantt-driver-id">${driverNumber}</div>`;
      html += `</div>`;
      
      html += `<div class="roster-gantt-blocks" data-driver-id="${driverId}">`;
      
      // Grid lines
      for (let h = 0; h < GANTT_HOURS; h++) {
        html += `<div class="roster-gantt-grid-line" style="left: ${(h / GANTT_HOURS) * 100}%;"></div>`;
      }
      
      // Blocks
      for (const block of blocks) {
        const startPct = ((block.start_time - GANTT_START_HOUR) / GANTT_HOURS) * 100;
        const widthPct = ((block.end_time - block.start_time) / GANTT_HOURS) * 100;
        if (startPct < 0 || startPct >= 100) continue;
        
        const color = getShiftColor(block.shift_type);
        const hasMultiple = block.blocks_in_shift > 1;
        
        html += `<div class="roster-gantt-block" 
          style="left: ${Math.max(0, startPct)}%; width: ${Math.min(widthPct, 100 - startPct)}%; background: ${color};"
          draggable="true"
          data-block-id="${block.id}"
          data-shift-id="${block.shift_template_id}"
          data-entry-id="${block.entry_id || ''}"
          data-has-multiple="${hasMultiple}"
          ondragstart="onBlockDragStart(event)"
          onclick="showBlockInfo('${block.id}')"
        >`;
        html += `<div class="roster-gantt-block-name">${block.shift_code} / ${block.block_name}</div>`;
        html += `<div class="roster-gantt-block-time">${formatDecimalTime(block.start_time)} - ${formatDecimalTime(block.end_time)}</div>`;
        html += `</div>`;
      }
      
      html += `</div></div>`;
      return html;
    }
    
    function getShiftColor(shiftType) {
      const colors = {
        regular: '#3b82f6',
        charter: '#a855f7',
        school: '#22c55e',
      };
      return colors[shiftType] || '#3b82f6';
    }
    
    // ============================================
    // DRAG & DROP
    // ============================================
    
    function setupDragDrop() {
      document.querySelectorAll('.roster-gantt-blocks').forEach(container => {
        container.addEventListener('dragover', e => {
          e.preventDefault();
          container.classList.add('drag-over');
        });
        
        container.addEventListener('dragleave', () => {
          container.classList.remove('drag-over');
        });
        
        container.addEventListener('drop', async e => {
          e.preventDefault();
          container.classList.remove('drag-over');
          
          const blockId = e.dataTransfer.getData('blockId');
          const shiftId = e.dataTransfer.getData('shiftId');
          const hasMultiple = e.dataTransfer.getData('hasMultiple') === 'true';
          const newDriverId = container.dataset.driverId || null;
          
          if (hasMultiple && newDriverId) {
            // Show modal asking about connected blocks
            pendingAssignment = { blockId, shiftId, driverId: newDriverId };
            showConnectedModal();
          } else {
            // Direct assign
            await doAssign(blockId, shiftId, newDriverId, false);
          }
        });
      });
    }
    
    function onBlockDragStart(e) {
      const target = e.target.closest('.roster-gantt-block');
      e.dataTransfer.setData('blockId', target.dataset.blockId);
      e.dataTransfer.setData('shiftId', target.dataset.shiftId);
      e.dataTransfer.setData('hasMultiple', target.dataset.hasMultiple);
      target.classList.add('dragging');
      setTimeout(() => target.classList.remove('dragging'), 100);
    }
    
    // ============================================
    // ASSIGNMENT API
    // ============================================
    
    async function doAssign(blockId, shiftId, driverId, includeConnected) {
      try {
        const result = await apiRequest('/roster/assign', {
          method: 'POST',
          body: {
            roster_id: currentRosterId,
            shift_template_id: shiftId,
            duty_block_id: blockId,
            date: formatDateISO(currentRosterDate),
            driver_id: driverId,
            include_connected: includeConnected,
          }
        });
        
        // Check if API returned an error
        if (result.error) {
          showToast(result.error, 'error');
          return;
        }
        
        showToast(driverId ? 'Block assigned' : 'Block unassigned');
        await loadDayView();
      } catch (err) {
        showToast(err.message || 'Assignment failed', 'error');
      }
    }
    
    async function quickAssign(blockId, shiftId, defaultDriverId) {
      // Find the block to check if it has multiple
      let hasMultiple = false;
      if (dayViewData) {
        const allBlocks = [...dayViewData.unassigned, ...Object.values(dayViewData.by_driver).flat()];
        const block = allBlocks.find(b => b.id === blockId);
        hasMultiple = block?.blocks_in_shift > 1;
      }
      
      if (hasMultiple) {
        pendingAssignment = { blockId, shiftId, driverId: defaultDriverId };
        showConnectedModal();
      } else {
        await doAssign(blockId, shiftId, defaultDriverId, false);
      }
    }
    
    // ============================================
    // DISPATCH TOGGLE FUNCTIONS
    // ============================================
    
    async function toggleBlockDispatch(blockId, shiftId, include) {
      try {
        const result = await apiRequest('/roster/toggle-dispatch', {
          method: 'POST',
          body: {
            roster_id: currentRosterId,
            duty_block_id: blockId,
            shift_template_id: shiftId,
            date: formatDateISO(currentRosterDate),
            include: include
          }
        });
        
        if (result.error) {
          showToast(result.error, 'error');
          return;
        }
        
        showToast(include ? 'Block included in dispatch' : 'Block omitted from dispatch');
        await loadDayView();
      } catch (err) {
        showToast(err.message || 'Toggle failed', 'error');
      }
    }
    
    async function toggleDayDispatch(include) {
      try {
        const result = await apiRequest('/roster/toggle-dispatch-day', {
          method: 'POST',
          body: {
            roster_id: currentRosterId,
            date: formatDateISO(currentRosterDate),
            include: include
          }
        });
        
        if (result.error) {
          showToast(result.error, 'error');
          return;
        }
        
        showToast(result.message || (include ? 'All included' : 'All omitted'));
        await loadDayView();
      } catch (err) {
        showToast(err.message || 'Toggle failed', 'error');
      }
    }
    
    async function toggleRosterDispatch(include) {
      if (!confirm(`This will ${include ? 'include' : 'omit'} ALL unassigned blocks for the ENTIRE roster period. Continue?`)) {
        return;
      }
      
      try {
        showToast('Processing...', 'info');
        
        const result = await apiRequest('/roster/toggle-dispatch-all', {
          method: 'POST',
          body: {
            roster_id: currentRosterId,
            include: include
          }
        });
        
        if (result.error) {
          showToast(result.error, 'error');
          return;
        }
        
        showToast(result.message || (include ? 'All included' : 'All omitted'), 'success');
        await loadDayView();
      } catch (err) {
        showToast(err.message || 'Toggle failed', 'error');
      }
    }
    
    function showBlockInfo(blockId) {
      if (!dayViewData) return;
      const allBlocks = [...dayViewData.unassigned, ...Object.values(dayViewData.by_driver).flat()];
      const block = allBlocks.find(b => b.id === blockId);
      if (block) {
        showToast(`${block.shift_code} / ${block.block_name}: ${formatDecimalTime(block.start_time)} - ${formatDecimalTime(block.end_time)}`);
      }
    }
    
    // ============================================
    // CONNECTED BLOCKS MODAL
    // ============================================
    
    function showConnectedModal() {
      document.getElementById('connectedModalOverlay').classList.add('show');
    }
    
    function closeConnectedModal() {
      document.getElementById('connectedModalOverlay').classList.remove('show');
      pendingAssignment = null;
    }
    
    async function confirmConnected(includeAll) {
      if (!pendingAssignment) return;
      const { blockId, shiftId, driverId } = pendingAssignment;
      closeConnectedModal();
      await doAssign(blockId, shiftId, driverId, includeAll);
    }
    
    // ============================================
    // ROSTER CRUD MODALS
    // ============================================
    
    let editingRosterId = null;
    
    function showAddRosterModal() {
      document.getElementById('rosterModalTitle').textContent = 'New Roster';
      document.getElementById('rosterForm').reset();
      
      const today = new Date();
      const daysUntilMonday = (8 - today.getDay()) % 7 || 7;
      const nextMonday = new Date(today);
      nextMonday.setDate(today.getDate() + daysUntilMonday);
      const nextSunday = new Date(nextMonday);
      nextSunday.setDate(nextMonday.getDate() + 6);
      
      document.getElementById('rosterStartDate').value = formatDateISO(nextMonday);
      document.getElementById('rosterEndDate').value = formatDateISO(nextSunday);
      
      editingRosterId = null;
      document.getElementById('rosterModalOverlay').classList.add('show');
    }
    
    function editRosterDetails(id) {
      const roster = rostersData.find(r => r.id === id);
      if (!roster) return;
      
      // Block editing if roster is published
      if (roster.status === 'published') {
        showToast('This roster cannot be edited as it is published to the Ops calendar. Unpublish the roster to make changes.', 'error');
        return;
      }
      
      document.getElementById('rosterModalTitle').textContent = 'Edit Roster';
      document.getElementById('rosterCode').value = roster.code;
      document.getElementById('rosterName').value = roster.name;
      document.getElementById('rosterStartDate').value = roster.start_date;
      document.getElementById('rosterEndDate').value = roster.end_date;
      document.getElementById('rosterStatus').value = roster.status || 'draft';
      document.getElementById('rosterNotes').value = roster.notes || '';
      
      editingRosterId = id;
      document.getElementById('rosterModalOverlay').classList.add('show');
    }
    
    function closeRosterModal() {
      document.getElementById('rosterModalOverlay').classList.remove('show');
      editingRosterId = null;
    }
    
    async function saveRoster() {
      const data = {
        code: document.getElementById('rosterCode').value,
        name: document.getElementById('rosterName').value,
        start_date: document.getElementById('rosterStartDate').value,
        end_date: document.getElementById('rosterEndDate').value,
        status: document.getElementById('rosterStatus').value,
        notes: document.getElementById('rosterNotes').value || null,
      };
      
      if (!data.code || !data.name || !data.start_date || !data.end_date) {
        showToast('Please fill in all required fields', 'error');
        return;
      }
      
      try {
        if (editingRosterId) {
          await apiRequest(`/roster/containers/${editingRosterId}`, { method: 'PUT', body: data });
          showToast('Roster updated');
        } else {
          await apiRequest('/roster/containers', { method: 'POST', body: data });
          showToast('Roster created');
        }
        closeRosterModal();
        loadRosters();
      } catch (err) {
        showToast(err.message || 'Failed to save', 'error');
      }
    }
    
    async function deleteRoster(id) {
      if (!confirm('Delete this roster and all assignments?')) return;
      try {
        await apiRequest(`/roster/containers/${id}`, { method: 'DELETE' });
        showToast('Roster deleted');
        loadRosters();
      } catch (err) {
        showToast(err.message || 'Failed to delete', 'error');
      }
    }
    
    // Legacy aliases
    async function loadRoster() { await loadRosters(); }
    function renderRosterTable() { renderRosterList(); }
    function showAddRosterEntryModal() { showAddRosterModal(); }
    
    // ============================================
    // NAVIGATION HOOKS
    // ============================================
    const originalNavigateTo = navigateTo;
    navigateTo = function(screen) {
      originalNavigateTo(screen);
      
      // Load data for the screen
      if (screen === 'hrm') {
        loadEmployees();
      } else if (screen === 'vehicles') {
        loadVehiclesData();
      } else if (screen === 'shifts') {
        loadShifts();
      } else if (screen === 'roster') {
        loadRoster();
      }
    };

    init();
  </script>
  
  <!-- Employee Modal -->
  <div class="crud-modal-overlay" id="employeeModalOverlay">
    <div class="crud-modal">
      <div class="crud-modal-header">
        <span class="crud-modal-title" id="employeeModalTitle">Add Employee</span>
        <button class="crud-modal-close" onclick="closeEmployeeModal()">&times;</button>
      </div>
      <div class="crud-modal-body">
        <form id="employeeForm" onsubmit="event.preventDefault(); saveEmployee();">
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Employee Number *</label>
              <input type="text" id="empNumber" class="form-input" required>
            </div>
            <div class="form-group">
              <label class="form-label">Role</label>
              <select id="empRole" class="form-input">
                <option value="driver">Driver</option>
                <option value="dispatcher">Dispatcher</option>
                <option value="admin">Admin</option>
              </select>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">First Name *</label>
              <input type="text" id="empFirstName" class="form-input" required>
            </div>
            <div class="form-group">
              <label class="form-label">Last Name *</label>
              <input type="text" id="empLastName" class="form-input" required>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Email</label>
              <input type="email" id="empEmail" class="form-input">
            </div>
            <div class="form-group">
              <label class="form-label">Phone</label>
              <input type="tel" id="empPhone" class="form-input">
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Licence Number</label>
              <input type="text" id="empLicence" class="form-input">
            </div>
            <div class="form-group">
              <label class="form-label">Status</label>
              <select id="empStatus" class="form-input">
                <option value="active">Active</option>
                <option value="inactive">Inactive</option>
              </select>
            </div>
          </div>
        </form>
      </div>
      <div class="crud-modal-footer">
        <button class="btn-secondary" onclick="closeEmployeeModal()">Cancel</button>
        <button class="btn-primary" onclick="saveEmployee()">Save</button>
      </div>
    </div>
  </div>
  
  <!-- Vehicle Modal -->
  <div class="crud-modal-overlay" id="vehicleModalOverlay">
    <div class="crud-modal">
      <div class="crud-modal-header">
        <span class="crud-modal-title" id="vehicleModalTitle">Add Vehicle</span>
        <button class="crud-modal-close" onclick="closeVehicleModal()">&times;</button>
      </div>
      <div class="crud-modal-body">
        <form id="vehicleForm" onsubmit="event.preventDefault(); saveVehicle();">
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Fleet Number *</label>
              <input type="text" id="vehFleet" class="form-input" required>
            </div>
            <div class="form-group">
              <label class="form-label">Registration *</label>
              <input type="text" id="vehRego" class="form-input" required>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Capacity *</label>
              <input type="number" id="vehCapacity" class="form-input" min="1" required>
            </div>
            <div class="form-group">
              <label class="form-label">Status</label>
              <select id="vehStatus" class="form-input">
                <option value="active">Active</option>
                <option value="inactive">Inactive</option>
                <option value="sold">Sold</option>
              </select>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Make</label>
              <input type="text" id="vehMake" class="form-input">
            </div>
            <div class="form-group">
              <label class="form-label">Model</label>
              <input type="text" id="vehModel" class="form-input">
            </div>
          </div>
          <div class="form-group">
            <label class="form-label">Year</label>
            <input type="number" id="vehYear" class="form-input" min="1900" max="2099">
          </div>
        </form>
      </div>
      <div class="crud-modal-footer">
        <button class="btn-secondary" onclick="closeVehicleModal()">Cancel</button>
        <button class="btn-primary" onclick="saveVehicle()">Save</button>
      </div>
    </div>
  </div>
  
  <!-- Cancel Duty Confirmation Modal -->
  <div class="crud-modal-overlay" id="cancelDutyModalOverlay">
    <div class="crud-modal" style="width: 400px;">
      <div class="crud-modal-header">
        <span class="crud-modal-title">Cancel Duty Line</span>
        <button class="crud-modal-close" onclick="closeCancelDutyModal()">&times;</button>
      </div>
      <div class="crud-modal-body">
        <p style="margin-bottom: 16px; color: var(--text-secondary);">
          This will cancel the duty line for dispatch purposes only. The roster will not be affected.
        </p>
        <div id="cancelDutyInfo" style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px; margin-bottom: 16px;">
          <!-- Duty info will be populated here -->
        </div>
        <div class="form-group">
          <label class="form-label">Reason (optional)</label>
          <input type="text" id="cancelDutyReason" class="form-input" placeholder="e.g. Customer cancelled, Weather...">
        </div>
      </div>
      <div class="crud-modal-footer">
        <button class="btn-secondary" onclick="closeCancelDutyModal()">Keep Active</button>
        <button class="btn-primary" style="background: var(--accent-amber);" onclick="confirmCancelDuty()">Cancel Duty</button>
      </div>
    </div>
  </div>
  
  <!-- Shift Template Modal -->
  <div class="crud-modal-overlay" id="shiftModalOverlay">
    <div class="crud-modal crud-modal-wide">
      <div class="crud-modal-header">
        <span class="crud-modal-title" id="shiftModalTitle">Add Shift Template</span>
        <button class="crud-modal-close" onclick="closeShiftModal()">&times;</button>
      </div>
      <div class="crud-modal-body">
        <form id="shiftForm" onsubmit="event.preventDefault(); saveShift();">
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Code *</label>
              <input type="text" id="shiftCode" class="form-input" placeholder="e.g. AM-01" required>
            </div>
            <div class="form-group">
              <label class="form-label">Name *</label>
              <input type="text" id="shiftName" class="form-input" placeholder="e.g. Morning Route 1" required>
            </div>
            <div class="form-group">
              <label class="form-label">Type</label>
              <select id="shiftType" class="form-input">
                <option value="regular">Regular</option>
                <option value="charter">Charter</option>
                <option value="school">School</option>
              </select>
            </div>
          </div>
          
          <div class="form-section">
            <div class="form-section-header">
              <span class="form-section-title">Duties</span>
              <button type="button" class="btn-small" onclick="addShiftDutyBlock()">+ Add Duty</button>
            </div>
            <div class="duty-blocks-container" id="shiftDutyBlocks">
              <div class="duty-editor-empty">No duties added. Click "+ Add Duty" to start.</div>
            </div>
            <div class="duty-editor-totals" id="shiftDutyTotals"></div>
          </div>
          
          <div class="form-group">
            <label class="form-label">Notes</label>
            <textarea id="shiftNotes" class="form-input" rows="2"></textarea>
          </div>
        </form>
      </div>
      <div class="crud-modal-footer">
        <button class="btn-secondary" onclick="closeShiftModal()">Cancel</button>
        <button class="btn-primary" onclick="saveShift()">Save</button>
      </div>
    </div>
  </div>
  
  <!-- Roster Modal -->
  <div class="crud-modal-overlay" id="rosterModalOverlay">
    <div class="crud-modal">
      <div class="crud-modal-header">
        <span class="crud-modal-title" id="rosterModalTitle">New Roster</span>
        <button class="crud-modal-close" onclick="closeRosterModal()">&times;</button>
      </div>
      <div class="crud-modal-body">
        <form id="rosterForm" onsubmit="event.preventDefault(); saveRoster();">
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Code *</label>
              <input type="text" id="rosterCode" class="form-input" required placeholder="e.g. WK01-JAN25">
            </div>
            <div class="form-group">
              <label class="form-label">Name *</label>
              <input type="text" id="rosterName" class="form-input" required placeholder="e.g. Week 1 January 2025">
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Start Date *</label>
              <input type="date" id="rosterStartDate" class="form-input" required>
            </div>
            <div class="form-group">
              <label class="form-label">End Date *</label>
              <input type="date" id="rosterEndDate" class="form-input" required>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Status</label>
              <select id="rosterStatus" class="form-input">
                <option value="draft">Draft</option>
                <option value="published">Published</option>
                <option value="archived">Archived</option>
              </select>
            </div>
          </div>
          <div class="form-group">
            <label class="form-label">Notes</label>
            <textarea id="rosterNotes" class="form-input" rows="2" placeholder="Optional notes..."></textarea>
          </div>
        </form>
      </div>
      <div class="crud-modal-footer">
        <button class="btn-secondary" onclick="closeRosterModal()">Cancel</button>
        <button class="btn-primary" onclick="saveRoster()">Save Roster</button>
      </div>
    </div>
  </div>
  
  <!-- Schedule Roster Modal -->
  <div class="schedule-modal-overlay" id="scheduleModalOverlay">
    <div class="schedule-modal">
      <div class="schedule-modal-header">
        <span class="schedule-modal-title">Add Roster to Calendar</span>
        <button class="schedule-modal-close" onclick="closeScheduleModal()">&times;</button>
      </div>
      <div class="schedule-modal-body">
        <div style="margin-bottom: 16px;">
          <strong id="scheduleRosterName"></strong>
          <div id="scheduleValidRange" style="font-size: 12px; color: var(--text-muted); margin-top: 4px;"></div>
        </div>
        <div class="form-group" style="margin-bottom: 12px;">
          <label class="form-label">Calendar Start Date</label>
          <input type="date" id="scheduleStartDate" class="form-input">
        </div>
        <div class="form-group">
          <label class="form-label">Calendar End Date</label>
          <input type="date" id="scheduleEndDate" class="form-input">
        </div>
        <p style="font-size: 11px; color: var(--text-muted); margin-top: 12px;">
          The roster will appear on the calendar for these dates. You can schedule a subset of the roster's valid date range.
        </p>
      </div>
      <div class="schedule-modal-footer">
        <button class="btn-secondary" onclick="closeScheduleModal()">Cancel</button>
        <button class="btn-primary" onclick="confirmScheduleRoster()">Add to Calendar</button>
      </div>
    </div>
  </div>
  
  <!-- Connected Blocks Modal -->
  <div class="crud-modal-overlay" id="connectedModalOverlay">
    <div class="crud-modal" style="max-width: 400px;">
      <div class="crud-modal-header">
        <span class="crud-modal-title">Multiple Blocks in Shift</span>
        <button class="crud-modal-close" onclick="closeConnectedModal()">&times;</button>
      </div>
      <div class="crud-modal-body">
        <p style="margin: 0 0 16px 0; color: var(--text-secondary);">
          This shift has multiple duty blocks. Would you like to assign all connected blocks to this driver?
        </p>
      </div>
      <div class="crud-modal-footer" style="justify-content: space-between;">
        <button class="btn-secondary" onclick="confirmConnected(false)">Just This Block</button>
        <button class="btn-primary" onclick="confirmConnected(true)">All Connected Blocks</button>
      </div>
    </div>
  </div>
</body>
</html>
